<?xml version="1.0" encoding="ISO-8859-1"?>
     <!-- Embedded DTD for validation -->
     <!DOCTYPE upload [
     <!ELEMENT compile (#PCDATA)>
     <!ATTLIST compile
      condition CDATA #REQUIRED
     >
     <!ELEMENT copysrc (#PCDATA)>
     <!ELEMENT install_instructions (#PCDATA)>
     <!ELEMENT install_program (#PCDATA)>
     <!ELEMENT mbr (copysrc)>
     <!ATTLIST mbr
      mbrname CDATA #REQUIRED
      mbrtype CDATA #REQUIRED
      mbrtext CDATA #REQUIRED
      srcfile CDATA #REQUIRED
      srclib CDATA #REQUIRED
      srclen CDATA #REQUIRED
      srccssid CDATA #REQUIRED
     >
     <!ELEMENT qcmdexc (#PCDATA)>
     <!ATTLIST qcmdexc
      condition CDATA #REQUIRED
      release CDATA #REQUIRED
      dltsplf CDATA #REQUIRED
     >
     <!ELEMENT qrycond (#PCDATA)>
     <!ATTLIST qrycond
      msg CDATA #REQUIRED
      values CDATA #REQUIRED
      var CDATA #REQUIRED
     >
     <!ELEMENT sendmsg (#PCDATA)>
     <!ATTLIST sendmsg
      sendmsgid CDATA #REQUIRED
      sendmsgtype CDATA #REQUIRED
     >
     <!ELEMENT rtvobjd (#PCDATA)>
     <!ATTLIST rtvobjd
      condition CDATA #REQUIRED
      obj CDATA #REQUIRED
      lib CDATA #REQUIRED
      objtype CDATA #REQUIRED
      rtnlib CDATA #IMPLIED
     >
     <!ELEMENT upload (install_instructions | install_program | qrycond |
                       qcmdexc | sendmsg | mbr | compile | rtvobjd | chgvar)+>
     <!ATTLIST upload
      appname CDATA #REQUIRED
      appauthor CDATA #REQUIRED
      appblddate CDATA #REQUIRED
     >
     ]>
<upload  appname="EVENTF"  appauthor="Thomas Raddatz"  appblddate="12/25/2020">
<install_instructions><![CDATA[
     *----------------------------------------------------------------      ------
     *  1. Upload entire XML to your AS/400 to a source file 112 long, into any mbr
     *     name not in this XML (suggest member name like ABCX or XYZX). The source
     *     file must be in the library where source and objects are to be installed.
     *
     *  2. If you have XMLPREVIEW installed, skip to step 3.
     *
     *     Copy the text between the start tag <install_program> and the end
     *     tag </install_program> into any member name (your choice)
     *     in file QRPGLESRC member type RPGLE.   CRTBNDRPG to compile.
     *     NOTE: You need extract the install program only once, this same program
     *           will install any upload on this page.
     *
     *  3. Call the install program (or execute XmlPrevew) passing these 3 parms.
     *       'your-member-name you uploaded this text into'
     *       'your-source-file-name the member is in'
     *       'your-library-name the source file is in'
     *
     *  The various source members will be extracted and the objects required
     *   for the application will be created in your-library-name.
     *----------------------------------------------------------------      ------
]]>  </install_instructions>
<install_program><![CDATA[
      * /// START OF INSTALL PGM HERE   ************************** ///
      *---------------------------------------------------------------------------------------
      * CRTBNDRPG PGM(QTEMP/XMLINST) SRCFILE(ISPHERE/QBUILD) SRCMBR(*PGM)
      *---------------------------------------------------------------------------------------
      * Parse / Install from xml text into source members and objects.
      * Copyright (C) 2001    Craig Rutledge    <craig_rutledge@mohawkind.com>
      * Martin Rowe    <Martin@dbg400.net>          scripting cmd prompts
      * David George   <webmaster@400times.co.uk>   intellectual input
      * Thomas Raddatz <thomas.raddatz@tools400.de> execute SQL statements
      * Thomas Raddatz <thomas.raddatz@tools400.de> conditions
      * Thomas Raddatz <thomas.raddatz@tools400.de> release
      * Thomas Raddatz <thomas.raddatz@tools400.de> retrieve object description
      *
      * Use xml tags in text to trigger:
      * 1. Parse text into source members (create srcfile & member if required).
      * 2. Compile source into objects.
      * 3. Send installation progress user messages.
      * 4. Execute qcmdexc as required.
      * 5. Execute SQL statements as required.
      *
      * This program is free software, you can redistribute it and/or modify it
      * under the terms of the GNU General Public License as published by
      * the Free Software Foundation.  See GNU General Public License for details
      *---------------------------------------------------------------------------------------
      * >>PRE-COMPILER<<
      *   >>CRTCMD<< CRTBNDRPG    PGM(&LI/&OB) SRCFILE(&SL/&SF) SRCMBR(*PGM) +
      *                           DBGVIEW(*LIST) OPTION(*EVENTF);
      *   >>EXECUTE<<
      * >>END-PRE-COMPILER<<
      *---------------------------------------------------------------------------------------
     H DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('QC2LE')
      *---------------------------------------------------------------------------------------
     Fxmlinput  if   f  112        disk    usropn                               uploaded text
     Fqxxxsrc   o    f  112        disk    usropn                               parsed out
      *--------------------------------------------------------------------
      * create parm prototypes
      *--------------------------------------------------------------------
      *  Tokenize String
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_token                        *   value  options(*string)
      * retrieve member description
     D qusrmbrd        PR                  ExtPgm('QUSRMBRD')                   MEMBER DESCRIPTION
     D  o_rcvVar                  32767a          options(*varsize)             RECEIVER
     D  i_lenRcvVar                  10i 0 const                                LENGTH OF RECVR
     D  i_format                      8    const                                UPLOAD TYPE
     D  i_qFile                      20    const                                FILE   LIB
     D  i_mbr                        10    const                                MEMBER NAME
     D  i_ovverride                   1    const                                PROCESS OVERIDE
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * retrieve object description
     D QUSROBJD...
     D                 PR                         extpgm('QUSROBJD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_type                       10A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    | OptGrp 1
      * send program message
     D qmhsndpm        PR                  ExtPgm('QMHSNDPM')                   SEND MESSAGES
     D  i_msgID                       7a   const                                ID
     D  i_qMsgF                      20a   const                                FILE
     D  i_msgText                 32767a   const  options(*varsize)             TEXT
     D  i_lenMsgText                 10i 0 const                                LENGTH
     D  i_msgType                    10a   const                                TYPE
     D  i_callStackE                 10a   const                                STACK ENTRY
     D  i_callStackC                 10i 0 const                                STACK COUNTER
     D  i_msgKey                      4a   const                                KEY
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * execute cl command
     D  qcmdexc        PR                  ExtPgm('QCMDEXC')
     D  i_cmd                        50a   Const
     D  i_lenCmd                     15p 5 Const
      *  Allocate Environment Handle
     D SQLAllocEnv...
     D                 PR                         extproc('SQLAllocEnv')
     D                                     like(SQLRETURN_t )
     D  o_phenv                        *   value
      *  Allocate Connection Handle
     D SQLAllocConnect...
     D                 PR                         extproc('SQLAllocConnect')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
     D  o_phdbc                        *   value
      *  Connect to a Data Source
     D SQLConnect...
     D                 PR                         extproc('SQLConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_szDSN                        *   value  options(*string)
     D  i_cbDSN                            value  like(SQLSMALLINT_t)
     D  i_szUID                        *   value  options(*string)
     D  i_cbUID                            value  like(SQLSMALLINT_t)
     D  i_szAuthStr                    *   value  options(*string)
     D  i_cbAuthStr                        value  like(SQLSMALLINT_t)
      *  Set Connection Option
     D SQLSetConnectOption...
     D                 PR                         extproc('SQLSetConnectOption')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_fOption                          value  like(SQLSMALLINT_t)
     D  i_vParam                           value  like(SQLPOINTER_t )
      *  Allocate a Statement Handle
     D SQLAllocStmt...
     D                 PR                         extproc('SQLAllocStmt')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  o_phstmt                       *   value
      *  Execute a Statement Directly
     D SQLExecDirect...
     D                 PR                         extproc('SQLExecDirect')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_szSqlStr                     *   value  options(*string)
     D  i_cbSqlStr                         value  like(SQLINTEGER_t)
      *  Free (or Reset) a Statement Handle
     D SQLFreeStmt...
     D                 PR                         extproc('SQLFreeStmt')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_fOption                          value  like(SQLSMALLINT_t)
      *  Disconnect from a Data Source
     D SQLDisconnect...
     D                 PR                         extproc('SQLDisconnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Connection Handle
     D SQLFreeConnect...
     D                 PR                         extproc('SQLFreeConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Environment Handle
     D SQLFreeEnv...
     D                 PR                         extproc('SQLFreeEnv')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
      *--------------------------------------------------------------------
     D long_t          S             10I 0                    based(pDummy)
     D short_t         S              5I 0                    based(pDummy)
      *
     D SQLINTEGER_t    S                   like(long_t      ) based(pDummy)
     D SQLSMALLINT_t   S                   like(short_t     ) based(pDummy)
      *
     D PTR_t           S               *                      based(pDummy)
     D SQLPOINTER_t    S                   like(PTR_t       ) based(pDummy)
     D HENV_t          S                   like(long_t      ) based(pDummy)
     D HDBC_t          S                   like(long_t      ) based(pDummy)
     D HSTMT_t         S                   like(long_t      ) based(pDummy)
     D RETCODE_t       S                   like(SQLINTEGER_t) based(pDummy)
      *
     D SQLHENV_t       S                   like(HENV_t      ) based(pDummy)
     D SQLHDBC_t       S                   like(HDBC_t      ) based(pDummy)
     D SQLHSTMT_t      S                   like(HSTMT_t     ) based(pDummy)
     D SQLRETURN_t     S                   like(RETCODE_t   ) based(pDummy)
      *
     D retCode         S                   like(SQLRETURN_t) inz
     D hdbc            S                   like(SQLHDBC_t  ) inz
     D hstmt           S                   like(SQLHSTMT_t ) inz
     D henv            S                   like(SQLHENV_t  ) inz
     D sqlInit         S              1A                     inz(*off)
     D cOptVal         S             10I 0                   inz
      *
     D SQL_NTS         C                   const( -3)
     D SQL_COMMIT_NONE...
     D                 C                   const(  1)
     D SQL_ATTR_COMMIT...
     D                 C                   const(  0)
     D SQL_DROP        C                   const(  1)
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     D readElement     PR                        like(bldexc)
     D  i_element                     9A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to double quotes in a string
      *--------------------------------------------------------------------
     D dblQuotes       PR          2048A         varying
     D  i_string                   2048A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to get attribute data from a string
      *--------------------------------------------------------------------
     D getAttrData...
     D                 PR          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *--------------------------------------------------------------------
      * Define function prototype to check for a condition
      *--------------------------------------------------------------------
     D isCondition...
     D                 PR              n
     D  i_condList                 2000A   value
      *---------------------------------------------------------------------------------------
     D loadConditions...
     D                 PR                  dim(32) like(condition)
     D  i_conditions                128A   value
      *--------------------------------------------------------------------
     D getCurrentRelease...
     D                 PR            10A
      *--------------------------------------------------------------------
     D isRelease...
     D                 PR              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *--------------------------------------------------------------------
     D setTargetRelease...
     D                 PR          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *--------------------------------------------------------------------
     D setVariable...
     D                 PR
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
      *---------------------------------------------------------------------------------------------
     D getVarName...
     D                 PR            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
      *---------------------------------------------------------------------------------------------
     D getVarValue...
     D                 PR            64a          varying
     D  i_name                       11a   value  varying
      *---------------------------------------------------------------------------------------------
     D uCase...
     D                 PR          2000A          varying
     D  i_string                   2000A   value  varying
      *--------------------------------------------------------------------
     D vrcvar          s            145
     D qm_msgid        s              7
     D qm_msgtxt       s            500
     D qm_msgq         s             10
     D qm_msgtyp       s             10
     D mbrname         s             10
     D mbrtype         s             10
     D mbrtext         s             50
     D srcfile         s             10
     D srclen          s              5
     D srclenN         s              5  0   inz(0)
     D srccssid        s              5
     D bldexc          s           2000
     D write_flag      s              1n   inz(*off)
     D srcSeqno        s              6s 2 inz(0)
     D aa              s              5u 0 inz(0)
     D ll              s              5u 0 inz(0)
     D qs              c                   ''''
     D qd              c                   '"'
     D errFLag         s              1    inz(*off)
     D cnd_msg         s             42
     D cnd_values      s            110
     D cnd_var         s             10
     D cnd_rtnVal      s             10
     D cnd_array       s                   dim(32) inz like(condition)
     D cnd_ptr         s             10i 0 inz
     D condition       s             10a
     D condList        s           2000a
     D release         s             10a
     D dltsplf         s             10a
     D objd_obj        s             10a
     D objd_lib        s             10a
     D objd_objtype    s             10a
     D objd_rtnlib     s             10a
     D objd0100        ds
     D  od_bytRet              1      4i 0
     D  od_bytAvl              5      8i 0
     D  od_name                9     18a
     D  od_lib                19     28a
     D  od_type               29     38a
     D  od_rtnLib             39     48a
     D fld_array       ds
     D  fld_x                        10i 0 inz
     D  fld_name                     11a   inz dim(64) varying
     D  fld_value                    64a   inz dim(64) varying
     D var_name        s             11a   inz varying
     D var_value       s             64a   inz varying
      * Error return code parm for APIs.
     D errCode         DS
     D  errCode_bytPrv...
     D                               10i 0 inz(%size(errCode))
     D  errCode_bytAvl...
     D                               10i 0 inz(0)
     D  errCode_excID...
     D                                7a   inz
     D  errCode_reserved...
     D                                1a   inz
     D  errCode_escData...
     D                              256a   inz
      * Optional parameters
     D OvrSrcFile      s                   like(i_OvrSrcFile) inz
     D isPreDefCond    s               N   inz(*off)
     D TgtRls          s                   like(i_TgtRls    ) inz
      *
      * Program status data structure.
     D sds            sds
     D  sds_pgmName                  10A
     D  sds_status                    5S 0
     D  sds_prvStat                   5S 0
     D  sds_lastSeq                   8A
     D  sds_lastSubR                  8A
     D  sds_numParm                   3S 0
     D  sds_msgID                     7A
     D  sds_MiInstr                   4A
     D  sds_wrkArea                  30A
     D  sds_lib                      10A
     D  sds_msgText                  80A
      *--------------------------------------------------------------------
     Ixmlinput  ns
     I                                 13   21  xmltag1
     I                                 18   27  xmltag2
     I                                 13  112  xmlcode
      *--------------------------------------------------------------------
     C     *entry        plist
     C                   parm                    ParseSrcMbr      10            source member
     C                   parm                    ParseSrcFile     10            source file
     C                   parm                    ParseSrcLib      10            source lib
      *  optional parameters:
     C                   parm                    i_OvrSrcFile     10            override to src
     C                   parm                    i_Conditions    128            pre-def conditions
     C                   parm                    i_TgtRls         10            target release
      *
      *  get optional parameter: Overrride to Source File
     C                   if        %parms() >= 4
     C                   eval      OvrSrcFile = i_OvrSrcFile
     C                   else
     C                   eval      OvrSrcFile = ''
     C                   endif
      *
      *  get optional parameter: Conditions
     C                   if        %parms() >= 5
     C                   if        %subst(i_Conditions:1:32) <> ''
     C                   eval      cnd_array = loadConditions(i_Conditions)
     C                   eval      isPreDefCond = *on
     C                   else
     C                   eval      isPreDefCond = *off
     C                   endif
     C                   endif
      *
      *  get optional parameter: Target Release
     C                   if        %parms() >= 6
     C                   eval      TgtRls = i_TgtRls
     C                   else
     C                   eval      TgtRls = getCurrentRelease()
     C                   endif
      *
     C                   exsr      srValidate                                   make sure exist
      *
      * Set user selected library *first for remainder of program
     C                   eval      bldexc = 'RMVLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
     C                   eval      bldexc = 'ADDLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ') POSITION(*FIRST)'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
      *       CPF2103 - Library &1 already exists in library list.
     C                   if        %error and sds_msgID <> 'CPF2103'
     C                   eval      qm_msgtxt = '0000 ' + sds_msgText
     C                   exsr      srKill
     C                   endif
      *
      * Set variable &TOLIB
     C                   callp     setVariable('tolib': ParseSrcLib)
      *
      * Set variable &TGTRLS
     C                   callp     setVariable('tgtrls': TgtRls)
      *
      * Set variable &XMLFILE
     C                   callp     setVariable('xmlfile': ParseSrcFile)
      *
      * Set variable &XMLLIB
     C                   callp     setVariable('xmllib': ParseSrcFile)
      *
      * Set variable &XMLMBR
     C                   callp     setVariable('xmlmbr': ParseSrcFile)
      *
      * Override Input file to uploaded text file
     C                   eval      bldexc = 'OVRDBF FILE(XMLINPUT) TOFILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(ParseSrcFile) + ') MBR(' +
     C                             %trimr(ParseSrcMbr) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   open      xmlinput
     C                   read      xmlinput
     C                   dow       not %eof
      * write records to outfile if flag is on
     C                   select
     C                   when      write_flag = *on
     C                   if        xmltag2<>'</copysrc>'
     C                   eval      srcSeqno=srcSeqno+1
     C                   except    write_one
     C                   else
     C                   eval      write_flag=*off
     C                   close     qxxxsrc
     C                   endif
      *
      * Extract values based on xml tags.
     C                   when      xmltag1 = 'mbrname ='
     C                   eval      mbrname = %subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtype ='
     C                   eval      mbrtype =%subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtext ='
     C                   eval      mbrtext =dblQuotes(%subst(xmlcode:13:50))
     C                   when      xmltag1 = 'srcfile ='
     C                   if        OvrSrcFile <> ''
     C                   eval      srcfile =OvrSrcFile
     C                   else
     C                   eval      srcfile =%subst(xmlcode:13:10)
     C                   endif
     C                   when      xmltag1 = 'srclen  ='
     C                   eval      srclen  =%subst(xmlcode:13:5)
     C                   when      xmltag1 = 'srccssid='
     C                   eval      srccssid=%subst(xmlcode:13:5)
      *--------------------------------------------------------------------
      * Start of data to copy.  Create source files/mbrs as required.
      *--------------------------------------------------------------------
     C                   when      xmltag1='<copysrc>'
     C                   move      srclen        srclenN
      * crtsrcpf
     C                   eval      bldexc = 'CRTSRCPF FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') RCDLEN(' +
     C                             srclen + ') CCSID(' +
     C                             srccssid + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      * addpfm
     C                   eval      bldexc = 'ADDPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') SRCTYPE(' +
     C                             %trimr(mbrtype) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error
      * chgpfm
     C                   eval      bldexc = 'CHGPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
      * clr mbr
     C                   eval      bldexc = 'CLRPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      * ovr to outfile mbr
     C                   eval      bldexc = 'OVRDBF QXXXSRC ' +
     C                             %trimr(ParseSrcLib) + '/' +
     C                             %trimr(srcfile) + ' ' +
     C                             mbrname
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   clear                   srcSeqno
     C                   open      qxxxsrc
     C                   eval      write_flag = *on
      *--------------------------------------------------------------------
      * Compile statement.  Read next record and execute it.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<compile '
     C                   eval      condList= getAttrData('condition':xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('compile')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      *--------------------------------------------------------------------
      * qcmdexc statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qcmdexc '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      release  = getAttrData('release'
     C                                                    :xmlcode:'*CURRENT')
     C                   eval      dltsplf  = getAttrData('dltsplf'
     C                                                    :xmlcode:'*NONE')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('qcmdexc')
     C                   if        isCondition(condList) and
     C                             isRelease(tgtRls: release)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   if        %subst(bldexc: 1: 3) = 'DLT'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   else
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error()
     C                   eval      qm_msgtxt = '0000 Failed to execute: '+bldexc
     C                   exsr      srKill
     C                   endif
     C                   if        dltsplf <> '' and dltsplf <> '*NONE'
     C                   eval      bldexc = 'DLTSPLF FILE(' + dltsplf +
     C                                      ') JOB(*) SPLNBR(*LAST)'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
     C                   endif
     C                   endif
      *--------------------------------------------------------------------
      * SQL statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute SQL statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<execsql '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('execsql')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      srSQLExecute
     C                   endif
      *--------------------------------------------------------------------
      * Send messages to user as program executes
      * Extract message ID, Message Type, from <sendmsg>
      * read a record and get the single line of message text.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<sendmsg '
     C                   eval      qm_msgid = %subst(xmlcode:22:7)
     C                   eval      qm_msgtyp = %subst(xmlcode:46:10)
     C                   read      xmlinput
     C                   eval      qm_msgq   = '*EXT   '
     C                   eval      qm_msgtxt = xmlcode
     C                   exsr      srSndMessage
      *--------------------------------------------------------------------
      * rtvobjd statement. retrieve object description of the specified
      * object. Store attributes in specified fields.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<rtvobjd '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('rtvobjd')
     C                   eval      objd_obj    =getAttrData('obj'    :bldexc:'')
     C                   eval      objd_lib    =getAttrData('lib'    :bldexc:'')
     C                   eval      objd_objtype=getAttrData('objtype':bldexc:'')
     C                   eval      objd_rtnlib =getAttrData('rtnlib' :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srRtvObjD
     C                   endif
      *--------------------------------------------------------------------
      * chgvar statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<chgvar  '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('chgvar')
     C                   eval      var_name  = getAttrData('var'    :bldexc:'')
     C                   eval      var_value = getAttrData('value'  :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srChgVar
     C                   endif
      *--------------------------------------------------------------------
      * Query condition
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qrycond '
     C                   eval      bldexc = readElement('qrycond')
     C                   eval      cnd_msg = getAttrData('msg'   : bldexc: '')
     C                   eval      cnd_values = getAttrData('values': bldexc:'')
     C                   eval      cnd_var = getAttrData('var': bldexc: '*NONE')
     C                   exsr      srQueryCond
     C                   endsl
      *
     C                   read      xmlinput
     C                   enddo
      *
     C                   exsr      srSQLEnd
     C                   eval      *inlr=*on
     C                   return
      *--------------------------------------------------------------------
      * Replace variable names with their associated values.
      *--------------------------------------------------------------------
     C     RplVars       begsr
     C                   eval      aa=%scan('&':bldexc)
     C                   dow       aa>0
     C                   eval      var_name=getVarName(bldexc:aa)
     C                   eval      var_value=getVarValue(var_name)
     C                   eval      bldexc=%replace(var_value:bldexc:aa
     C                                             :%len(var_name))
     C                   eval      aa=%scan('&':bldexc)
     C                   enddo
     C                   endsr
      *--------------------------------------------------------------------
      * Sets the target release according to the optional parameter
      * i_TgtRls.
      *--------------------------------------------------------------------
     C     SetTgtRls     begsr
     C                   if        TgtRls = getCurrentRelease()
     C                   leavesr
     C                   endif
     C                   eval      bldexc =
     C                                setTargetRelease('TGTRLS': bldexc: TgtRls)
     C                   endsr
      *--------------------------------------------------------------------
      * Check of file, lib, member exist.
      *--------------------------------------------------------------------
     C     srValidate    begsr
     C                   callp     QUSRMBRD(
     C                             vrcvar:
     C                             145:
     C                             'MBRD0100':
     C                             ParseSrcFile + ParseSrcLib:
     C                             ParseSrcMbr:
     C                             '0':
     C                             errCode)
      *   --------------------------------------------------------------------------------
      *   If error occurred on call, send appropriate message back to user.
      *   ---------------------------------------------------------------------------------
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   select
      * lib not found
     C                   when      errCode_excID = 'CPF9810'
     C                   eval      qm_msgtxt = '0000 Library ' +
     C                             %trimr(ParseSrcLib) + ' was not found.'
      * src file not found
     C                   when      errCode_excID = 'CPF9812'
     C                   eval      qm_msgtxt = '0000 Source file ' +
     C                             %trimr(ParseSrcFile)+' was not found in ' +
     C                             %trimr(ParseSrcLib) + '.'
      * member not found
     C                   when      errCode_excID = 'CPF9815'
     C                   eval      qm_msgtxt = '0000 Member ' +
     C                             %trimr(ParseSrcMbr)+' was not found in ' +
     C                             %trimr(ParseSrcLib)+'/'+ %trimr(ParseSrcFile)
      * unexpected
     C                   other
     C                   eval      qm_msgtxt = '0000 Unexpected message ' +
     C                             errCode_excID + ' received. '
     C                   endsl
      * send message
     C                   exsr      srKill
     C                   eval      *inlr=*on
     C                   return
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * kill application
      *--------------------------------------------------------------------
     C     srKill        begsr
     C                   eval      qm_msgid  = 'CPD0006'
     C                   eval      qm_msgtyp = '*DIAG'
     C                   eval      qm_msgq   = '*CTLBDY'
     C                   exsr      srSndMessage
     C                   eval      qm_msgtxt = *blanks
     C                   eval      qm_msgid  = 'CPF0002'
     C                   eval      qm_msgtyp = '*ESCAPE'
     C                   exsr      srSndMessage
     C                   endsr
      *--------------------------------------------------------------------
      * call send program message api
      *--------------------------------------------------------------------
     C     srSndMessage  begsr
     C                   callp     QMHSNDPM(
     C                             qm_msgid:
     C                             'QCPFMSG   *LIBL     ':
     C                             qm_msgtxt:
     C                             %size(qm_msgtxt):
     C                             qm_msgtyp:
     C                             qm_msgq:
     C                             1:
     C                             '    ':
     C                             errCode)
     C                   endsr
      *--------------------------------------------------------------------
      * retrieve object description and store attributes
      *--------------------------------------------------------------------
     C     srRtvObjD     begsr
     C                   callp     QUSROBJD(objd0100
     C                                      : %size(objd0100)
     C                                      : 'OBJD0100'
     C                                      : objd_obj + objd_lib
     C                                      : objd_objtype
     C                                      : errCode)
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   eval      qm_msgtxt = '0000 Failed to retrieve +
     C                             object description of object ' +
     C                             %trim(objd_lib) + '/' + %trim(objd_obj) +
     C                             ' type ' + %trim(objd_objtype) + '.'
      * send message
     C                   exsr      srKill
     C                   else
     C                   callp     setVariable(objd_rtnlib: od_rtnlib)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * change variable
      *--------------------------------------------------------------------
     C     srChgVar      begsr
     C                   callp     setVariable(var_name: var_value)
     C                   endsr
      *--------------------------------------------------------------------
      * execute SQL statement.
      *--------------------------------------------------------------------
     C     srSQLExecute  begsr
     C                   exsr      srSQLInit
     C                   Eval      retCode = SQLExecDirect(hstmt    :
     C                                                     bldexc   :
     C                                                     SQL_NTS  )
     C                   endsr
      *--------------------------------------------------------------------
      * query condition.
      *--------------------------------------------------------------------
     C     srQueryCond   begsr
     C                   if        isPreDefCond = *off
     C                   eval      cnd_values = uCase(cnd_values)
     C                   dou       (%scan(cnd_rtnVal: cnd_values) > 0) and
     C                             (cnd_rtnval <> ''                 )
     C                   eval      cnd_rtnval = ' '
     C     cnd_msg       dsply                   cnd_rtnval
     C                   eval      cnd_rtnVal = uCase(cnd_rtnVal)
     C                   enddo
     C                   eval      cnd_ptr = cnd_ptr + 1
     C                   eval      cnd_array(cnd_ptr) = cnd_rtnVal
     C                   endif
     C                   if        (cnd_var <> '*NONE')
     C                   callp     setVariable(cnd_var: cnd_rtnval)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * initialize SQL.
      *--------------------------------------------------------------------
     C     srSQLInit     begsr
      *
     C                   if        sqlInit = *off
     C                   Eval      retCode = SQLAllocEnv(%addr(henv))
     C                   Eval      retCode = SQLAllocConnect(henv: %addr(hdbc))
     C                   Eval      retCode = SQLConnect(hdbc      :
     C                                                  '*LOCAL'  :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   )
     C                   Eval      cOptVal = SQL_COMMIT_NONE
     C                   Eval      retCode = SQLSetConnectOption(hdbc          :
     C                                                          SQL_ATTR_COMMIT:
     C                                                          %addr(cOptVal) )
     C                   Eval      retCode = SQLAllocStmt(hdbc       :
     C                                                  %addr(hstmt) )
     C                   eval      sqlInit = *on
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * end SQL.
      *--------------------------------------------------------------------
     C     srSQLEnd      begsr
     C                   if        sqlInit = *on
     C                   Eval      retCode = SQLFreeStmt(hstmt    :
     C                                                   SQL_DROP )
     C                   Eval      retCode = SQLDisconnect(hdbc)
     C                   Eval      retCode = SQLFreeConnect(hdbc)
     C                   Eval      retCode = SQLFreeEnv(henv)
     C                   eval      sqlInit = *off
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * error handler
      *--------------------------------------------------------------------
     C     *pssr         begsr
     C                   if        errFLag = *off
     C                   eval      errFlag = *on
     C                   exsr      srSQLEnd
     C                   endif
     C                   endsr     '*CANCL'
     Oqxxxsrc   e            write_one
     O                       srcSeqno             6
     O                                           12 '000000'
     O                       xmlcode            112
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     P readElement...
     P                 B
     D                 PI                        like(bldexc)
     D  i_element                     9A   value varying
      *
     D i               S             10I 0 inz
     D value           S                   like(bldexc ) inz
     D endTag          S                   like(xmlTag2) inz
      *
     C                   eval      i = 1
     C                   eval      endTag = '</' + i_element + '>'
     C                   dow       xmltag2 <> endTag
     C                   eval      %subst(value: i: %len(xmlcode)) = xmlcode
     C                   eval      i = i + %len(xmlcode)
     C                   read      xmlinput
     C                   enddo
      *
     C                   Return    value
      *
     P                 E
      *--------------------------------------------------------------------
      * Double quotes
      *--------------------------------------------------------------------
     P dblQuotes...
     P                 B
     D                 PI          2048A         varying
     D  i_string                   2048A   value varying
      *
     D x               S             10I 0         inz
     D string          S           2048A   varying inz
      *
     C                   For       x = 1 to %len(i_string)
     C                   Eval      string = string + %subst(i_string: x:1)
     C                   If        %subst(i_string: x : 1) = qs
     C                   Eval      string = string + qs
     C                   Endif
     C                   Endfor
      *
     C                   Return    string
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get Attribute Data from String
      *---------------------------------------------------------------------------------------------
     P getAttrData...
     P                 B
     D                 PI          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *
      *  return value
     D attrData        S           2000A   varying inz                          like(string_t)
      *
      *  local fields
     D attr            S             20a   varying inz
     D lenAttr         S             10i 0 inz
     D aa              S             10i 0 inz
     D cc              S             10i 0 inz
      *
     D Qd              C                   const('"')
      *-------------------------------------------------------------------*
      *
      *  find the keyword
     C                   eval      attr = %trim(i_attr) + '=' + Qd
      *
     C                   eval      aa   = %scan(attr: i_string)
     C                   if        aa = 0
     C                   return    i_default
     C                   endif
      *
     C                   eval      aa   = aa + %len(attr)
     C                   eval      cc   = %scan(Qd: i_string: aa+1)
      *
      *  return the data between the double-quotes
     C                   if        (cc-aa) > 0
     C                   eval      attrData = %subst(i_string: aa: cc-aa)
     C                   endif
      *
     C                   Return    attrData
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Load condition array
      *---------------------------------------------------------------------------------------------
     P loadConditions...
     P                 B
     D                 PI                  dim(32) like(condition)
     D  i_conditions                128A   value
      *
      *  return value
     D cnd_array       s                   dim(32) inz like(condition)
     D pValue          s               *   inz
     D x               s             10i 0 inz
     D i               s             10i 0 inz
     D cnd_value       s            128a   varying
     D var_name        s             64a   varying
     D var_value       s             64a   varying
      *-------------------------------------------------------------------*
      /FREE

         i_conditions = uCase(i_conditions);

         pValue = strtok(i_conditions: ';');
         dow (pValue <> *null);
            x = x + 1;
            cnd_value = %str(pValue);
            i = %scan('=': cnd_value);
            if (i = 0);
               cnd_array(x) = cnd_value;
            else;
               var_name = %subst(cnd_value: 1: i-1);
               if (%subst(var_name: 1: 1) = '&');
                  var_name = %subst(var_name: 2);
               endif;
               var_value = %subst(cnd_value: i+1);
               setVariable(var_name: var_value);
               cnd_array(x) = var_value;
            endif;
            pValue = strtok(*null: ';');
         enddo;

         return cnd_array;
      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check for a condition
      *---------------------------------------------------------------------------------------------
     P isCondition...
     P                 B
     D                 PI              n
     D  i_condList                 2000A   value
      *
      *  return value
     D isCondition     S               n   inz
     D pValue          S               *   inz
     D aCondition      S             10a   inz
      *-------------------------------------------------------------------*
      *
     C                   eval      i_condList = uCase(i_condList)
      *
     C                   if        (i_condList = '*NONE')  or
     C                             (i_condList = ''     )
     C                   eval      *in01 = *on
     C                   else
      *
     C                   eval      pValue = strtok(i_condList: ' ')
     C                   dow       pValue <> *null
     C                   eval      aCondition = %str(pValue)
     C     aCondition    lookup    cnd_array                              01
     C                   if        not *in01
     C                   leave
     C                   endif
     C                   eval      pValue = strtok(*null     : ' ')
     C                   enddo
      *
     C                   endif
      *
     C                   if        *in01
     C                   eval      isCondition = *on
     C                   else
     C                   eval      isCondition = *off
     C                   endif
      *
     C                   Return    isCondition
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get the current release level of the operation system
      *---------------------------------------------------------------------------------------------
     P getCurrentRelease...
     P                 B
     D                 PI            10A
      *
      *  QSZRTVPR API
     D QSZRTVPR...
     D                 PR                  extpgm('QSZRTVPR')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  o_prodInf                 65535A   const  options(*varsize)
     D  io_errCode                65535A          options(*varsize)
      *
     D prdi0100        DS                  qualified
     D  productID              1      7A   inz('*OPSYS')
     D  releaseLvl             8     13A   inz('*CUR'  )
     D  productOpt            14     17A   inz('0000'  )
     D  loadID                18     27A   inz('*CODE' )
      *  Shortened!:
     D prdr0100        DS                  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     12I 0
     D  productID             13     19A
     D  releaseLvl            20     25A
      *  API error code
     D errCode         DS
     D  bytPrv                       10i 0 inz(0)
     D  bytAvl                       10i 0 inz(0)
      *-------------------------------------------------------------------*
      *
     C                   Callp     QSZRTVPR(prdr0100: %size(prdr0100):
     C                                      'PRDR0100': prdi0100: errCode)
     C                   Return    prdr0100.releaseLvl
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check the release level
      *---------------------------------------------------------------------------------------------
     P isRelease...
     P                 B
     D                 PI              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *
      *  return value
     D isRelease       S               n   inz(*off)
      *  Release
     D release         DS
     D  r_operator             1      3a
     D  r_space                4      4a
     D  r_level                5     10a
      *-------------------------------------------------------------------*
      *
     C                   If        i_release = '*CURRENT'
     C                   Eval      isRelease = *on
     C                   Else
     C                   Eval      release = i_release
     C                   Select
     C                   When      r_operator = '*LT' and
     C                             i_os_release < r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*EQ' and
     C                             i_os_release = r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GT' and
     C                             i_os_release > r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*LE' and
     C                             i_os_release <= r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GE' and
     C                             i_os_release >= r_level
     C                   Eval      isRelease = *on
     C                   Other
     C                   Eval      isRelease = *off
     C                   Endsl
     C                   Endif
      *
     C                   Return    isRelease
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Replaces the value of a given keyword.
      *---------------------------------------------------------------------------------------------
     P setTargetRelease...
     P                 B
     D                 PI          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *
      *  return value
     D string          S           2000A   varying inz
      *
      *  helper fields
     D x               S             10I 0 inz
     D l               S             10I 0 inz
     D tmpKeyword      S                   like(i_keyword) inz
     D tmpString       S                   like(i_string ) inz
     D tmpCmd          S             10A   inz
      *-------------------------------------------------------------------*
      /FREE

         tmpKeyword = uCase(%trimR(i_keyword));
         tmpString  = uCase(%trimR(i_string ));
         x = %scan(' ': tmpString);
         if x = 0;
            return i_string;
         endif;
         tmpCmd = %subst(tmpString: 1: x);
         if tmpCmd <> 'CRTRPGMOD' and
            tmpCmd <> 'CRTRPGPGM' and
            tmpCmd <> 'CRTCLMOD'  and
            tmpCmd <> 'CRTCLPGM'  and
            tmpCmd <> 'CRTCBLMOD' and
            tmpCmd <> 'CRTCBLPGM' and
            tmpCmd <> 'CRTCMOD'   and
            tmpCmd <> 'CRTCPPMOD' and
            tmpCmd <> 'CRTBNDC'   and
            tmpCmd <> 'CRTBNDCBL' and
            tmpCmd <> 'CRTBNDCL'  and
            tmpCmd <> 'CRTBNDCPP' and
            tmpCmd <> 'CRTBNDDIR' and
            tmpCmd <> 'CRTBNDRPG' and
            tmpCmd <> 'CRTPGM'    and
            tmpCmd <> 'CRTSRVPGM' ;
            return i_string;
         endif;
         x = %scan(tmpKeyword + '(': tmpString);
         if x = 0;
            return %trimR(i_string) +
                   ' ' + tmpKeyword + '(' + %trimR(i_value) + ')';
         endif;
         l = %scan(')': tmpString: x + %len(i_keyword) + 1);
         if l = 0;
            return i_string;
         endif;
         l = l - x + 1;
         string = %replace(tmpKeyword + '(' + %trimR(i_value) + ')'
                           : i_string: x: l);
         Return string;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Store field value.
      *---------------------------------------------------------------------------------------------
     P setVariable...
     P                 B
     D                 PI
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
     D i               s             10I 0 inz
      *-------------------------------------------------------------------*
      /FREE

         if (i_fldName = '');
            return;
         endif;

         for i = 1 to fld_x;
            if (uCase('&' + %trim(i_fldName)) = uCase(fld_name(i)));
               fld_value(i) = i_value;
               return;
            endif;
         endfor;

         if (fld_x >= %elem(fld_name));
            return;
         endif;

         fld_x = fld_x + 1;
         fld_name(fld_x)  = uCase('&' + %trim(i_fldName));
         fld_value(fld_x) = i_value;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable name from statement.
      *---------------------------------------------------------------------------------------------
     P getVarName...
     P                 B
     D                 PI            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
     D name            s             11a   varying inz
     D CHARS           c                   '&ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                      abcdefghijklmnopqrstuvwxyz+
     D                                      1234567890_'
      *-------------------------------------------------------------------*
      /FREE

         dow (i_pos<=%len(i_bldexc) and
              %check(CHARS:%subst(i_bldexc:i_pos:1))=0);
            name = name+%subst(i_bldexc:i_pos:1);
            i_pos=i_pos+1;
         enddo;

         return name;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable value.
      *---------------------------------------------------------------------------------------------
     P getVarValue...
     P                 B
     D                 PI            64a          varying
     D  i_name                       11a   value  varying
     D i               s             10i 0 inz
     D value           s             64a   varying inz('?')
      *-------------------------------------------------------------------*
      /FREE

         for i=1 to fld_x;
            if (ucase(fld_name(i))=uCase(i_name));
               value=%trimR(fld_value(i));
               leave;
            endif;
         endfor;

         return value;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  convert to upper case
      *---------------------------------------------------------------------------------------------
     P uCase...
     P                 B
     D                 PI          2000A          varying
     D  i_string                   2000A   value  varying
     D uCase           s           2000A   inz varying
     D LC              C                   const('abcdefghijklmnopqrstuvwxyz')
     D UC              C                   CONST('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      *-------------------------------------------------------------------*
      /FREE

         uCase = %xlate(LC:UC:i_string);

         return uCase;

      /END-FREE
     P                 E
      * /// END   OF INSTALL PGM HERE   ****************************************** ///
      * /// do not copy past this point ///
]]>  </install_program>
<qrycond
  msg="'Create sample programs? (YES, NO)'"
  values="YES        NO"
  var="CRTTSTPGM">
<![CDATA[
]]>  </qrycond>
<chgvar   condition="*NONE" var="SRCFILE" value="QEVENTF">
<![CDATA[
]]>  </chgvar>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_INSTALL  type CLLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_INSTALL "
mbrtype =  "CLLE      "
mbrtext =  "EVENTF - Installer                                "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
     /* =================================================================== */
     /*                                                                     */
     /*  Documentation:                                                     */
     /*                                                                     */
     /*  Utility . . . : EVENTF                                             */
     /*  Object  . . . : A_INSTALL  (PGM)                                   */
     /*  Source member : A_INSTALL                                          */
     /*  Source type . : CLLE                                               */
     /*  Description   : EVENTF - Installer                                 */
     /*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      */
     /*                                                                     */
     /* =================================================================== */
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /* =================================================================== */
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          nderung                                 */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /* =================================================================== */
     /*   >>PRE-COMPILER<<                                                  */
     /*     >>CRTCMD<<    CRTBNDCL  PGM(QTEMP/&OB) +                        */
     /*                             SRCFILE(&SL/&SF) SRCMBR(&SM);           */
     /*     >>IMPORTANT<<                                                   */
     /*       >>PARM<<    OPTION(*EVENTF);                                  */
     /*     >>END-IMPORTANT<<                                               */
     /*     >>EXECUTE<<                                                     */
     /*     >>CMD<<       CALL   PGM(QTEMP/A_INSTALL) +                     */
     /*                          PARM('*CURRENT' '&SF' '&LI' 'NO');         */
     /*     >>CMD<<       DLTPGM PGM(QTEMP/A_INSTALL);                      */
     /*   >>END-PRE-COMPILER<<                                              */
     /* =================================================================== */
             PGM        PARM(&TGTRLS &SRCFILE &TOLIB &CRTTSTPGM)

             DCL        VAR(&TGTRLS   ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&SRCFILE  ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&TOLIB    ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&CRTTSTPGM) TYPE(*CHAR) LEN(10)

             DCL        VAR(&SRCLIB   ) TYPE(*CHAR) LEN(10)

             CHGVAR     VAR(&SRCLIB) VALUE(&TOLIB   )

     /* -------------------------------- */
     /*  Delete old objects              */
     /* -------------------------------- */
             DLTMOD     MODULE(&TOLIB/EVENTF1)
             MONMSG     MSGID(CPF2105)

             DLTSRVPGM  SRVPGM(&TOLIB/EVENTF)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/EVENTFT1)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/EVENTFT1)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/EVENTFT2)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/EVENTFT2)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/EVENTFT3)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/EVENTFT3)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/EVENTFT4)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/EVENTFT4)
             MONMSG     MSGID(CPF2105)

             RMVMSG     PGMQ(*SAME (*)) CLEAR(*ALL)

     /* -------------------------------- */
     /*  Create modules                  */
     /* -------------------------------- */
             CRTRPGMOD  MODULE(&TOLIB/EVENTF1) +
                          SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(EVENTF1  ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create service programs         */
     /* -------------------------------- */
             CRTSRVPGM  SRVPGM(&TOLIB/EVENTF) +
                          MODULE(&TOLIB/EVENTF1) +
                          EXPORT(*SRCFILE) +
                          SRCFILE(&SRCLIB/&SRCFILE) +
                          SRCMBR(EVENTF) +
                          ACTGRP(*CALLER) +
                          DETAIL(*BASIC) +
                          BNDSRVPGM(&TOLIB/BASICS1) +
                          TEXT('Event File API') +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(EVENTF   ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create test programs            */
     /* -------------------------------- */
             IF         COND(&CRTTSTPGM *EQ 'YES') THEN(DO)
                CRTRPGMOD  MODULE(&TOLIB/EVENTFT1) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(EVENTFT1 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/EVENTFT1) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1  +
                                       &TOLIB/EVENTF ) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(EVENTFT1 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                DLTMOD    MODULE(&TOLIB/EVENTFT1)

                CRTRPGMOD  MODULE(&TOLIB/EVENTFT2) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
               DLTSPLF    FILE(EVENTFT2 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/EVENTFT2) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1  +
                                       &TOLIB/EVENTF ) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(EVENTFT2 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                DLTMOD    MODULE(&TOLIB/EVENTFT2)

                CRTRPGMOD  MODULE(&TOLIB/EVENTFT3) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(EVENTFT3 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/EVENTFT3) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1  +
                                       &TOLIB/EVENTF ) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(EVENTFT3 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                DLTMOD    MODULE(&TOLIB/EVENTFT3)

                CRTRPGMOD  MODULE(&TOLIB/EVENTFT4) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(EVENTFT4 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/EVENTFT4) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1  +
                                       &TOLIB/EVENTF ) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(EVENTFT4 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                DLTMOD    MODULE(&TOLIB/EVENTFT4)

             ENDDO

     /* -------------------------------- */
     /*  Delete obsolete objects         */
     /* -------------------------------- */
             DLTMOD     MODULE(&TOLIB/EVENTF1)

             ENDPGM
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_README  type TXT - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_README  "
mbrtype =  "TXT       "
mbrtext =  "EVENTF Readme                                     "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
EVENTF - A Tools/400 Service Program
------------------------------------

EVENTF is service program that offers services for writing a events to
the IBM compile event file (EVFEVENT).

Dependencies: BASICS1

Compile members with the following PDM option:

   STRPREPRC USESRCFILE(&L/&F) USESRCMBR(&N) OPTION(*EVENTF) CHGOBJD(*NO)
     LIB(&O) OBJ(&N) SRCLIB(&L) SRCFILE(&F) SRCMBR(&N) USER0(&X)
     USER1(*LIST) USER2(*FULL)

Members of type MAKPGM or BND are used for linking programs (MAKPGM)
and service programs (BND).

2018, Thomas Raddatz
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing CEELIB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "CEELIB    "
mbrtype =  "RPGLE     "
mbrtext =  "Prototypes of CEE APIs                   (include)"
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(CEELIB)
 DEF  /DEFINE CEELIB
      *
      * ---------------------------------------------------------------
      *   Program or Procedure Call APIs
      * ---------------------------------------------------------------
      *
      *  Condition token, used as feedback code
     D cee_fc_t        DS                  qualified               based(pDummy)
     D  Condition_ID...
     D                         1      4A
     D   MsgSev                1      2I 0
     D   Msg_No                3      4U 0
     D  Flags                  5      5A
     D  Facility_ID...
     D                         6      8A
     D  I_S_Info               9     12A
      *
      *  Retrieve Operational Descriptor Information (CEEDOD)
     D CEEDOD...
     D                 PR
     D                                            extproc('CEEDOD')
     D  i_posn                       10I 0 const
     D  o_desctype                   10I 0
     D  o_datatype                   10I 0
     D  o_descinf1                   10I 0
     D  o_descinf2                   10I 0
     D  o_datalen                    10I 0
     D  o_fc                         12A          options(*omit   )
      *
      *  Reference fields for CEEDOD API
     D descInf_t       DS                  based(pDummy)   qualified
     D  desctype                     10I 0
     D  datatype                     10I 0
     D  descinf1                     10I 0
     D  descinf2                     10I 0
     D  datalen                      10I 0
      *
      *  Test for Omitted Argument (CEETSTA) API
     D CEETSTA...
     D                 PR
     D                                            extproc('CEETSTA')
     D  io_isPresent                 10I 0
     D  i_argNum                     10I 0 const
     D  o_fc                         12A          options(*omit   )
      *
      *  Get String Information (CEEGSI) API
     D CEEGSI...
     D                 PR
     D                                            extproc('CEEGSI')
     D  i_posn                       10I 0 const
     D  o_datatype                   10I 0
     D  o_curlen                     10I 0
     D  o_maxlen                     10I 0
     D  o_fb                         12A          options(*omit   )
      *
      *  Reference fields for CEEGSI API
     D strInf_t        DS                  based(pDummy)   qualified
     D  datatype                     10I 0
     D  curlen                       10I 0
     D  maxlen                       10I 0
      *
      * ---------------------------------------------------------------
      *   Math APIs
      * ---------------------------------------------------------------
      *
      *  Logarithm base 10 (double float)
     D CEESDLG1...
     D                 PR                  extproc('CEESDLG1')
     D  i_value                       8F   const
     D  o_result                      8F
      *
      * ---------------------------------------------------------------
      *   ILE CEE Date and Time APIs
      * ---------------------------------------------------------------
      *
      *  Calculate Day of Week from Lilian Date (CEEDYWK) API
     D CEEDYWK         PR                  opdesc extproc('CEEDYWK')
     D   lilian_date                 10I 0 const
     D   day_no                      10I 0
     D   feedback                    12A   options(*omit)
      *
      *  Convert Lilian Date to Character Format (CEEDATE) API
     D CEEDATE         PR                  opdesc extproc('CEEDATE')
     D   lilian_date                 10I 0 const
     D   date_format                 80A   const options(*varsize)
     D   char_date                   80A   options(*varsize)
     D   feedback                    12A   options(*omit)
      *
      *  Convert Date to Lilian Format (CEEDAYS) API
     D CEEDAYS         PR                  opdesc extproc('CEEDAYS')
     D   char_date                   80A   const options(*varsize)
     D   date_format                 80A   const options(*varsize)
     D   lilian_date                 10I 0
     D   feedback                    12A   options(*omit)
      *
      *  Convert Seconds to Character Timestamp (CEEDATM) API
     D CEEDATM         PR                  opdesc extproc('CEEDATM')
     D  input_seconds                 8F   const
     D  picture_string...
     D                               80A   const options(*varsize)
     D  output_timestamp...
     D                               80A         options(*varsize)
     D   feedback                    12A   options(*omit)
      *
      *  Get Offset from Universal Time Coordinated to Local Time (CEEUTCO) API
     D CEEUTCO         pr                  extproc('CEEUTCO')
     D  offsethours                  10i 0
     D  offsetminutes                10i 0
     D  offsetseconds                 8f
     D  feedback                     12a   options(*nopass)
      *
     D cee_utco_t      ds                  qualified   based(pDummy)
     D  offhours                     10i 0
     D  offmins                      10i 0
     D  offsecs                       8f
      *
      *  Convert Timestamp to Number of Seconds (CEESECS) API
     D CEESECS         pr                  extproc('CEESECS') opdesc
     D  inTimestamp                 255a   const options(*varsize)
     D  inPicture                   255a   const options(*varsize)
     D  outSeconds                    8f
     D  outFC                        12a         options(*omit)
      *
      * ---------------------------------------------------------------
      *   Activation Group and Control Flow APIs
      * ---------------------------------------------------------------
      *
      *  Register Activation Group Exit Procedure (CEE4RAGE) API
     D CEE4RAGE...
     D                 PR                  extproc('CEE4RAGE')
     D  i_pProc                        *   const procptr
     D   fc                          12A         options(*OMIT)
      *
     D END_ACTGRP_CODE_EXCEPTION_MESSAGE...
     D                 C                   x'40000000'
     D END_ACTGRP_CODE_ABNORMAL_END...
     D                 C                   x'00008000'
     D END_ACTGRP_CODE_ACTGRP_IS_ENDING...
     D                 C                   x'00004000'
     D END_ACTGRP_CODE_INIT_BY_RCLACTGRP...
     D                 C                   x'00002000'
     D END_ACTGRP_CODE_INIT_BY_JOB_END...
     D                 C                   x'00001000'
     D END_ACTGRP_CODE_INIT_BY_EXIT_VERB...
     D                 C                   x'00000800'
     D END_ACTGRP_CODE_INIT_BY_FUNCTION_CHECK...
     D                 C                   x'00000400'
     D END_ACTGRP_CODE_INIT_BY_OUT_OF_SCOPE_JUMP...
     D                 C                   x'00000200'
      *
     D CEE4RAGE_user_exit...
     D                 PR                         extproc('CEE4RAGE_user_exit')
     D  i_ag_mark                    10U 0 const
     D  i_reason                     10U 0 const
     D  io_result_code...
     D                               10U 0 const
     D  io_user_rc                   10I 0 const
      *
      *  Register Call Stack Entry Termination User Exit Procedure (CEERTX)
     D CEERTX...
     D                 PR                         extproc('CEERTX')
     D  i_procPtr                      *   const  procptr
     D  i_rtxToken                     *   const  options(*omit)
     D  o_fc                         12A          options(*omit)
      *
     D CEERTX_user_exit...
     D                 PR                         extproc('CEERTX_user_exit')
     D  i_rtxToken                     *   const
      *
      *  Unregister Call Stack Entry Termination User Exit Procedure (CEEUTX)
     D CEEUTX...
     D                 PR                         extproc('CEEUTX')
     D  i_procPtr                      *   const  procptr
     D  o_fc                         12A          options(*omit)
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing COPYRIGHT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "COPYRIGHT "
mbrtype =  "RPGLE     "
mbrtext =  "Copyright information                             "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      /if not defined(COPYRIGHT_DSPEC)
     H COPYRIGHT('V1.2.4 - 09.02.2017 - mailto:thomas.raddatz@tools400.de')
      /eof
      /endif
     D EVENTF_VERSION...
     D                 C                   '1.2.4'
     D EVENTF_DATE...
     D                 C                   '09.02.2017'
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTF  type MAKSRV - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTF    "
mbrtype =  "MAKSRV    "
mbrtext =  "Events File API                                   "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
     /* ===================================================================== */
     /*  Events File API                                                      */
     /* ===================================================================== */
     /*  Author  :  Thomas Raddatz                                            */
     /*  Date    :  19.05.2013                                                */
     /*  E-mail  :  thomas.raddatz@Tools400.de                                */
     /*  Homepage:  www.tools400.de                                           */
     /* ===================================================================== */
     /* >>PRE-COMPILER<<                                                      */
     /*   >>CRTCMD<< CRTSRVPGM    SRVPGM(&LI/EVENTF);                         */
     /*   >>LINK<<                                                            */
     /*     >>PARM<< MODULE(+                                                 */
     /*                     &LI/EVENTF1   +                                   */
     /*                     );                                                */
     /*     >>PARM<< EXPORT(*SRCFILE);                                        */
     /*     >>PARM<<   SRCFILE(&SL/&SF);                                      */
     /*     >>PARM<<   SRCMBR(&SM);                                           */
     /*     >>PARM<< ACTGRP(*CALLER);                                         */
     /*     >>PARM<< ALWUPD(*YES);                                            */
     /*     >>PARM<< ALWLIBUPD(*YES);                                         */
     /*     >>PARM<< BNDSRVPGM(&LI/BASICS1);                                  */
     /*     >>PARM<< TEXT('Events File API');                                 */
     /*     >>PARM<< TGTRLS(V7R1M0  );                                        */
     /*     >>PARM<< DETAIL(*BASIC);                                          */
     /*   >>END-LINK<<                                                        */
     /*   >>EXECUTE<<                                                         */
     /* >>END-PRE-COMPILER<<                                                  */
     /* ===================================================================== */

STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('Events_File_API')

  EXPORT SYMBOL('EVENTF1_Eventf_open')
  EXPORT SYMBOL('EVENTF1_Eventf_writeProcessor')
  EXPORT SYMBOL('EVENTF1_Eventf_writeFileID')
  EXPORT SYMBOL('EVENTF1_Eventf_writeFileEnd')
  EXPORT SYMBOL('EVENTF1_Eventf_writeError')
  EXPORT SYMBOL('EVENTF1_Eventf_close')

  /* New with 1.2.2 */
  EXPORT SYMBOL('EVENTF1_Eventf_openAppend')
  EXPORT SYMBOL('EVENTF1_Eventf_clear')

  /* New with 1.2.3 */
  EXPORT SYMBOL('EVENTF1_Eventf_copyFrom')
ENDPGMEXP
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTF_H  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTF_H  "
mbrtype =  "RPGLE     "
mbrtext =  "Events File format (EVFEVENT)                     "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      /if defined(EVENTF_H)
      /eof
      /endif
      /define EVENTF_H

      // The Events File contains information that allows the editor to locate, in the
      // source member, any tokens or lines that caused a message to be issued, and to
      // relate messages that refer to expanded source to the corresponding position in
      // a given source file. The Events File is meant to provide machine-readable
      // information useful to certain classes of tools. The processor's listing file,
      // by contrast, is meant to be read by humans. Since the Events File has a common
      // format across all processors, tools will not have to write processor-specific
      // code to obtain the information they need.

      // Source: http://pic.dhe.ibm.com/infocenter/iadthelp/v8r5/index.jsp?
      //         topic=%2Fcom.ibm.etools.iseries.rse.doc%2Ftopics%2Frevformat.html

      // Timestamp Record
      // This record indicates when the Events File was created, and allows an application
      // to determine if the Events File is current. This record is always the first record
      // in the Events File.
     D evf_timestamp...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('TIMESTAMP')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  value                        14a   inz                                  yyyymmddhhmmss

      // Processor Record
      // This record indicates that a new processor has been invoked.
      // One will always follow the timestamp record in the Events File.
     D evf_processor...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('PROCESSOR')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  output_id                     3a   inz('000')
     D  separator_3                   1    inz
     D  line_class                    1a   inz('1')

      // File ID Record
      // This record contains the full name of the source file processed
      // and associates an integer with the file name.
      // Usage:  result = %trimR(evf_file_id_1) + evf_file_id_2
     D evf_file_id_1...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('FILEID')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  source_id                     3a   inz('001')
     D  separator_3                   1    inz
     D  line                          6a   inz('000000')
     D  separator_4                   1    inz
     D  length                        3a   inz('000')
     D  separator_5                   1    inz
     D  filename                    200a   inz(
     D                                     'Library___/File______(Member____)')

     D evf_file_id_2...
     D                 ds                  qualified based(pDummy)
     D  separator_6                   1    inz
     D  sourcefile_timestamp...
     D                               14a   inz('YYYYMMDDHHMMSS')
     D  separator_7                   1    inz
     D  temp_flag                     1a   inz('0')

      // File End Record
      // This record indicates that an included file is ending.
     D evf_file_end...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('FILEEND')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  file_id                       3a   inz('001')
     D  separator_3                   1    inz
     D  expansion                     6a   inz('000000')

      // Error Information Record
      // A record of this type contains information required to locate
      // a token or line causing a message in the source file, as well
      // as enough information to allow the message itself to be displayed.
     D evf_error...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('ERROR')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  file_id                       3a   inz('001')
     D  separator_3                   1    inz
     D  annot_class                   1a   inz('1')
     D  separator_4                   1    inz
     D  stmt_line                     6a   inz('000000')
     D  separator_5                   1    inz
     D  start_err_line...
     D                                6a   inz('000000')
     D  separator_6                   1    inz
     D  token_start                   3a   inz('000')
     D  separator_7                   1    inz
     D  end_err_line                  6a   inz('000000')
     D  separator_8                   1    inz
     D  token_end                     3a   inz('000')
     D  separator_9                   1    inz
     D  msg_id                        7a   inz
     D  separator_10                  1    inz
     D  msg_id                        7a   inz
     D  separator_11                  1    inz
     D  sev_char                      1a   inz('E')                             I, W, E, S, or
     D  separator_12                  1    inz
     D  sev_num                       2a   inz('30')
     D  separator_13                  1    inz
     D  length                        3a   inz('000')
     D  separator_14                  1    inz
     D  msg                         200a   inz

      // Expansion Record
      // This record contains information about expanded source lines
      // due to a pre-processor.
     D evf_expansion...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('EXPANSION')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  input_file_id                 3a   inz('000')
     D  separator_3                   1    inz
     D  input_line_start...
     D                                6a   inz('000000')
     D  separator_4                   1    inz
     D  input_line_end...
     D                                6a   inz('000000')
     D  separator_5                   1    inz
     D  output_file_id...
     D                                3a   inz('000')
     D  separator_6                   1    inz
     D  output_line_start...
     D                                6a   inz('000000')
     D  separator_7                   1    inz
     D  output_line_end...
     D                                6a   inz('000000')
     D  separator_8                   1    inz

      // Program Record
      // This record indicates a new program in the same source file
      // is being compiled.
      // Note: All ERROR records for a program must come after the
      //       PROGRAM record for that program and before any PROGRAM
      //       records for other programs.
     D evf_program...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('PROGRAM')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  line                          6a   inz('000000')

      // Map Define Record
      // This record indicates that a macro is being defined.
     D evf_map_define...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('MAPDEFINE')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  macro_id                      3a   inz('000')
     D  separator_3                   1    inz
     D  line                          6a   inz('000000')
     D  separator_4                   1    inz
     D  length                        3a   inz('000')
     D  separator_5                   1    inz
     D  macro_name                  200a   inz

      // Map Start Record
      // This record indicates that source expansion is starting.
     D evf_map_start...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('MAPSTART')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  macro_id                      3a   inz('000')
     D  separator_3                   1    inz
     D  line                          6a   inz('000000')

      // Map End Record
      // This record indicates that source expansion is complete.
     D evf_map_end...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('MAPEND')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  macro_id                      3a   inz('000')
     D  separator_3                   1    inz
     D  line                          6a   inz('000000')
     D  separator_4                   1    inz
     D  expansion                     6a   inz('000000')

      // Feedback Code Record
      // This record indicates that source expansion is complete.
     D evf_feedback...
     D                 ds                  qualified based(pDummy)
     D  type                         10a   inz('FEEDBACK')
     D  separator_1                   1    inz
     D  version                       1a   inz('0')
     D  separator_2                   1    inz
     D  return_code                   3a   inz('0')
     D  separator_3                   1    inz
     D  reason_code                   3a   inz('0')

]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTFT1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTFT1  "
mbrtype =  "RPGLE     "
mbrtext =  "Event File API - Example 1 (short path names)     "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *===============================================================*
      *  erstellt : 19.05.2013                                        *
      *===============================================================*
      *                                                               *
      *  Kurzdokumentation :                                          *
      *                                                               *
      *  Rahmentestprogramm mit Protokollausgabe                      *
      *  Thema:                                                       *
      *     Event File API - Example 1 (short path names)             *
      *                                                               *
      *===============================================================*
      * >>PRE-COMPILER<<                                              *
      *                                                               *
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +                   *
      *                           SRCFILE(&SL/&SF) +                  *
      *                           SRCMBR(&SM);                        *
      *                                                               *
      *   >>COMPILE<<                                                 *
      *     >>PARM<< TRUNCNBR(*NO);                                   *
      *     >>PARM<< DBGVIEW(*LIST);                                  *
      *     >>PARM<< OPTION(*EVENTF);                                 *
      *   >>END-COMPILE<<                                             *
      *                                                               *
      *   >>EXECUTE<<                                                 *
      *                                                               *
      *   >>CMD<<    CRTPGM       PGM(&LI/&OB) +                      *
      *                           MODULE(&LI/&OB          +           *
      *                                          ) +                  *
      *                           BNDSRVPGM(*LIBL/BASICS1      +      *
      *                                     *LIBL/EVENTF       +      *
      *                                          ) +                  *
      *                           BNDDIR(*N         ) +               *
      *                           DETAIL(*BASIC) +                    *
      *                           ACTGRP(*NEW);                       *
      *                                                               *
      * >>END-PRE-COMPILER<<                                          *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
     FQSYSPRT   O    F   80        PRINTER OFLIND(*in70)
      *
      * ------------------------------------
      *  Type definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1                      SrvPgm: Basics 1
      *
      *  Examinee
      /COPY QEVENTF,PEVENTF                        Event File API
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Globale Konstanten
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                  extpgm('EVENTFT1')
      *
     D main...
     D                 PR                         extproc('main')
      *
      *  Logs a message to the job log or appends it to a spooled file
     D logMsg...
     D                 PR                         extproc('logMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying
      *
      *  Prints a given message to QSYSPRT.
     D printMsg...
     D                 PR                  extproc('printMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
     D PGM_ENTRY_POINT...
     D                 PI
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         if (%open(QSYSPRT));
            close QSYSPRT;
         endif;

         *inlr = *on;

      /END-FREE
      *
      *===============================================================*
      *  *** private ***
      *  Logs a message to the job log or appends it to a spooled file
      *===============================================================*
     P logMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if (%parms() >= 1);
            printMsg(i_text);
            // sndMsg(i_text);
         else;
            printMsg('');
            // no output to the job log
         endif;

      /END-FREE
      *
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';
         clear errCode;
         errCode.bytPrv = %size(errCode);
         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);
         return;

      /END-FREE
      *
     P                 E
      *
      * =====================================================================
      *  *** private ***
      *  Prints a given message to QSYSPRT.
      * =====================================================================
     P printMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Local fields
     D lineOutput      DS            80    inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free
         if (not %open(QSYSPRT));
            open QSYSPRT;
         endif;
         if (%parms() >= 1);
            lineOutput = i_text;
         endif;
         write QSYSPRT lineOutput;
      /end-free
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D source_id       s                   like(evf_source_id_t)
     D object          s                   like(evf_objName_t)
     D library         s                   like(evf_objName_t)
     D fileName        s                   like(evf_path_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         object = 'EVENTF';
         library = 'RADDATZ';

         Eventf_open(library: object);
         Eventf_writeProcessor();

         // Add module source
         source_id = 1;
         fileName = f_cvtQSYSObjNameToPath(
                       'QEVENTF': 'RADDATZ': 'EVENTF1': '*FILE');
         Eventf_writeFileID(source_id: fileName
                            : EVF_NAME_TYPE_PATH
                            : EVF_PERSISTENT_SOURCE);

         // Add first /copy book
         fileName = f_cvtQSYSObjNameToPath(
                       'QEVENTF': 'RADDATZ': 'H_SPEC': '*FILE');
         Eventf_writeFileID(source_id + 1: fileName
                            : EVF_NAME_TYPE_PATH
                            : EVF_PERSISTENT_SOURCE
                            : 43);

         Eventf_writeFileEnd(source_id + 1: 10); // close first /copy book

         // Add errors of module source
         Eventf_writeError(source_id
                           : 1077                   // stmt-line
                           : 'RNF5409'              // msg-id
                           : 30                     // sev-num
                           : 'The prototyped call returns a value which is +
                              lost when CALLP is used.'
                           : EVF_SEVERITY_ERROR     // sev-char
                           : EVF_ANNOTATION_TOP     // annotation class
                           : 1076                   // start-err-line
                           : 1078                   // end-err-line
                           : 13                     // token-start
                           : 18);                   // token-end

         Eventf_writeError(source_id
                           : 1077                   // stmt-line
                           : 'RNF5409'              // msg-id
                           : 30                     // sev-num
                           : 'The prototyped call returns a value which is +
                              lost when CALLP is used.'
                           : EVF_SEVERITY_ERROR     // sev-char
                           : EVF_ANNOTATION_TOP);   // annotation class

         Eventf_writeFileEnd(source_id: 842); // close module source

         Eventf_close();

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTFT2  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTFT2  "
mbrtype =  "RPGLE     "
mbrtext =  "Event File API - Example 2 (QSYS object names)    "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *===============================================================*
      *                                                               *
      *  erstellt : 19.05.2013                                        *
      *                                                               *
      *===============================================================*
      *                                                               *
      *  Kurzdokumentation :                                          *
      *                                                               *
      *  Rahmentestprogramm mit Protokollausgabe                      *
      *  Thema:                                                       *
      *     Event File API - Example 2 (QSYS object names)            *
      *                                                               *
      *===============================================================*
      * >>PRE-COMPILER<<                                              *
      *                                                               *
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +                   *
      *                           SRCFILE(&SL/&SF) +                  *
      *                           SRCMBR(&SM);                        *
      *                                                               *
      *   >>COMPILE<<                                                 *
      *     >>PARM<< TRUNCNBR(*NO);                                   *
      *     >>PARM<< DBGVIEW(*LIST);                                  *
      *     >>PARM<< OPTION(*EVENTF);                                 *
      *   >>END-COMPILE<<                                             *
      *                                                               *
      *   >>EXECUTE<<                                                 *
      *                                                               *
      *   >>CMD<<    CRTPGM       PGM(&LI/&OB) +                      *
      *                           MODULE(&LI/&OB          +           *
      *                                          ) +                  *
      *                           BNDSRVPGM(*LIBL/BASICS1      +      *
      *                                     *LIBL/EVENTF       +      *
      *                                          ) +                  *
      *                           BNDDIR(*N         ) +               *
      *                           DETAIL(*BASIC) +                    *
      *                           ACTGRP(*NEW);                       *
      *                                                               *
      * >>END-PRE-COMPILER<<                                          *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
     FQSYSPRT   O    F   80        PRINTER OFLIND(*in70)
      *
      * ------------------------------------
      *  Type definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1                      SrvPgm: Basics 1
      *
      *  Examinee
      /COPY QEVENTF,PEVENTF                        Event File API
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Globale Konstanten
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                  extpgm('EVENTFT2')
      *
     D main...
     D                 PR                         extproc('main')
      *
      *  Logs a message to the job log or appends it to a spooled file
     D logMsg...
     D                 PR                         extproc('logMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying
      *
      *  Prints a given message to QSYSPRT.
     D printMsg...
     D                 PR                  extproc('printMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
     D PGM_ENTRY_POINT...
     D                 PI
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         if (%open(QSYSPRT));
            close QSYSPRT;
         endif;

         *inlr = *on;

      /END-FREE
      *
      *===============================================================*
      *  *** private ***
      *  Logs a message to the job log or appends it to a spooled file
      *===============================================================*
     P logMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if (%parms() >= 1);
            printMsg(i_text);
            // sndMsg(i_text);
         else;
            printMsg('');
            // no output to the job log
         endif;

      /END-FREE
      *
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';
         clear errCode;
         errCode.bytPrv = %size(errCode);
         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);
         return;

      /END-FREE
      *
     P                 E
      *
      * =====================================================================
      *  *** private ***
      *  Prints a given message to QSYSPRT.
      * =====================================================================
     P printMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Local fields
     D lineOutput      DS            80    inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free
         if (not %open(QSYSPRT));
            open QSYSPRT;
         endif;
         if (%parms() >= 1);
            lineOutput = i_text;
         endif;
         write QSYSPRT lineOutput;
      /end-free
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D source_id       s                   like(evf_source_id_t)
     D object          s                   like(evf_objName_t)
     D library         s                   like(evf_objName_t)
     D qFile           ds                  likeds(qFile_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         object = 'EVENTF';
         library = 'RADDATZ';

         Eventf_open(library: object);
         Eventf_writeProcessor();

         // Add module source
         source_id = 1;
         qFile.name = 'QEVENTF';
         qFile.lib = 'RADDATZ';
         qFile.mbr = 'EVENTF1';
         Eventf_writeFileID(source_id: qFile
                            : EVF_NAME_TYPE_QSYS
                            : EVF_PERSISTENT_SOURCE);

         // Add first /copy book
         qFile.name = 'QEVENTF';
         qFile.lib = 'RADDATZ';
         qFile.mbr = 'H_SPEC';
         Eventf_writeFileID(source_id + 1: qFile
                            : EVF_NAME_TYPE_QSYS
                            : EVF_PERSISTENT_SOURCE
                            : 43);

         Eventf_writeFileEnd(source_id + 1: 10);
         Eventf_writeFileEnd(source_id: 842);

         Eventf_close();

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTFT3  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTFT3  "
mbrtype =  "RPGLE     "
mbrtext =  "Event File API - Example 3 (QSYS object names)    "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *===============================================================*
      *                                                               *
      *  erstellt : 19.05.2013                                        *
      *                                                               *
      *===============================================================*
      *                                                               *
      *  Kurzdokumentation :                                          *
      *                                                               *
      *  Rahmentestprogramm mit Protokollausgabe                      *
      *  Thema:                                                       *
      *     Event File API - Example 3 (QSYS object names)            *
      *                                                               *
      *===============================================================*
      * >>PRE-COMPILER<<                                              *
      *                                                               *
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +                   *
      *                           SRCFILE(&SL/&SF) +                  *
      *                           SRCMBR(&SM);                        *
      *                                                               *
      *   >>COMPILE<<                                                 *
      *     >>PARM<< TRUNCNBR(*NO);                                   *
      *     >>PARM<< DBGVIEW(*LIST);                                  *
      *     >>PARM<< OPTION(*EVENTF);                                 *
      *   >>END-COMPILE<<                                             *
      *                                                               *
      *   >>EXECUTE<<                                                 *
      *                                                               *
      *   >>CMD<<    CRTPGM       PGM(&LI/&OB) +                      *
      *                           MODULE(&LI/&OB          +           *
      *                                          ) +                  *
      *                           BNDSRVPGM(*LIBL/BASICS1      +      *
      *                                     *LIBL/EVENTF       +      *
      *                                          ) +                  *
      *                           BNDDIR(*N         ) +               *
      *                           DETAIL(*BASIC) +                    *
      *                           ACTGRP(*NEW);                       *
      *                                                               *
      * >>END-PRE-COMPILER<<                                          *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
     FQSYSPRT   O    F   80        PRINTER OFLIND(*in70)
      *
      * ------------------------------------
      *  Type definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1                      SrvPgm: Basics 1
      *
      *  Examinee
      /COPY QEVENTF,PEVENTF                        Event File API
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Globale Konstanten
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                  extpgm('EVENTFT3')
      *
     D main...
     D                 PR                         extproc('main')
      *
      *  Logs a message to the job log or appends it to a spooled file
     D logMsg...
     D                 PR                         extproc('logMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying
      *
      *  Prints a given message to QSYSPRT.
     D printMsg...
     D                 PR                  extproc('printMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
     D PGM_ENTRY_POINT...
     D                 PI
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         if (%open(QSYSPRT));
            close QSYSPRT;
         endif;

         *inlr = *on;

      /END-FREE
      *
      *===============================================================*
      *  *** private ***
      *  Logs a message to the job log or appends it to a spooled file
      *===============================================================*
     P logMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if (%parms() >= 1);
            printMsg(i_text);
            // sndMsg(i_text);
         else;
            printMsg('');
            // no output to the job log
         endif;

      /END-FREE
      *
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';
         clear errCode;
         errCode.bytPrv = %size(errCode);
         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);
         return;

      /END-FREE
      *
     P                 E
      *
      * =====================================================================
      *  *** private ***
      *  Prints a given message to QSYSPRT.
      * =====================================================================
     P printMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Local fields
     D lineOutput      DS            80    inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free
         if (not %open(QSYSPRT));
            open QSYSPRT;
         endif;
         if (%parms() >= 1);
            lineOutput = i_text;
         endif;
         write QSYSPRT lineOutput;
      /end-free
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D source_id       s                   like(evf_source_id_t)
     D object          s                   like(evf_objName_t)
     D library         s                   like(evf_objName_t)
     D qQSYSObj        ds                  likeds(qQSYSObj_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         object = 'EVENTF';
         library = 'RADDATZ';

         Eventf_open(library: object);
         Eventf_writeProcessor();

         // Add module source
         source_id = 1;
         qQSYSObj.name = 'QEVENTF';
         qQSYSObj.lib = 'RADDATZ';
         qQSYSObj.mbr = 'EVENTF1';
         Eventf_writeFileID(source_id: qQSYSObj
                            : EVF_NAME_TYPE_QSYS
                            : EVF_PERSISTENT_SOURCE);

         // Add first /copy book
         qQSYSObj.name = 'QEVENTF';
         qQSYSObj.lib = 'RADDATZ';
         qQSYSObj.mbr = 'H_SPEC';
         Eventf_writeFileID(source_id + 1: qQSYSObj
                            : EVF_NAME_TYPE_QSYS
                            : EVF_PERSISTENT_SOURCE
                            : 43);

         Eventf_writeFileEnd(source_id + 1: 10);
         Eventf_writeFileEnd(source_id: 842);

         Eventf_close();

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTFT4  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTFT4  "
mbrtype =  "RPGLE     "
mbrtext =  "Event File API - Example 4 (long path names)      "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *===============================================================*
      *                                                               *
      *  erstellt : 19.05.2013                                        *
      *                                                               *
      *===============================================================*
      *                                                               *
      *  Kurzdokumentation :                                          *
      *                                                               *
      *  Rahmentestprogramm mit Protokollausgabe                      *
      *  Thema:                                                       *
      *     Event File API - Example 4 (long path names)              *
      *                                                               *
      *===============================================================*
      * >>PRE-COMPILER<<                                              *
      *                                                               *
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +                   *
      *                           SRCFILE(&SL/&SF) +                  *
      *                           SRCMBR(&SM);                        *
      *                                                               *
      *   >>COMPILE<<                                                 *
      *     >>PARM<< TRUNCNBR(*NO);                                   *
      *     >>PARM<< DBGVIEW(*LIST);                                  *
      *     >>PARM<< OPTION(*EVENTF);                                 *
      *   >>END-COMPILE<<                                             *
      *                                                               *
      *   >>EXECUTE<<                                                 *
      *                                                               *
      *   >>CMD<<    CRTPGM       PGM(&LI/&OB) +                      *
      *                           MODULE(&LI/&OB          +           *
      *                                          ) +                  *
      *                           BNDSRVPGM(*LIBL/BASICS1      +      *
      *                                     *LIBL/EVENTF       +      *
      *                                          ) +                  *
      *                           BNDDIR(*N         ) +               *
      *                           DETAIL(*BASIC) +                    *
      *                           ACTGRP(*NEW);                       *
      *                                                               *
      * >>END-PRE-COMPILER<<                                          *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
     FQSYSPRT   O    F   80        PRINTER OFLIND(*in70)
      *
      * ------------------------------------
      *  Type definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1                      SrvPgm: Basics 1
      *
      *  Examinee
      /COPY QEVENTF,PEVENTF                        Event File API
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Globale Konstanten
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                  extpgm('EVENTFT4')
      *
     D main...
     D                 PR                         extproc('main')
      *
      *  Logs a message to the job log or appends it to a spooled file
     D logMsg...
     D                 PR                         extproc('logMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying
      *
      *  Prints a given message to QSYSPRT.
     D printMsg...
     D                 PR                  extproc('printMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
     D PGM_ENTRY_POINT...
     D                 PI
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         if (%open(QSYSPRT));
            close QSYSPRT;
         endif;

         *inlr = *on;

      /END-FREE
      *
      *===============================================================*
      *  *** private ***
      *  Logs a message to the job log or appends it to a spooled file
      *===============================================================*
     P logMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if (%parms() >= 1);
            printMsg(i_text);
            // sndMsg(i_text);
         else;
            printMsg('');
            // no output to the job log
         endif;

      /END-FREE
      *
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';
         clear errCode;
         errCode.bytPrv = %size(errCode);
         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);
         return;

      /END-FREE
      *
     P                 E
      *
      * =====================================================================
      *  *** private ***
      *  Prints a given message to QSYSPRT.
      * =====================================================================
     P printMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Local fields
     D lineOutput      DS            80    inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free
         if (not %open(QSYSPRT));
            open QSYSPRT;
         endif;
         if (%parms() >= 1);
            lineOutput = i_text;
         endif;
         write QSYSPRT lineOutput;
      /end-free
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D source_id       s                   like(evf_source_id_t)
     D object          s                   like(evf_objName_t)
     D library         s                   like(evf_objName_t)
     D fileName        s                   like(evf_path_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         object = 'EVENTF';
         library = 'RADDATZ';

         Eventf_open(library: object);
         Eventf_writeProcessor();

         // Add module source
         source_id = 1;
         fileName =
            '/home/raddatz/directory1/directory2/directory3/directory4/di+
             rectory5/directory6/directory7/directory8/directory9/directo+
             ry10/directory11/directory12/directory13/directory14/directo+
             ry15/directory16/directory17/directory18/directory19/directo+
             ry20/EVENTF1.RPGLE';
         Eventf_writeFileID(source_id: fileName
                            : EVF_NAME_TYPE_PATH
                            : EVF_PERSISTENT_SOURCE);

         // Add first /copy book
         fileName =
            '/home/raddatz/directory1/directory2/directory3/directory4/di+
             rectory5/directory6/directory7/directory8/directory9/directo+
             ry10/directory11/directory12/directory13/directory14/directo+
             ry15/directory16/directory17/directory18/directory19/directo+
             ry20/H_SPEC.RPGLE';

         Eventf_writeFileID(source_id + 1: fileName
                            : EVF_NAME_TYPE_PATH
                            : EVF_PERSISTENT_SOURCE
                            : 43);

         Eventf_writeFileEnd(source_id + 1: 10);
         Eventf_writeFileEnd(source_id: 842);

         Eventf_close();

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing EVENTF1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "EVENTF1   "
mbrtype =  "RPGLE     "
mbrtext =  "EVFEVENT API - Public Interface                   "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *=====================================================================*
      *  EVENTF API - Public Interface                                      *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  19.05.2013                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Date        Name          Description                              *
      *  ----------  ------------  ---------------------------------------  *
      *  23.07.2015  Th.Raddatz    Fixed problem that an invalid error      *
      *                            was produced for blank messages IDs.     *
      *  17.01.2017  Th.Raddatz    Changed parameter o_rtnLib of procedure  *
      *                            Eventf_open() to *NOPASS/*OMIT.          *
      *                            Added procedure Eventf_openAppend().     *
      *  28.01.2017  Th.Raddatz    Added procedures: Eventf_copyFrom()      *
      *                                              Eventf_openAppend()    *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD   MODULE(&LI/&OB) +                       *
      *                             SRCFILE(&SL/&SF) +                      *
      *                             SRCMBR(&SM);                            *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< OPTION(*EVENTF);                                     *
      *       >>PARM<< TGTRLS(V7R1M0  );                                    *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN BNDDIR('QC2LE')
      /COPY QEVENTF,H_SPEC
      /COPY QEVENTF,COPYRIGHT
      *=====================================================================*
     FEVFEVENT  UF A F  300        DISK    usropn
     F                                     extfile(g_status.outFile)
     F                                     extmbr(g_status.outMbr)
     F                                     infds(g_fileInfo)
     F                                     block(*no)
      *
     FEVFEVENT2 IF   F  300        DISK    usropn
     F                                     extfile(g_inFile.name)
     F                                     extmbr(g_inFile.mbr)
     F                                     infds(g_fileInfo2)
     F                                     block(*no)
      *
     D g_fileInfo      ds                  likeds(infDS_DB_t)
     D g_fileInfo2     ds                  likeds(infDS_DB_t)
      * ------------------------------------
      *  Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  Exported prototypes
      * ------------------------------------
      /COPY QEVENTF,PEVENTF
      *
      * ------------------------------------
      *  Imported prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      /COPY QEVENTF,CEELIB                         CEE APIs
      /COPY QEVENTF,QP0LCVTPAT                     Qp0lCvtPathToQSYSObjName()--Resolve Path
      /COPY QEVENTF,QCMDEXC                        Execute Command (QCMDEXC) API
      *
      /define fileInfDS_DB
      /COPY QEVENTF,FDINFDS
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      *
      *  Adds a value to the output buffer.
     D addValue...
     D                 pr            10u 0
     D                                     extproc('addValue')
     D  io_buffer                   300a
     D  io_pos                       10u 0
     D  i_value                     300a   const
      *
      *  Returns the timestamp, the file was last changed.
     D getLastChangedTime...
     D                 pr              z
     D                                     extproc('getLastChangedTime')
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
      *
      *  Returns the QSYS file name.
     D getQSYSFileName...
     D                 pr                  likeds(qFile_t)
     D                                     extproc('getQSYSFileName')
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
      *
      *  Creates an event file.
     D createEventFile...
     D                 pr
     D                                     extproc('createEventFile')
     D  i_file                             const like(evf_objName_t)
     D  i_lib                              const like(evf_objName_t)
      *
      *  Adds a member to the event file.
     D addEventFileMember...
     D                 pr
     D                                     extproc('addEventFileMember')
     D  i_file                             const like(evf_objName_t)
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
      *  Clears the member of the event file.
     D clearEventFileMember...
     D                 pr
     D                                     extproc('clearEventFileMember')
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
      *  Opens the event file.
     D openEventFile...
     D                 pr                  like(evf_objName_t)
     D                                     extproc('openEventFile')
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
      *  Closes the event file.
     D closeEventFile...
     D                 pr
     D                                     extproc('closeEventFile')
      *
      *  Appends a TIMESTAMP record to the event file.
     D writeTimestampRecord...
     D                 pr
     D                                     extproc('writeTimestampRecord')
      *
      *  Appends a PROCESSOR record to the event file.
     D writeProcessorRecord...
     D                 pr
     D                                     extproc('writeProcessorRecord')
     D  i_output_id                        const like(evf_output_id_t)
     D  i_line_class                       const like(evf_line_class_t)
      *
      *  Appends a FILEID record to the event file.
     D writeFileIDRecord...
     D                 pr
     D                                     extproc('writeFileIDRecord')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_line                             const like(evf_line_t)
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
     D  i_temp_flag                        const like(evf_temp_flag_t)
      *
      *  Appends a FILEEND record to the event file.
     D writeFileEndRecord...
     D                 pr
     D                                     extproc('writeFileEndRecord')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_expansions                       const like(evf_expansion_t)
      *
      *  Appends an ERROR record to the event file.
     D writeErrorRecord...
     D                 pr
     D                                     extproc('writeErrorRecord')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_annot_class                      const like(evf_annot_class_t)
     D  i_stmt_line                        const like(evf_line_t)
     D  i_start_err_line...
     D                                     const like(evf_line_t)
     D  i_token_start                      const like(evf_token_t)
     D  i_end_err_line...
     D                                     const like(evf_line_t)
     D  i_token_end                        const like(evf_token_t)
     D  i_msg_id                           const like(evf_msg_id_t)
     D  i_sev_char                         const like(evf_sev_char_t)
     D  i_sev_num                          const like(evf_sev_num_t)
     D  i_length                           const like(evf_length_t)
     D  i_msg_text                         const like(evf_msg_text_t)
      *
      *  Converts a given message severity to the annotation class.
     D getAnnotationClass...
     D                 pr             1a
     D                                     extproc('getAnnotationClass')
     D  i_msgSeverity                10i 0 value
      *
      *  Converts a given message type to the severity character.
     D getSeverityChar...
     D                 pr             1a
     D                                     extproc('getSeverityChar')
     D  i_msgSeverity                10i 0 value
      *
      * ------------------------------------
      *  Global fields & constants
      * ------------------------------------
     D EVENT_FILE      c                   'EVFEVENT'
     D VERSION         c                   '0'
      *
     D g_status        ds                  qualified
     D  outFile                      21a   inz
     D  outMbr                             like(evf_objName_t) inz
      *
     D g_inFile        ds                  qualified
     D  name                         21a   inz
     D  mbr                                like(evf_objName_t) inz
      *
      *=========================================================================
      *  Opens an event file member. The event file is created, if
      *  it does not yet exist.
      *=========================================================================
      *  Parameters:
      *   i_lib         - Name of the library that contains the EVFEVENT file.
      *                   This parameter must be set to the name of the library
      *                   where the created object is to be stored.
      *   i_mbr         - Name of the member to use.
      *                   This parameter must be set to the name of the object
      *                   that is to be created.
      *   o_rtnLib      - Return the actual library that contains the event file.
      *
      *  Returns:
      *   done          - Returns cTrue on success, else cFalse.
      *=========================================================================
     P Eventf_open...
     P                 b                   export
     D                 pi
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
     D  o_rtnLib                                 like(evf_objName_t)
     D                                           options(*nopass: *omit)
      *
     D p_rtnLib        c                   3
      *
     D rtnLib          s                   like(o_rtnLib) inz
     D msg             ds                  likeds(msg_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         monitor;

            rtnLib = '';

            if (not f_exist(EVENT_FILE: i_lib: '*FILE'));
               createEventFile(EVENT_FILE: i_lib);
            endif;

            if (not f_exist(EVENT_FILE: i_lib: '*FILE': i_mbr));
               addEventFileMember(EVENT_FILE: i_lib: i_mbr);
            endif;

            clearEventFileMember(i_lib: i_mbr);

            rtnLib = openEventFile(i_lib: i_mbr);

         on-error;
            msg = f_rcvPgmMsgObj(cMsg_Escape);
            f_sndPgmMsg(msg: cMsg_Prv);
         endmon;

         if (%parms() >= p_rtnLib and %addr(o_rtnLib) <> *null);
            o_rtnLib = rtnLib;
         endif;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Clears an existing event file member.
      *=========================================================================
      *  Parameters:
      *   i_lib         - Name of the library that contains the EVFEVENT file.
      *                   This parameter must be set to the name of the library
      *                   where the created object is to be stored.
      *   i_mbr         - Name of the member to use.
      *                   This parameter must be set to the name of the object
      *                   that is to be created.
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_clear...
     P                 b                   export
     D                 pi
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
     D msg             ds                  likeds(msg_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         monitor;

            if (not f_exist(EVENT_FILE: i_lib: '*FILE'));
               return;
            endif;

            if (not f_exist(EVENT_FILE: i_lib: '*FILE': i_mbr));
               return;
            endif;

            clearEventFileMember(i_lib: i_mbr);

         on-error;
            msg = f_rcvPgmMsgObj(cMsg_Escape);
            f_sndPgmMsg(msg: cMsg_Prv);
         endmon;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Opens an event file member for appending records. The event file
      *  is created, if it does not yet exist.
      *=========================================================================
      *  Parameters:
      *   i_lib         - Name of the library that contains the EVFEVENT file.
      *                   This parameter must be set to the name of the library
      *                   where the created object is to be stored.
      *   i_mbr         - Name of the member to use.
      *                   This parameter must be set to the name of the object
      *                   that is to be created.
      *   o_rtnLib      - Return the actual library that contains the event file.
      *
      *  Returns:
      *   done          - Returns cTrue on success, else cFalse.
      *=========================================================================
     P Eventf_openAppend...
     P                 b                   export
     D                 pi              n
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
     D  o_rtnLib                                 like(evf_objName_t)
     D                                           options(*nopass: *omit)
      *
     D p_rtnLib        c                   3
      *
     D rtnLib          s                   like(o_rtnLib) inz
     D msg             ds                  likeds(msg_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         monitor;

            rtnLib = '';

            if (not f_exist(EVENT_FILE: i_lib: '*FILE'));
               return cFalse;
            endif;

            if (not f_exist(EVENT_FILE: i_lib: '*FILE': i_mbr));
               return cFalse;
            endif;

            rtnLib = openEventFile(i_lib: i_mbr);

         on-error;
            msg = f_rcvPgmMsgObj(cMsg_Escape);
            f_sndPgmMsg(msg: cMsg_Prv);
         endmon;

         if (%parms() >= p_rtnLib and %addr(o_rtnLib) <> *null);
            o_rtnLib = rtnLib;
         endif;

         return cTrue;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Appends a 'PROCESSOR' record to the event file.
      *=========================================================================
      *  Parameters:
      *   i_output_id   - The file ID of an output file produced by this
      *                   processor.
      *                   Default:        0
      *   i_line_class  - Method used to number lines.
      *                    EVF_LINE_CLASS_PHYSICAL_SOURCE -
      *                          physical line number
      *                    EVF_LINE_CLASS_EXPANDED_SOURCE -
      *                          line number in an expanded source
      *                   Default:        EVF_LINE_CLASS_PHYSICAL_SOURCE
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_writeProcessor...
     P                 b                   export
     D                 pi
     D  i_output_id                        const like(evf_output_id_t)
     D                                           options(*nopass: *omit)
     D  i_line_class                       const like(evf_line_class_t)
     D                                           options(*nopass: *omit)
      *
      *  Parameter positions
     D p_output_id     c                   1
     D p_line_class    c                   2
      *
      *  Optional parameters
     D output_id       s                   like(i_output_id)
     D line_class      s                   like(i_line_class)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (not %open(EVFEVENT));
            return;
         endif;

         if (%parms() >= p_output_id and %addr(i_output_id) <> *null);
            output_id = i_output_id;
         else;
            output_id = 0;
         endif;

         if (%parms() >= p_line_class and %addr(i_line_class) <> *null);
            line_class = i_line_class;
         else;
            line_class = EVF_LINE_CLASS_PHYSICAL_SOURCE;
         endif;

         writeTimestampRecord();
         writeProcessorRecord(output_id: line_class);

      /end-free
     P                 e
      *
      *=========================================================================
      *  Appends a 'FILEID' record to the event file.
      *=========================================================================
      *  Parameters:
      *   i_source_id   - A file identifier expressed as an integer.
      *   i_path        - Qualified member name, specified as:
      *                    a) a path name
      *                    b) a QSYS object name of type qFile_t
      *                    c) a QSYS object name of type qQSYSObj_t
      *   i_nameType    - Type of parameter 'i_path'.
      *                    EVF_NAME_TYPE_PATH - for a path name
      *                    EVF_NAME_TYPE_QSYS - for a QSYS object name
      *                   Default:        EVF_NAME_TYPE_QSYS
      *   i_temp_flag   - Indicates whether the source is a temporary file.
      *                   Default:        EVF_PERSISTENT_SOURCE
      *   i_line        - Source file line number where the new file
      *                   is referenced.
      *                   Default:        0
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_writeFileID...
     P                 b                   export
     D                 pi                  opdesc
     D  i_source_id                        const like(evf_source_id_t)
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
     D  i_nameType                    1a   const options(*nopass: *omit)
     D  i_temp_flag                        const like(evf_temp_flag_t)
     D                                           options(*nopass: *omit)
     D  i_line                             const like(evf_line_t)
     D                                           options(*nopass: *omit)
      *
      *  Parameter positions
     D p_path          c                   2
     D p_nameType      c                   3
     D p_temp_flag     c                   4
     D p_line          c                   5
      *
      *  Optional parameters
     D nameType        s                   like(i_nameType)
     D temp_flag       s                   like(i_temp_flag)
     D line            s                   like(i_line)
      *
     D qQSYSObj        ds                  likeds(qQSYSObj_t) inz
     D qFile           ds                  likeds(qFile_t) inz
     D nameInf         ds                  likeds(strInf_t) inz
     D path            s                   like(i_path) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (not %open(EVFEVENT));
            return;
         endif;

         if (%parms() >= p_nameType and %addr(i_nameType) <> *null);
            nameType = i_nameType;
         else;
            nameType = EVF_NAME_TYPE_QSYS;
         endif;

         if (%parms() >= p_temp_flag and %addr(i_temp_flag) <> *null);
            temp_flag = i_temp_flag;
         else;
            temp_flag = EVF_PERSISTENT_SOURCE;
         endif;

         if (%parms() >= p_line and %addr(i_line) <> *null);
            line = i_line;
         else;
            line = 0;
         endif;

         if (nameType = EVF_NAME_TYPE_QSYS);
            CEEGSI(p_path
                   : nameInf.dataType: nameInf.curlen: nameInf.maxlen: *omit);
            if (nameInf.curlen = 30);
               qFile = i_path;
            else;
               qQSYSObj = i_path;
               qFile.name = qQSYSObj.name;
               qFile.lib = qQSYSObj.lib;
               qFile.mbr = qQSYSObj.mbr;
            endif;
            path = f_cvtQSYSObjNameToPath(qFile);
         else;
            path = i_path;
         endif;

         writeFileIDRecord(i_source_id: line: path: temp_flag);

      /end-free
     P                 e
      *
      *=========================================================================
      *  Appends a 'FILEEND' record to the event file.
      *=========================================================================
      *  Parameters:
      *   i_source_id   - A file identifier expressed as an integer.
      *   i_expansion   - Number of expanded source lines.
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_writeFileEnd...
     P                 b                   export
     D                 pi
     D  i_source_id                        const like(evf_source_id_t)
     D  i_expansion                        const like(evf_expansion_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (not %open(EVFEVENT));
            return;
         endif;

         writeFileEndRecord(i_source_id: i_expansion);

      /end-free
     P                 e
      *
      *=========================================================================
      *  Appends an 'ERROR' record to the event file.
      *=========================================================================
      *  Parameters:
      *   i_source_id      - A file identifier expressed as an integer.
      *   i_stmt_line      - Line number containing the error.
      *   i_msg_id         - Message ID (for example, AMPX999).
      *   i_sev_num        - Severity level number.
      *   i_msg_text       - The message text of the error message.
      *   i_sev_char       - Severity code letter (I, W, E, S, or T).
      *   i_annot_class    - Indicates where in a listing of messages this
      *                      message should be placed.
      *   i_start_err_line - Line number containing the start of the error.
      *                      Default:        i_stmt_line
      *   i_end_err_line   - Line number containing the end of the error.
      *                      Default:        i_stmt_line
      *   i_token_start    - Column of the start of the token in error.
      *                      Default:        1
      *   i_token_end      - Column of the start of the token in error.
      *                      Default:        0
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_writeError...
     P                 b                   export
     D                 pi
     D  i_source_id                        const like(evf_source_id_t)
     D  i_stmt_line                        const like(evf_line_t)
     D  i_msg_id                           const like(evf_msg_id_t)
     D  i_sev_num                          const like(evf_sev_num_t)
     D  i_msg_text                         const like(evf_msg_text_t)
     D  i_sev_char                         const like(evf_sev_char_t)
     D                                           options(*nopass: *omit)
     D  i_annot_class                      const like(evf_annot_class_t)
     D                                           options(*nopass: *omit)
     D  i_start_err_line...
     D                                     const like(evf_line_t)
     D                                           options(*nopass: *omit)
     D  i_end_err_line...
     D                                     const like(evf_line_t)
     D                                           options(*nopass: *omit)
     D  i_token_start...
     D                                     const like(evf_token_t)
     D                                           options(*nopass: *omit)
     D  i_token_end...
     D                                     const like(evf_token_t)
     D                                           options(*nopass: *omit)
      *
      *  Parameter positions
     D p_sev_char      c                   6
     D p_annot_class...
     D                 c                   7
     D p_start_err_line...
     D                 c                   8
     D p_end_err_line  c                   9
     D p_token_start   c                   10
     D p_token_end     c                   11
      *
      *  Optional parameters
     D sev_char        s                   like(i_sev_char)
     D annot_class     s                   like(i_annot_class)
     D start_err_line  s                   like(i_start_err_line)
     D end_err_line    s                   like(i_end_err_line)
     D token_start     s                   like(i_token_start)
     D token_end       s                   like(i_token_end)
      *
     D msg_id          s                   like(i_msg_id)
     D msg_text        s                   like(i_token_end)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%parms() >= p_sev_char and %addr(i_sev_char) <> *null);
            sev_char = i_sev_char;
         else;
            sev_char = getSeverityChar(i_sev_num);
         endif;

         if (%parms() >= p_annot_class and %addr(i_annot_class) <> *null);
            annot_class = i_annot_class;
         else;
            annot_class = getAnnotationClass(i_sev_num);
         endif;

         if (%parms() >= p_start_err_line and %addr(i_start_err_line) <> *null);
            start_err_line = i_start_err_line;
         else;
            start_err_line = i_stmt_line;
         endif;

         if (%parms() >= p_end_err_line and %addr(i_end_err_line) <> *null);
            end_err_line = i_end_err_line;
         else;
            end_err_line = start_err_line;
         endif;

         if (%parms() >= p_token_start and %addr(i_token_start) <> *null);
            token_start = i_token_start;
         else;
            token_start = 1;
         endif;

         if (%parms() >= p_token_end and %addr(i_token_end) <> *null);
            token_end = i_token_end;
         else;
            token_end = 0;
         endif;

         if (i_msg_id <> '');
            msg_id = i_msg_id;
         else;
            msg_id = '[none]';
         endif;

         writeErrorRecord(i_source_id: annot_class: i_stmt_line
                          : start_err_line: token_start
                          : end_err_line: token_end
                          : msg_id: sev_char: i_sev_num
                          : %len(i_msg_text): i_msg_text);

      /end-free
     P                 e
      *
      *=========================================================================
      *  Copies the events of a given event file into this event file.
      *=========================================================================
      *  Parameters:
      *   i_fromLib     - Name of the library that contains the EVFEVENT file.
      *                   This parameter must be set to the name of the library
      *                   where the created object is to be stored.
      *   i_fromMbr     - Name of the member to use.
      *                   This parameter must be set to the name of the object
      *                   that is to be created.
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_copyFrom...
     P                 b                   export
     D                 pi
     D  i_fromLib                          const like(evf_objName_t)
     D  i_fromMbr                          const like(evf_objName_t)
      *
     D buffer          ds           300
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         g_inFile.name = %trim(i_fromLib) + '/' + EVENT_FILE;
         g_inFile.mbr = %trim(i_fromMbr);
         open EVFEVENT2;

         dou (%eof(EVFEVENT2));
            read EVFEVENT2 buffer;
            if (not %eof);
               write EVFEVENT buffer;
            endif;
         enddo;

         close EVFEVENT2;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Closes an event file member.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   void
      *=========================================================================
     P Eventf_close...
     P                 b                   export
     D                 pi
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         closeEventFile();

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Appends a TIMESTAMP record to the event file.
      *
      *  This record indicates when the Events File was created, and allows an
      *  application to determine if the Events File is current (if the timestamp
      *  is older than a file indicated in a File ID record, the Events File may
      *  be incorrect for that file). This record is always the first record in
      *  the Events File.
      *
      *  Note: This record is not written by a processor; it is written by the
      *  caller of the first processor. This allows each processor to append to
      *  the Events File without having to determine if the file exists.
      *=========================================================================
     P writeTimestampRecord...
     P                 b
     D                 pi
      *
     D timestamp       ds           300    qualified inz
     D  format                 1     10a   inz('TIMESTAMP')
     D  version               12     12a   inz(VERSION)
     D  timestamp             14     27a
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         reset timestamp;
         timestamp.timestamp = %char(%date(): *ISO0) + %char(%time(): *HMS0);
         write EVFEVENT timestamp;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Appends a PROCESSOR record to the event file.
      *
      *  This record indicates that a new processor has been invoked. One will
      *  always follow the timestamp record in the Events File (although there
      *  may be more than one).
      *
      *  version
      *  The revision of this record, used for upward compatibility. The current
      *  version is "1".
      *
      *  output-id
      *  The file ID of an output file produced by this processor. If the output
      *  of this processor is intended to be used as input to another processor,
      *  this file ID represents that file, and the file ID record of the file
      *  will follow this record. If this is the last processor that will be
      *  invoked for which the editor will be expected to display messages, the
      *  file ID is 0.
      *
      *  line-class
      *  Method used to number lines. Specify zero if a temporary file or
      *  internal file containing an expanded source representation is being
      *  used; the line number represents the line number in the expanded source.
      *  Specify one if the line number represents the physical line number in
      *  the source file indicated in source file ID field.
      *
      *  Note: If the output of one processor is intended as the input to another
      *  processor, the FILEID record for the output should contain a name, even
      *  if the output is not placed in a real file. This same name should be
      *  used in the input FILEID record of the processor using the output.
      *=========================================================================
     P writeProcessorRecord...
     P                 b
     D                 pi
     D  i_output_id                        const like(evf_output_id_t)
     D  i_line_class                       const like(evf_line_class_t)
      *
     D processor       ds           300    qualified inz
     D  format                 1     10a   inz('PROCESSOR')
     D  version               12     12a   inz(VERSION)
     D  output_id             14     16a
     D  line_class            18     18a
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         reset processor;
         processor.output_id = %editc(i_output_id: 'X');
         processor.line_class = i_line_class;
         write EVFEVENT processor;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Appends a FILEID record to the event file.
      *
      *  This record contains the full name of the source file processed and
      *  associates an integer with the file name. There should be one record of
      *  this type for each source file processed (the main source file as well
      *  as any included source units (copylib members) and macros).
      *
      *  Note: If a file is included several times during processing, a file ID
      *  record should be written for each inclusion.
      *
      *  version
      *  The revision of this record, used for upward compatibility. The current
      *  version is "1".
      *
      *  source-id
      *  A file identifier expressed as an integer to be used in place of the
      *  file name to correlate an error record with the source file in which it
      *  occurred, without having to use the character based file name. Use zero
      *  if the input file is not known, such as input coming from a user exit.
      *
      *  line
      *  Source file line number where a new file is referenced, or zero if the
      *  file was not referenced from a file.
      *
      *  length
      *  Length of the file name; the maximum length is 255. In a FILEIDCONT
      *  record, the length is always zero since length is only determined by the
      *  file ID record.
      *
      *  filename
      *  The name should be the fully-qualified physical file name. If none
      *  exists (for example, getting text from the user) or the name can't be
      *  determined, place a null string here.
      *  The name can include servername.
      *
      *  sourcefile timestamp
      *  This is the timestamp on the Source file.
      *
      *  temp flag
      *  This field is set to 1 to indicate the source is a temporary file,
      *  otherwise it is set to 0. Temporary source file can only be opened in
      *  browse mode. Currently the temp flag is used to reference output
      *  generated by SQL preprocessor.
      *=========================================================================
     P writeFileIDRecord...
     P                 b
     D                 pi
     D  i_source_id                        const like(evf_source_id_t)
     D  i_line                             const like(evf_line_t)
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
     D  i_temp_flag                        const like(evf_temp_flag_t)
      *
     D fileID          ds           300    qualified inz
     D  format                 1     10a   inz('FILEID')
     D  version               12     12a   inz(VERSION)
     D  source_id             14     16a
     D  line                  18     23a
     D  length                25     27a
      *   char(*) - file name              FILE/LIBRARY(MEMBER), max. length = 255
      *   char(*) - source file timestamp  YYYYMMDDhhmmss
      *   char(*) - temp flag              0/1
      *
     D MAX_NAME_LENGTH...
     D                 c                   255
      *
     D pos             s             10u 0
     D offset          s             10u 0
     D len             s             10u 0
     D lastChanged     s             14a
     D path            s                   like(i_path) inz
     D qFile           ds                  likeds(qFile_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         lastChanged =
            %subst(%char(getLastChangedTime(i_path): *ISO0): 1: 14);

         if (f_startsWith('/QSYS.LIB': i_path));
            qFile = getQSYSFileName(i_path);
            path = %trimR(qFile.lib) + '/' +
                   %trimR(qFile.name) + '(' +
                   %trimR(qFile.mbr) + ')';
         else;
            path = i_path;
         endif;

         reset fileID;
         fileID.source_id = %editc(i_source_id: 'X');
         fileID.line = %editc(%dec(i_line: 6: 0): 'X');
         fileID.length = %editc(%dec(%len(path): 3: 0): 'X');

         offset = 0;
         dow (offset < %len(path));
            pos = 29;
            %subst(fileID: 29) = '';

            if (%len(path) - offset > MAX_NAME_LENGTH);
               len = MAX_NAME_LENGTH;
            else;
               len = %len(path) - offset;
            endif;

            addValue(fileID: pos: %subst(path: 1 + offset: len));
            if (offset + len >= %len(path));
               addValue(fileID: pos: lastChanged);
               addValue(fileID: pos: i_temp_flag);
            endif;

            write EVFEVENT fileID;

            offset += len;
            fileID.format = 'FILEIDCONT';
            fileID.line = %editc(%dec(0: 6: 0): 'X');
            fileID.length = %editc(%dec(0: 3: 0): 'X');
         enddo;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Appends a FILEEND record to the event file.
      *
      *  This record indicates that an included file is ending. It provides a
      *  method to determine the nesting of include files so a program can
      *  navigate back up the include chain. This is useful when the included
      *  file does not contain enough information to determine what caused the
      *  error.
      *
      *  version
      *  The revision of this record, used for upward compatibility. The current
      *  version is "1".
      *
      *  file-id
      *  file ID of this file. (source-id)
      *
      *  expansion
      *  Number of expanded source lines in this file, including any nested
      *  includes and macro expansions.
      *
      *  Note: Every file ID record must have a corresponding file end record,
      *  except for the file ID that follows the processor record to define the
      *  output file.
      *=========================================================================
     P writeFileEndRecord...
     P                 b
     D                 pi
     D  i_source_id                        const like(evf_source_id_t)
     D  i_expansion                        const like(evf_expansion_t)
      *
     D fileEnd         ds           300    qualified inz
     D  format                 1     10a   inz('FILEEND')
     D  version               12     12a   inz(VERSION)
     D  source_id             14     16a
     D  expansion             18     23a
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         reset fileEnd;
         fileEnd.source_id = %editc(i_source_id: 'X');
         fileEnd.expansion = %editc(i_expansion: 'X');
         write EVFEVENT fileEnd;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Appends an ERROR record to the event file.
      *
      *  A record of this type contains information required to locate a token or
      *  line causing a message in the source file, as well as enough information
      *  to allow the message itself to be displayed. This information includes
      *  location information (such as what file and line the error occurred on)
      *  and information related to the error itself (such as the number, text,
      *  and severity of the message).
      *
      *  version
      *  The revision of this record, used for upward compatibility. The current
      *  version is "1".
      *
      *  file-id
      *  file ID of this file. (source-id)
      *
      *  annot-class
      *  Indicates where in a listing of messages this message should be placed
      *  when the Events File is loaded in the Error List window. The positions
      *  are defined as follows:
      *
      *   0 - top of list
      *   2 - middle of list
      *   3 - bottom of list
      *
      *  stmt-line
      *  Line number (in the source file associated with the above source file ID
      *  number) of the first line of the statement containing the error. This is
      *  required in case the error does not occur on the first line of the
      *  statement. This number is interpreted using the line class field.
      *
      *  start-err-line
      *  Line number (in the source file associated with the above source file ID
      *  number) containing the start of the error. This number is interpreted
      *  using the line class field.
      *
      *  token-start
      *  Column (or character in the line) of the start of the token in error. If
      *  this information is not available, a zero here will cause the entire
      *  line to be flagged as an error.
      *
      *  end-err-line
      *  Line number (in the source file associated with the above source file ID
      *  number) containing the end of the error. This number is interpreted
      *  using the line class field.
      *
      *  token-end
      *  Column (or character in the line) of the end of the token in error. If
      *  this information is not available, a zero here will cause the entire
      *  line to be flagged as an error.
      *
      *  msg-id
      *  Message ID (for example, AMPX999).
      *
      *  sev-char
      *  Severity code letter (I, W, E, S, or T).
      *
      *  sev-num
      *  Severity level number. For some systems, this is the return code
      *  associated with the severity code letter
      *  (for example, I=0, W=4, E=8, S=12, T=16).
      *
      *  length
      *  The actual length of the message text (the next field). The maximum
      *  length is 1024 bytes.
      *
      *  msg
      *  The message text of the error message. Any replacement of fields should
      *  have already been done.
      *=========================================================================
     P writeErrorRecord...
     P                 b
     D                 pi
     D  i_source_id                        const like(evf_source_id_t)
     D  i_annot_class                      const like(evf_annot_class_t)
     D  i_stmt_line                        const like(evf_line_t)
     D  i_start_err_line...
     D                                     const like(evf_line_t)
     D  i_token_start                      const like(evf_token_t)
     D  i_end_err_line...
     D                                     const like(evf_line_t)
     D  i_token_end                        const like(evf_token_t)
     D  i_msg_id                           const like(evf_msg_id_t)
     D  i_sev_char                         const like(evf_sev_char_t)
     D  i_sev_num                          const like(evf_sev_num_t)
     D  i_length                           const like(evf_length_t)
     D  i_msg_text                         const like(evf_msg_text_t)
      *
     D error           ds           300    qualified inz
     D  format                 1     10a   inz('ERROR')
     D  version               12     12a   inz(VERSION)
     D  source_id             14     16a
     D  annot_class           18     18a
     D  stmt_line             20     25a
     D  start_err_line...
     D                        27     32a
     D  token_start           34     36a
     D  end_err_line          38     43a
     D  token_end             45     47a
     D  msg_id                49     55a
     D  sev_char              57     57a
     D  sev_num               59     60a
     D  length                62     64a
     D  msg                   66    283a
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         reset error;
         error.source_id = %editc(i_source_id: 'X');
         error.annot_class = i_annot_class;
         error.stmt_line = %editc(%dec(i_stmt_line: 6: 0): 'X');
         error.start_err_line = %editc(%dec(i_start_err_line: 6: 0): 'X');
         error.token_start = %editc(%dec(i_token_start: 3: 0): 'X');
         error.end_err_line = %editc(%dec(i_end_err_line: 6: 0): 'X');
         error.token_end = %editc(%dec(i_token_end: 3: 0): 'X');
         error.msg_id = i_msg_id;
         error.sev_char = i_sev_char;
         error.sev_num = %editc(%dec(i_sev_num: 2: 0): 'X');
         error.length = %editc(%dec(i_length: 3: 0): 'X');
         error.msg = i_msg_text;
         write EVFEVENT error;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Adds a value to the output buffer.
      *=========================================================================
     P addValue...
     P                 b
     D                 pi            10u 0
     D  io_buffer                   300a
     D  io_pos                       10u 0
     D  i_value                     300a   const
      *
     D length          s             10u 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         length = %len(%trimR(i_value));
         if (io_pos + length - 1 > %len(io_buffer));
            length = %len(io_buffer) - io_pos + 1;
         endif;

         if (length <= 0);
            return 0;
         endif;

         %subst(io_buffer: io_pos: length) = %subst(i_value: 1: length);
         io_pos += length + 1;

         return length;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Returns the timestamp, the file was last changed.
      *=========================================================================
     P getLastChangedTime...
     P                 b
     D                 pi              z
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
      *
     D lastChanged     s               z   inz
      *
     D rc              s             10i 0
     D st_stat         ds                  likeds(st_stat_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         rc = stat(i_path: %addr(st_stat));
         if (rc <> 0);
            return lastChanged;
         endif;

         lastChanged = f_cvtEpochTS(st_stat.ctime);

         return lastChanged;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Returns the QSYS file name.
      *=========================================================================
     P getQSYSFileName...
     P                 b
     D                 pi                  likeds(qFile_t)
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
      *
     D qFile           ds                  likeds(qFile_t) inz
      *
     D pathName        ds                  likeds(Qlg_Path_Name_t) inz
     D qsys_info       ds                  likeds(qsys0100_t) inz
     D errCode         ds                  likeds(errCode_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         pathName = *ALLx'00';
         pathName.CCSID = QLG_PATH_JOB_CCSID;
         pathName.Country_ID = QLG_PATH_JOB_COUNTRYID;
         pathName.Language_ID = QLG_PATH_JOB_LANGUAGEID;
         pathName.Reserved = *ALLx'00';
         pathName.Path_Type = QLG_CHAR_SINGLE;
         pathName.Path_Length = %len(%trimR(i_path));
         pathName.Path_Name_Delimiter = '/';
         pathName.Reserved2 = *ALLx'00';
         pathName.Path_Name = i_path;
         errCode = f_newApiErrCode(cFalse);

         Qp0lCvtPathToQSYSObjName(
            pathName: qsys_info: 'QSYS0100': %size(qsys_info): 0: errCode);

         qFile.name = %trimR(qsys_info.obj_name: x'00');
         qFile.lib = %trimR(qsys_info.lib_name: x'00');
         qFile.mbr = %trimR(qsys_info.mbr_name: x'00');

         return qFile;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Creates an event file.
      *=========================================================================
     P createEventFile...
     P                 b
     D                 pi
     D  i_file                             const like(evf_objName_t)
     D  i_lib                              const like(evf_objName_t)
      *
     D command         s            128a   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         command = 'CRTPF FILE(' + %trim(i_lib) + '/' + %trim(i_file) + ') +
                      RCDLEN(300) MAXMBRS(*NOMAX) SIZE(500000 1000 3) +
                      CCSID(*HEX) MBR(*NONE)';

         QCMDEXC(command: %len(command));

         p_rmvPgmMsg(cMsg_Rmv_All);

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Adds a member to a given event file.
      *=========================================================================
     P addEventFileMember...
     P                 b
     D                 pi
     D  i_file                             const like(evf_objName_t)
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
     D command         s            128a   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         command = 'ADDPFM FILE(' + %trim(i_lib) + '/' + %trim(i_file) + ') +
                      MBR(' + %trim(i_mbr) + ')';

         QCMDEXC(command: %len(command));

         p_rmvPgmMsg(cMsg_Rmv_All);

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Clears the member of the event file.
      *=========================================================================
     P clearEventFileMember...
     P                 b
     D                 pi
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
     D command         s            128a   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         command =
            'CLRPFM FILE(' + %trim(i_lib) + '/' + EVENT_FILE + ') +
                    MBR(' + %trim(i_mbr) + ')';

         QCMDEXC(command: %len(command));

         p_rmvPgmMsg(cMsg_Rmv_All);

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Opens the event file.
      *=========================================================================
     P openEventFile...
     P                 b
     D                 pi                  like(evf_objName_t)
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         g_status.outFile = %trim(i_lib) + '/' + EVENT_FILE;
         g_status.outMbr = %trim(i_mbr);
         open EVFEVENT;

         return g_fileInfo.openFB.lib;

      /end-free
     P                 e
      *
      *=========================================================================
      *  *** private ***
      *  Closes the event file.
      *=========================================================================
     P closeEventFile...
     P                 b
     D                 pi
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (not %open(EVFEVENT));
            return;
         endif;

         close EVFEVENT;
         clear g_status;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Converts a given message severity to the annotation class.
      *=========================================================================
     P getAnnotationClass...
     P                 b
     D                 pi             1a
     D  i_msgSeverity                10i 0 value
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

        select;
        when (i_msgSeverity >= 50);
           return EVF_ANNOTATION_TOP;
        other;
           return EVF_ANNOTATION_MIDDLE;
        endsl;

      /end-free
     P                 e
      *
      *=========================================================================
      *  Converts a given message type to the severity character.
      *  Rules:
      *    n >= 40    -->   Terminating
      *    n >= 30    -->   Severe
      *    n >= 20    -->   Error
      *    n >= 10    -->   Warning
      *    other      -->   Info
      *=========================================================================
     P getSeverityChar...
     P                 b
     D                 pi             1a
     D  i_msgSeverity                10i 0 value
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

        select;
        when (i_msgSeverity >= EVF_MSG_SEVERITY_TERMINATING);
           return EVF_SEVERITY_TERMINATING;
        when (i_msgSeverity >= EVF_MSG_SEVERITY_SEVERE);
           return EVF_SEVERITY_SEVERE;
        when (i_msgSeverity >= EVF_MSG_SEVERITY_ERROR);
           return EVF_SEVERITY_ERROR;
        when (i_msgSeverity >= EVF_MSG_SEVERITY_WARNING);
           return EVF_SEVERITY_WARNING;
        other;
           return EVF_SEVERITY_INFO;
        endsl;

      /end-free
     P                 e
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDINFDS  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDINFDS   "
mbrtype =  "RPGLE     "
mbrtext =  "File information data structure                   "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      /IF DEFINED(fileInfDS_DB)
      /IF DEFINED(infDS_DB_t)
      /EOF
      /ENDIF
      /DEFINE infDS_DB_t
      /ENDIF
      *
      /IF DEFINED(fileInfDS_prtF)
      /IF DEFINED(infDS_prtF_t)
      /EOF
      /ENDIF
      /DEFINE infDS_prtF_t
      /ENDIF
      *
      /IF DEFINED(fileInfDS_dspF)
      /IF DEFINED(infDS_dspF_t)
      /EOF
      /ENDIF
      /DEFINE infDS_dspF_t
      /ENDIF
      *
      *===============================================================*
      *  File information data structure                              *
      *===============================================================*
      /IF DEFINED(fileInfDS_DB)
     D infDS_DB_t      DS                  qualified               based(pDummy)
      /ELSEIF DEFINED(fileInfDS_PRTF)
     D infDS_prtF_t    DS                  qualified               based(pDummy)
      /ELSEIF DEFINED(fileInfDS_DSPF)
     D infDS_dspF_t    DS                  qualified               based(pDummy)
      /ENDIF
      * Reserved 01
     D  reserved_01            1      8A
      * Open indication 1=open
     D  isOpen                 9      9A
      * End of file 1=EOF
     D  isEOF                 10     10A
      * Status
     D  status                11     15S 0
      * Operation code, first 5 pos.
     D  opCode                16     20A
      * IO-Type:
      *   F=The last operation was specified for a file name
      *   R=The last operation was specified for a record
      *   I=The last operation was an implicit file operation.
     D  IO_type               21     21A
      * Routine of operation code
     D  routine               22     29A
      * RPG source listing line nbr
     D  srcSeq                30     37A
      * Record format
     D  rcdFormat             38     45A
      * System message number
     D  sysMsgNbr             46     52A
      * Reserved 02
     D  reserved_02           53     66A
      *
      * Valid after post:
      *    Screen size (product of the number of rows
      *    and the number of columns on the device screen).
     D  screenSize            67     70S 0
      *    The display's keyboard type.
      *       00 = alphanumeric or katakana
      *       10 = ideographic
     D  kbdType               71     72S 0
      *    The display type.
      *       00 = alphanumeric or katakana
      *       10 = ideographic
      *       20 = DBCS
     D  displayType           73     74S 0
      *    Always set to 00.
     D  mode                  75     76S 0
      * Reserved_03
     D  reserved_03           77     80A
      *
      *  -----------------------------------------
      *    Open Feedback            81 - 240
      *  -----------------------------------------
     D  openFB                             likeds(openFeedback_t)
      *
      *  -----------------------------------------
      *    Input/Output Feedback      241 - 366
      *  -----------------------------------------
     D  IO_FB                              likeds(IO_feedback_t )
      *
      *  -----------------------------------------
      *    Device Specific Feedback   367 -
      *  -----------------------------------------
      /IF DEFINED(fileInfDS_DB)
     D  deviceFB_DB...
     D                                     likeds(deviceFeedback_DB_t)
      /ELSEIF DEFINED(fileInfDS_PRTF)
     D  deviceFB_PrtF...
     D                                     likeds(deviceFeedback_PrtF_t)
      /ELSEIF DEFINED(fileInfDS_DSPF)
     D  deviceFB_DspF...
     D                                     likeds(deviceFeedback_DspF_t)
      /ENDIF
      *
      /IF NOT DEFINED(openFeedback_t)
      /DEFINE openFeedback_t
      *  -----------------------------------------
      *    Open Feedback
      *  -----------------------------------------
     D openFeedback_t...
     D                 DS           160    qualified               based(pDummy)
      * DS=Display DB=File SP=Spooled File
     D  ODP_type               1      2A
      * Qualified file name
     D  qFile                              likeds(infds_qFile_t)
      * File name
     D  file                   3     12A
      * Library
     D  lib                   13     22A
      * Spool file name
     D  spoolFile             23     32A
      * Spool file library
     D  spoolLib              33     42A
      * Spool file number
     D  spoolNbr              43     44I 0
      * Record length
     D  maxRcdLength          45     46I 0
      * Key length
     D  maxKeyLength          47     48I 0
      * Member
     D  mbr                   49     58A
      * Reserved
     D  reserved_01           59     62I 0
      * Reserved
     D  reserved_02           63     66I 0
      * File type
      *     1  =  Display
      *     2  =  Printer
      *     4  =  Diskette
      *     5  =  Tape
      *     9  =  Save
      *    10  =  DDM
      *    11  =  ICF
      *    20  =  Inline data
      *    21  =  Database
     D  fileType              67     68I 0
      * Reserved
     D  reserved_03           69     71A
      * Number of lines on a display screen or       (Display, printer)
      * number of lines on a printed page.
     D  rows                  72     73I 0
      * Length of the null field byte map.           (Database)
     D  lenNullFldMap         72     73I 0
      * Number of positions on a display screen or   (Display, printer)
      * number of characters on a printed line.
     D  columns               74     75I 0
      * Length of the null key field byte map.       (Database)
     D  lenKeyFldMap          74     75I 0
      * Number of records in the member at open
      * at open time.
     D numRcdsAtOpen          76     79I 0
      * Access type
     D accessType             80     81A
      * Duplicate key?
     D isDupKey               82     82A
      * Source file?
     D isSrcFile              83     83A
      * Reserved
     D reserved_04            84     93A
      * Reserved
     D reserved_05            94    103A
      * Offset to volume label fields of open
      * feedback area.
     D ofsVolLblFld          104    105I 0
      * Max rcds in blk
     D maxBlkRcds            106    107I 0
      * Overflow line
     D overflow              108    109I 0
      * Blk increment
     D blkInc                110    111I 0
      * Reserved
     D reserved_06           112    115A
      * Miscellaneous flags
     D flags1                116    116A
      * Requester name
     D requester             117    126A
      * Open count
     D openCount             127    128I 0
      * Reserved
     D reserved_07           129    130I 0
      * Num based mbrs
     D numBasedMbrs          131    132I 0
      * Miscellaneous flags
     D flags2                133    133A
      * Open identifier
     D openID                134    135A
      * Max rcd fmt length
     D maxRcdFmtLen          136    137I 0
      * Database CCSID
     D CCSID                 138    139I 0
      * Miscellaneous flags
     D flags3                140    140A
      * Reserved
     D reserved_08           141    146A
      * Num devs defined
     D numDevices            147    148I 0
      * Device name definition list
     D devices               149    160A
      *
     D infds_qFile_t...
     D                 DS                  qualified               based(pDummy)
     D  name                   1     10A
     D  lib                   11     20A
      *
      /ENDIF
      /IF NOT DEFINED(IO_feedback_t)
      /DEFINE IO_feedback_t
      *  -----------------------------------------
      *    Input/Output Feedback
      *  -----------------------------------------
     D IO_feedback_t...
     D                 DS           126    qualified               based(pDummy)
      * Offset to file dependant feedback
     D ofsFileDepFB            1      2I 0
      * Write count
     D writeCount              3      6I 0
      * Read count
     D readCount               7     10I 0
      * Write/read count
     D writeReadCount         11     14I 0
      * Other I/O count
     D otherCount             15     18I 0
      * Reserved
     D reserved_01            19     19A
      * Current operation
      *   hex 01 =  Read or read block or read from invited devices
      *   hex 02 =  Read direct
      *   hex 03 =  Read by key
      *   hex 05 =  Write or write block
      *   hex 06 =  Write-read
      *   hex 07 =  Update
      *   hex 08 =  Delete
      *   hex 09 =  Force-end-of-data
      *   hex 0A =  Force-end-of-volume
      *   hex 0D =  Release record lock
      *   hex 0E =  Change end-of-data
      *   hex 0F =  Put deleted record
      *   hex 11 =  Release device
      *   hex 12 =  Acquire device
     D operation              20     20A
      * Rcd format name
     D IO_rcdFmt              21     30A
      * Device class
     D deviceClass            31     32A
      * Pgm device name
     D IO_pgmDevice           33     42A
      * Rcd len of I/O
     D IO_rcdLength           43     46I 0
      * Reserved
     D reserved_02            47    126A
      *
      /ENDIF
      /IF NOT DEFINED(deviceFeedback_DB_t)
      /DEFINE deviceFeedback_DB_t
      *  -----------------------------------------
      *    Device Specific Feedback of
      *    Database Files.
      *  -----------------------------------------
     D deviceFeedback_DB_t...
     D                 DS                  qualified               based(pDummy)
      * Size of feedback information
     D  size                   1      4I 0
      * Join logical file bits
     D  JFILE_bits             5      8I 0
      * Offset from the beginning of the I/O feedback area
      * for database files to the null key field byte map.
     D  ofsNullKeyFldMap...
     D                         9     10I 0
      * Number of locked records
     D  numLckRcds            11     12I 0
      * Maximum number of fields
     D  maxNumFlds            13     14I 0
      * Offset to the field-mapping error-bit map.
     D  ofsFldMapErrBitMap...
     D                        15     18I 0
      * Current file position indication.
     D                        19     19A
      * Current record deleted indication
     D                        20     20A
      * Number of key fields
     D  nbrOfKeyFlds          21     22I 0
      * Reserved
     D  resreved_1            23     26A
      * Key length
     D  keyLength             27     28I 0
      * Data member number
     D  dtaMbrNum             29     30I 0
      * Relative record number in data member
     D  rcdNbr                31     34U 0
      * Key value                      *
      * Null key field byte map        *
      *
      /ENDIF
      /IF NOT DEFINED(deviceFeedback_PrtF_t)
      /DEFINE deviceFeedback_PrtF_t
      *  -----------------------------------------
      *    Device Specific Feedback of
      *    Printer Files.
      *  -----------------------------------------
     D deviceFeedback_PrtF_t...
     D                 DS                  qualified               based(pDummy)
      * Current line number in a page
     D  curLine                1      2I 0
      * Current page count
     D  curPage                3      6I 0
      * Spooled file bits
     D  splF_bits              7      7A
      * Reserved
     D  reserved_1             8     34A
      * Major return code
     D  majorRtnCode          35     36A
      * Minor return code
     D  minorRtnCode          37     38A
      *
      /ENDIF
      /IF NOT DEFINED(deviceFeedback_DspF_t)
      /DEFINE deviceFeedback_DspF_t
      *  -----------------------------------------
      *    Device Specific Feedback of
      *    Display Files.
      *  -----------------------------------------
     D deviceFeedback_DspF_t...
     D                 DS                  qualified               based(pDummy)
      * Flag bits
     D  flag_bits              1      2A
      * AID byte
     D  aid_byte               3      3A
      * Cursor location (line and position)
     D  cursorPos              4      5U 0
      * Actual data length
     D  dataLength             6      9I 0
      * Relative record number of a subfile record
     D  rrn                   10     11I 0
      * Lowest subfile
     D  rrn_lowest            12     13I 0
      * Total number of records in a subfile
     D  numRcds               14     15I 0
      * Cursor location (line and position) within active window
     D  cursorPosWdw          16     17U 0
      * Reserved
     D  reserved_1            18     34A
      * Major return code
     D  majorRtnCode          35     36A
      * Minor return code
     D  minorRtnCode          37     38A
      * Systems Network Architecture (SNA) sense return code              (ICF only)
     D  snaCode               39     46A
      * Safe indicator                                                    (ICF only)
     D  saveInd               47     47A
      * Reserved
     D  reserved_2            48     48A
      * Request Write (RQSWRT) command from remote system/application     (ICF only)
     D  rqsWrt                49     49A
      * Record format name received from the remote system                (ICF only)
     D  rcdFormat             50     59A
      * Reserved
     D  reserved_3            60     63A
      * Mode name                                                         (ICF only)
     D  mode                  64     71A
      * Reserved
     D  reserved_4            72     80A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing H_SPEC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "H_SPEC    "
mbrtype =  "RPGLE     "
mbrtext =  "H-Specifications                                  "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
      /IF NOT DEFINED(NO_DECEDIT)
     H DECEDIT('0,')
      /ENDIF
     H DATEDIT(*DMY.)
     H DATFMT(*ISO ) TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
     H CCSID(*CHAR: *JOBRUN)
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PEVENTF  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PEVENTF   "
mbrtype =  "RPGLE     "
mbrtext =  "EVFEVENT API - Public Interface                   "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      /IF NOT DEFINED(PEVENTF)
      /DEFINE PEVENTF
      *
      *  Type templates
     D evf_path_t...
     D                 s           5000a   varying     based(pDummy)
     D evf_objName_t...
     D                 s             10a               based(pDummy)
     D evf_output_id_t...
     D                 s              3s 0             based(pDummy)
     D evf_line_class_t...
     D                 s              1a               based(pDummy)
     D evf_source_id_t...
     D                 s              3s 0             based(pDummy)
     D evf_line_t...
     D                 s             10u 0             based(pDummy)
     D evf_temp_flag_t...
     D                 s              1a               based(pDummy)
     D evf_expansion_t...
     D                 s              6s 0             based(pDummy)
     D evf_annot_class_t...
     D                 s              1a               based(pDummy)
     D evf_token_t...
     D                 s              5u 0             based(pDummy)
     D evf_msg_id_t...
     D                 s              7a               based(pDummy)
     D evf_sev_char_t...
     D                 s              1a               based(pDummy)
     D evf_sev_num_t...
     D                 s              5u 0             based(pDummy)
     D evf_msg_text_t...
     D                 s            210a   varying     based(pDummy)
     D evf_length_t...
     D                 s              5u 0             based(pDummy)
      *
      *  Processor Record
     D EVF_LINE_CLASS_EXPANDED_SOURCE...
     D                 c                   '0'
     D EVF_LINE_CLASS_PHYSICAL_SOURCE...
     D                 c                   '1'
      *
      *  File ID Record
     D EVF_TEMPORARY_SOURCE...
     D                 c                   '1'
     D EVF_PERSISTENT_SOURCE...
     D                 c                   '0'
     D EVF_NAME_TYPE_QSYS...
     D                 c                   '0'
     D EVF_NAME_TYPE_PATH...
     D                 c                   '1'
      *
      *  Annotation Classes
     D EVF_ANNOTATION_TOP...
     D                 c                   '0'
     D EVF_ANNOTATION_MIDDLE...
     D                 c                   '1'
     D EVF_ANNOTATION_BOTTOM...
     D                 c                   '2'
      *
      *  Severity Character
     D EVF_SEVERITY_INFO...
     D                 c                   'I'
     D EVF_SEVERITY_WARNING...
     D                 c                   'W'
     D EVF_SEVERITY_ERROR...
     D                 c                   'E'
     D EVF_SEVERITY_SEVERE...
     D                 c                   'S'
     D EVF_SEVERITY_TERMINATING...
     D                 c                   'T'
      *
      *  Message Severity
     D EVF_MSG_SEVERITY_INFO...
     D                 c                   0
     D EVF_MSG_SEVERITY_WARNING...
     D                 c                   10
     D EVF_MSG_SEVERITY_ERROR...
     D                 c                   20
     D EVF_MSG_SEVERITY_SEVERE...
     D                 c                   30
     D EVF_MSG_SEVERITY_TERMINATING...
     D                 c                   40
      *
      *  Opens an event file member. The event file is created, if
      *  it does not yet exist.
     D Eventf_open...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_open+
     D                                     ')
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
     D  o_rtnLib                                 like(evf_objName_t)
     D                                           options(*nopass: *omit)
      *
      *  Opens an event file member for appending records. The event file
      *  is created, if it does not yet exist.
     D Eventf_openAppend...
     D                 pr              n
     D                                     extproc('EVENTF1_+
     D                                     Eventf_openAppend+
     D                                     ')
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
     D  o_rtnLib                                 like(evf_objName_t)
     D                                           options(*nopass: *omit)
      *
      *  Appends a 'PROCESSOR' record to the event file.
     D Eventf_writeProcessor...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_writeProcessor+
     D                                     ')
     D  i_output_id                        const like(evf_output_id_t)
     D                                           options(*nopass: *omit)
     D  i_line_class                       const like(evf_line_class_t)
     D                                           options(*nopass: *omit)
      *
      *  Appends a 'FILEID' record to the event file.
     D Eventf_writeFileID...
     D                 pr                  opdesc
     D                                     extproc('EVENTF1_+
     D                                     Eventf_writeFileID+
     D                                     ')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_path                             const like(evf_path_t)
     D                                           options(*varsize)
     D  i_nameType                    1a   const options(*nopass: *omit)
     D  i_temp_flag                        const like(evf_temp_flag_t)
     D                                           options(*nopass: *omit)
     D  i_line                             const like(evf_line_t)
     D                                           options(*nopass: *omit)
      *
      *  Appends a 'FILEEND' record to the event file.
     D Eventf_writeFileEnd...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_writeFileEnd+
     D                                     ')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_expansion                        const like(evf_expansion_t)
      *
      *  Appends a 'ERROR' record to the event file.
     D Eventf_writeError...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_writeError+
     D                                     ')
     D  i_source_id                        const like(evf_source_id_t)
     D  i_stmt_line                        const like(evf_line_t)
     D  i_msg_id                           const like(evf_msg_id_t)
     D  i_sev_num                          const like(evf_sev_num_t)
     D  i_msg_text                         const like(evf_msg_text_t)
     D  i_sev_char                         const like(evf_sev_char_t)
     D                                           options(*nopass: *omit)
     D  i_annot_class                      const like(evf_annot_class_t)
     D                                           options(*nopass: *omit)
     D  i_start_err_line...
     D                                     const like(evf_line_t)
     D                                           options(*nopass: *omit)
     D  i_end_err_line...
     D                                     const like(evf_line_t)
     D                                           options(*nopass: *omit)
     D  i_token_start...
     D                                     const like(evf_token_t)
     D                                           options(*nopass: *omit)
     D  i_token_end...
     D                                     const like(evf_token_t)
     D                                           options(*nopass: *omit)
      *
      *  Clears an existing event file member.
     D Eventf_clear...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_clear+
     D                                     ')
     D  i_lib                              const like(evf_objName_t)
     D  i_mbr                              const like(evf_objName_t)
      *
      *  Copies the events of a given event file into this event file.
     D Eventf_copyFrom...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_copyFrom+
     D                                     ')
     D  i_fromLib                          const like(evf_objName_t)
     D  i_fromMbr                          const like(evf_objName_t)
      *
      *  Closes an event file member.
     D Eventf_close...
     D                 pr
     D                                     extproc('EVENTF1_+
     D                                     Eventf_close+
     D                                     ')
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QCMDEXC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QCMDEXC   "
mbrtype =  "RPGLE     "
mbrtext =  "Execute Command (QCMDEXC) API                     "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
      *
      *  ... Execute Command (QCMDEXC) API
     D QCMDEXC...
     D                 PR                  extpgm('QCMDEXC')
     D  i_cmd                     32702A   const  options(*varsize)
     D  i_length                     15P 5 const
     D  i_IGCprcCtrl                  3A   const  options(*nopass)
      *
     D QCMDEXC_IGC     C                   'IGC'
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QP0LCVTPAT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QP0LCVTPAT"
mbrtype =  "RPGLE     "
mbrtext =  "Qp0lCvtPathToQSYSObjName()--Resolve Path          "
srcfile =  "QEVENTF   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "01141">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(Qp0lCvtPathToQSYSObjName)
 DEF  /DEFINE Qp0lCvtPathToQSYSObjName
      *
      *  Qp0lCvtPathToQSYSObjName()--Resolve Integrated File System Path Name
      *                              into QSYS Object Name
     D Qp0lCvtPathToQSYSObjName...
     D                 PR            10I 0 extproc('Qp0lCvtPathToQSYSObjName')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
     D  o_qsys_info               65535A          options(*varsize)
     D  i_format                      8A   const
     D  i_bytPrv                     10I 0 value
     D  i_ccsid                      10I 0 value
     D  io_errCode                65535A          options(*varsize)
      *
     D qsys0100_t      DS                  qualified based(pDummy)
     D  bytRet                 1      4i 0
     D  bytAvl                 5      8i 0
     D  ccsid                  9     12i 0
     D  lib_name              13     40a
     D  lib_type              41     60a
     D  obj_name              61     88a
     D  obj_type              89    108a
     D  mbr_name             109    136a
     D  mbr_type             137    156a
     D  asp_name             157    184a
      *
      /if not defined(Qlg_Path_Name)
      /define Qlg_Path_Name
     D Qlg_Path_Name_t...
     D                 DS                  qualified align         based(pDummy)
     D   CCSID                       10I 0
     D   Country_ID                   2A
     D   Language_ID                  3A
     D   Reserved                     3A
     D   Path_Type                   10U 0
     D   Path_Length                 10I 0
     D   Path_Name_Delimiter...
     D                                2A
     D   Reserved2                   10A
     D   Path_Name                  256A
      *
     D QLG_PATH_JOB_CCSID...
     D                 C                   0
     D QLG_PATH_JOB_COUNTRYID...
     D                 C                   x'0000'
     D QLG_PATH_JOB_LANGUAGEID...
     D                 C                   x'000000'
      *
      *  The Path_Name is a character string and the delimiter is one byte long.
     D QLG_CHAR_SINGLE...
     D                 C                   0
      *
      *  The Path_Name is a pointer and the delimiter is one byte long.
     D QLG_PTR_SINGLE...
     D                 C                   1
      *
      *  The Path_Name is a character string and the delimiter is two bytes long.
     D QLG_CHAR_DOUBLE...
     D                 C                   2
      *
      *  The Path_Name is a pointer and the delimiter is two bytes long.
     D QLG_PTR_DOUBLE...
     D                 C                   3
      *
      /endif
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="A_INSTALL"><![CDATA[
CRTBNDCL PGM(&tolib/A_INSTALL) SRCFILE(&tolib/&SRCFILE) SRCMBR(*PGM) DFTACTGRP(*NO) ACTGRP(*NEW) DBG
VIEW(*LIST)
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
CALL PGM(&tolib/A_INSTALL) PARM('&TGTRLS' '&SRCFILE' '&tolib' '&CRTTSTPGM')
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
DLTPGM PGM(&tolib/A_INSTALL)
]]>  </qcmdexc>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*COMP     "><![CDATA[
Application EVENTF successfully installed.
]]>  </sendmsg>
</upload>
