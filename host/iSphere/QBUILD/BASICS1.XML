<?xml version="1.0" encoding="ISO-8859-1"?>
     <!-- Embedded DTD for validation -->
     <!DOCTYPE upload [
     <!ELEMENT compile (#PCDATA)>
     <!ATTLIST compile
      condition CDATA #REQUIRED
     >
     <!ELEMENT copysrc (#PCDATA)>
     <!ELEMENT install_instructions (#PCDATA)>
     <!ELEMENT install_program (#PCDATA)>
     <!ELEMENT mbr (copysrc)>
     <!ATTLIST mbr
      mbrname CDATA #REQUIRED
      mbrtype CDATA #REQUIRED
      mbrtext CDATA #REQUIRED
      srcfile CDATA #REQUIRED
      srclib CDATA #REQUIRED
      srclen CDATA #REQUIRED
      srccssid CDATA #REQUIRED
     >
     <!ELEMENT qcmdexc (#PCDATA)>
     <!ATTLIST qcmdexc
      condition CDATA #REQUIRED
      release CDATA #REQUIRED
      dltsplf CDATA #REQUIRED
     >
     <!ELEMENT qrycond (#PCDATA)>
     <!ATTLIST qrycond
      msg CDATA #REQUIRED
      values CDATA #REQUIRED
      var CDATA #REQUIRED
     >
     <!ELEMENT sendmsg (#PCDATA)>
     <!ATTLIST sendmsg
      sendmsgid CDATA #REQUIRED
      sendmsgtype CDATA #REQUIRED
     >
     <!ELEMENT rtvobjd (#PCDATA)>
     <!ATTLIST rtvobjd
      condition CDATA #REQUIRED
      obj CDATA #REQUIRED
      lib CDATA #REQUIRED
      objtype CDATA #REQUIRED
      rtnlib CDATA #IMPLIED
     >
     <!ELEMENT upload (install_instructions | install_program | qrycond |
                       qcmdexc | sendmsg | mbr | compile | rtvobjd | chgvar)+>
     <!ATTLIST upload
      appname CDATA #REQUIRED
      appauthor CDATA #REQUIRED
      appblddate CDATA #REQUIRED
     >
     ]>
<upload  appname="BASICS1"  appauthor="Thomas Raddatz"  appblddate=" 2/13/2017">
<install_instructions><![CDATA[
     *----------------------------------------------------------------      ------
     *  1. Upload entire XML to your AS/400 to a source file 112 long, into any mbr
     *     name not in this XML (suggest member name like ABCX or XYZX). The source
     *     file must be in the library where source and objects are to be installed.
     *
     *  2. If you have XMLPREVIEW installed, skip to step 3.
     *
     *     Copy the text between the start tag <install_program> and the end
     *     tag </install_program> into any member name (your choice)
     *     in file QRPGLESRC member type RPGLE.   CRTBNDRPG to compile.
     *     NOTE: You need extract the install program only once, this same program
     *           will install any upload on this page.
     *
     *  3. Call the install program (or execute XmlPrevew) passing these 3 parms.
     *       'your-member-name you uploaded this text into'
     *       'your-source-file-name the member is in'
     *       'your-library-name the source file is in'
     *
     *  The various source members will be extracted and the objects required
     *   for the application will be created in your-library-name.
     *----------------------------------------------------------------      ------
]]>  </install_instructions>
<install_program><![CDATA[
      * /// START OF INSTALL PGM HERE   ************************** ///
      *---------------------------------------------------------------------------------------
      * Parse / Install from xml text into source members and objects.
      * Copyright (C) 2001    Craig Rutledge    <craig_rutledge@mohawkind.com>
      * Martin Rowe    <Martin@dbg400.net>          scripting cmd prompts
      * David George   <webmaster@400times.co.uk>   intellectual input
      * Thomas Raddatz <thomas.raddatz@tools400.de> execute SQL statements
      * Thomas Raddatz <thomas.raddatz@tools400.de> conditions
      * Thomas Raddatz <thomas.raddatz@tools400.de> release
      * Thomas Raddatz <thomas.raddatz@tools400.de> retrieve object description
      *
      * Use xml tags in text to trigger:
      * 1. Parse text into source members (create srcfile & member if required).
      * 2. Compile source into objects.
      * 3. Send installation progress user messages.
      * 4. Execute qcmdexc as required.
      * 5. Execute SQL statements as required.
      *
      * This program is free software, you can redistribute it and/or modify it
      * under the terms of the GNU General Public License as published by
      * the Free Software Foundation.  See GNU General Public License for details
      *---------------------------------------------------------------------------------------
      * >>PRE-COMPILER<<
      *   >>CRTCMD<< CRTBNDRPG    PGM(&LI/&OB) SRCFILE(&SL/&SF) SRCMBR(*PGM) +
      *                           DBGVIEW(*LIST) OPTION(*EVENTF);
      *   >>EXECUTE<<
      * >>END-PRE-COMPILER<<
      *---------------------------------------------------------------------------------------
     H DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('QC2LE')
      *---------------------------------------------------------------------------------------
     Fxmlinput  if   f  112        disk    usropn                               uploaded text
     Fqxxxsrc   o    f  112        disk    usropn                               parsed out
      *--------------------------------------------------------------------
      * create parm prototypes
      *--------------------------------------------------------------------
      *  Tokenize String
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_token                        *   value  options(*string)
      * retrieve member description
     D qusrmbrd        PR                  ExtPgm('QUSRMBRD')                   MEMBER DESCRIPTION
     D  o_rcvVar                  32767a          options(*varsize)             RECEIVER
     D  i_lenRcvVar                  10i 0 const                                LENGTH OF RECVR
     D  i_format                      8    const                                UPLOAD TYPE
     D  i_qFile                      20    const                                FILE   LIB
     D  i_mbr                        10    const                                MEMBER NAME
     D  i_ovverride                   1    const                                PROCESS OVERIDE
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * retrieve object description
     D QUSROBJD...
     D                 PR                         extpgm('QUSROBJD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_type                       10A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    | OptGrp 1
      * send program message
     D qmhsndpm        PR                  ExtPgm('QMHSNDPM')                   SEND MESSAGES
     D  i_msgID                       7a   const                                ID
     D  i_qMsgF                      20a   const                                FILE
     D  i_msgText                 32767a   const  options(*varsize)             TEXT
     D  i_lenMsgText                 10i 0 const                                LENGTH
     D  i_msgType                    10a   const                                TYPE
     D  i_callStackE                 10a   const                                STACK ENTRY
     D  i_callStackC                 10i 0 const                                STACK COUNTER
     D  i_msgKey                      4a   const                                KEY
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * execute cl command
     D  qcmdexc        PR                  ExtPgm('QCMDEXC')
     D  i_cmd                        50a   Const
     D  i_lenCmd                     15p 5 Const
      *  Allocate Environment Handle
     D SQLAllocEnv...
     D                 PR                         extproc('SQLAllocEnv')
     D                                     like(SQLRETURN_t )
     D  o_phenv                        *   value
      *  Allocate Connection Handle
     D SQLAllocConnect...
     D                 PR                         extproc('SQLAllocConnect')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
     D  o_phdbc                        *   value
      *  Connect to a Data Source
     D SQLConnect...
     D                 PR                         extproc('SQLConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_szDSN                        *   value  options(*string)
     D  i_cbDSN                            value  like(SQLSMALLINT_t)
     D  i_szUID                        *   value  options(*string)
     D  i_cbUID                            value  like(SQLSMALLINT_t)
     D  i_szAuthStr                    *   value  options(*string)
     D  i_cbAuthStr                        value  like(SQLSMALLINT_t)
      *  Set Connection Option
     D SQLSetConnectOption...
     D                 PR                         extproc('SQLSetConnectOption')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_fOption                          value  like(SQLSMALLINT_t)
     D  i_vParam                           value  like(SQLPOINTER_t )
      *  Allocate a Statement Handle
     D SQLAllocStmt...
     D                 PR                         extproc('SQLAllocStmt')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  o_phstmt                       *   value
      *  Execute a Statement Directly
     D SQLExecDirect...
     D                 PR                         extproc('SQLExecDirect')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_szSqlStr                     *   value  options(*string)
     D  i_cbSqlStr                         value  like(SQLINTEGER_t)
      *  Free (or Reset) a Statement Handle
     D SQLFreeStmt...
     D                 PR                         extproc('SQLFreeStmt')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_fOption                          value  like(SQLSMALLINT_t)
      *  Disconnect from a Data Source
     D SQLDisconnect...
     D                 PR                         extproc('SQLDisconnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Connection Handle
     D SQLFreeConnect...
     D                 PR                         extproc('SQLFreeConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Environment Handle
     D SQLFreeEnv...
     D                 PR                         extproc('SQLFreeEnv')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
      *--------------------------------------------------------------------
     D long_t          S             10I 0                    based(pDummy)
     D short_t         S              5I 0                    based(pDummy)
      *
     D SQLINTEGER_t    S                   like(long_t      ) based(pDummy)
     D SQLSMALLINT_t   S                   like(short_t     ) based(pDummy)
      *
     D PTR_t           S               *                      based(pDummy)
     D SQLPOINTER_t    S                   like(PTR_t       ) based(pDummy)
     D HENV_t          S                   like(long_t      ) based(pDummy)
     D HDBC_t          S                   like(long_t      ) based(pDummy)
     D HSTMT_t         S                   like(long_t      ) based(pDummy)
     D RETCODE_t       S                   like(SQLINTEGER_t) based(pDummy)
      *
     D SQLHENV_t       S                   like(HENV_t      ) based(pDummy)
     D SQLHDBC_t       S                   like(HDBC_t      ) based(pDummy)
     D SQLHSTMT_t      S                   like(HSTMT_t     ) based(pDummy)
     D SQLRETURN_t     S                   like(RETCODE_t   ) based(pDummy)
      *
     D retCode         S                   like(SQLRETURN_t) inz
     D hdbc            S                   like(SQLHDBC_t  ) inz
     D hstmt           S                   like(SQLHSTMT_t ) inz
     D henv            S                   like(SQLHENV_t  ) inz
     D sqlInit         S              1A                     inz(*off)
     D cOptVal         S             10I 0                   inz
      *
     D SQL_NTS         C                   const( -3)
     D SQL_COMMIT_NONE...
     D                 C                   const(  1)
     D SQL_ATTR_COMMIT...
     D                 C                   const(  0)
     D SQL_DROP        C                   const(  1)
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     D readElement     PR                        like(bldexc)
     D  i_element                     9A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to double quotes in a string
      *--------------------------------------------------------------------
     D dblQuotes       PR          2048A         varying
     D  i_string                   2048A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to get attribute data from a string
      *--------------------------------------------------------------------
     D getAttrData...
     D                 PR          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *--------------------------------------------------------------------
      * Define function prototype to check for a condition
      *--------------------------------------------------------------------
     D isCondition...
     D                 PR              n
     D  i_condList                 2000A   value
      *---------------------------------------------------------------------------------------
     D loadConditions...
     D                 PR                  dim(32) like(condition)
     D  i_conditions                128A   value
      *--------------------------------------------------------------------
     D getCurrentRelease...
     D                 PR            10A
      *--------------------------------------------------------------------
     D isRelease...
     D                 PR              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *--------------------------------------------------------------------
     D setTargetRelease...
     D                 PR          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *--------------------------------------------------------------------
     D setVariable...
     D                 PR
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
      *---------------------------------------------------------------------------------------------
     D getVarName...
     D                 PR            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
      *---------------------------------------------------------------------------------------------
     D getVarValue...
     D                 PR            64a          varying
     D  i_name                       11a   value  varying
      *---------------------------------------------------------------------------------------------
     D uCase...
     D                 PR          2000A          varying
     D  i_string                   2000A   value  varying
      *--------------------------------------------------------------------
     D vrcvar          s            145
     D qm_msgid        s              7
     D qm_msgtxt       s            500
     D qm_msgq         s             10
     D qm_msgtyp       s             10
     D mbrname         s             10
     D mbrtype         s             10
     D mbrtext         s             50
     D srcfile         s             10
     D srclen          s              5
     D srclenN         s              5  0   inz(0)
     D srccssid        s              5
     D bldexc          s           2000
     D write_flag      s              1n   inz(*off)
     D srcSeqno        s              6s 2 inz(0)
     D aa              s              5u 0 inz(0)
     D ll              s              5u 0 inz(0)
     D qs              c                   ''''
     D qd              c                   '"'
     D errFLag         s              1    inz(*off)
     D cnd_msg         s             42
     D cnd_values      s            110
     D cnd_var         s             10
     D cnd_rtnVal      s             10
     D cnd_array       s                   dim(32) inz like(condition)
     D cnd_ptr         s             10i 0 inz
     D condition       s             10a
     D condList        s           2000a
     D release         s             10a
     D dltsplf         s             10a
     D objd_obj        s             10a
     D objd_lib        s             10a
     D objd_objtype    s             10a
     D objd_rtnlib     s             10a
     D objd0100        ds
     D  od_bytRet              1      4i 0
     D  od_bytAvl              5      8i 0
     D  od_name                9     18a
     D  od_lib                19     28a
     D  od_type               29     38a
     D  od_rtnLib             39     48a
     D fld_array       ds
     D  fld_x                        10i 0 inz
     D  fld_name                     11a   inz dim(64) varying
     D  fld_value                    64a   inz dim(64) varying
     D var_name        s             11a   inz varying
     D var_value       s             64a   inz varying
      * Error return code parm for APIs.
     D errCode         DS
     D  errCode_bytPrv...
     D                               10i 0 inz(%size(errCode))
     D  errCode_bytAvl...
     D                               10i 0 inz(0)
     D  errCode_excID...
     D                                7a   inz
     D  errCode_reserved...
     D                                1a   inz
     D  errCode_escData...
     D                              256a   inz
      * Optional parameters
     D OvrSrcFile      s                   like(i_OvrSrcFile) inz
     D isPreDefCond    s               N   inz(*off)
     D TgtRls          s                   like(i_TgtRls    ) inz
      *
      * Program status data structure.
     D sds            sds
     D  sds_pgmName                  10A
     D  sds_status                    5S 0
     D  sds_prvStat                   5S 0
     D  sds_lastSeq                   8A
     D  sds_lastSubR                  8A
     D  sds_numParm                   3S 0
     D  sds_msgID                     7A
     D  sds_MiInstr                   4A
     D  sds_wrkArea                  30A
     D  sds_lib                      10A
     D  sds_msgText                  80A
      *--------------------------------------------------------------------
     Ixmlinput  ns
     I                                 13   21  xmltag1
     I                                 18   27  xmltag2
     I                                 13  112  xmlcode
      *--------------------------------------------------------------------
     C     *entry        plist
     C                   parm                    ParseSrcMbr      10            source member
     C                   parm                    ParseSrcFile     10            source file
     C                   parm                    ParseSrcLib      10            source lib
      *  optional parameters:
     C                   parm                    i_OvrSrcFile     10            override to src
     C                   parm                    i_Conditions    128            pre-def conditions
     C                   parm                    i_TgtRls         10            target release
      *
      *  get optional parameter: Overrride to Source File
     C                   if        %parms() >= 4
     C                   eval      OvrSrcFile = i_OvrSrcFile
     C                   else
     C                   eval      OvrSrcFile = ''
     C                   endif
      *
      *  get optional parameter: Conditions
     C                   if        %parms() >= 5
     C                   if        %subst(i_Conditions:1:32) <> ''
     C                   eval      cnd_array = loadConditions(i_Conditions)
     C                   eval      isPreDefCond = *on
     C                   else
     C                   eval      isPreDefCond = *off
     C                   endif
     C                   endif
      *
      *  get optional parameter: Target Release
     C                   if        %parms() >= 6
     C                   eval      TgtRls = i_TgtRls
     C                   else
     C                   eval      TgtRls = getCurrentRelease()
     C                   endif
      *
     C                   exsr      srValidate                                   make sure exist
      *
      * Set user selected library *first for remainder of program
     C                   eval      bldexc = 'RMVLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
     C                   eval      bldexc = 'ADDLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ') POSITION(*FIRST)'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
      *       CPF2103 - Library &1 already exists in library list.
     C                   if        %error and sds_msgID <> 'CPF2103'
     C                   eval      qm_msgtxt = '0000 ' + sds_msgText
     C                   exsr      srKill
     C                   endif
      *
      * Set variable &TOLIB
     C                   callp     setVariable('tolib': ParseSrcLib)
      *
      * Set variable &TGTRLS
     C                   callp     setVariable('tgtrls': TgtRls)
      *
      * Override Input file to uploaded text file
     C                   eval      bldexc = 'OVRDBF FILE(XMLINPUT) TOFILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(ParseSrcFile) + ') MBR(' +
     C                             %trimr(ParseSrcMbr) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   open      xmlinput
     C                   read      xmlinput
     C                   dow       not %eof
      * write records to outfile if flag is on
     C                   select
     C                   when      write_flag = *on
     C                   if        xmltag2<>'</copysrc>'
     C                   eval      srcSeqno=srcSeqno+1
     C                   except    write_one
     C                   else
     C                   eval      write_flag=*off
     C                   close     qxxxsrc
     C                   endif
      *
      * Extract values based on xml tags.
     C                   when      xmltag1 = 'mbrname ='
     C                   eval      mbrname = %subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtype ='
     C                   eval      mbrtype =%subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtext ='
     C                   eval      mbrtext =dblQuotes(%subst(xmlcode:13:50))
     C                   when      xmltag1 = 'srcfile ='
     C                   if        OvrSrcFile <> ''
     C                   eval      srcfile =OvrSrcFile
     C                   else
     C                   eval      srcfile =%subst(xmlcode:13:10)
     C                   endif
     C                   when      xmltag1 = 'srclen  ='
     C                   eval      srclen  =%subst(xmlcode:13:5)
     C                   when      xmltag1 = 'srccssid='
     C                   eval      srccssid=%subst(xmlcode:13:5)
      *--------------------------------------------------------------------
      * Start of data to copy.  Create source files/mbrs as required.
      *--------------------------------------------------------------------
     C                   when      xmltag1='<copysrc>'
     C                   move      srclen        srclenN
      * crtsrcpf
     C                   eval      bldexc = 'CRTSRCPF FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') RCDLEN(' +
     C                             srclen + ') CCSID(' +
     C                             srccssid + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      * addpfm
     C                   eval      bldexc = 'ADDPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') SRCTYPE(' +
     C                             %trimr(mbrtype) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error
      * chgpfm
     C                   eval      bldexc = 'CHGPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
      * clr mbr
     C                   eval      bldexc = 'CLRPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      * ovr to outfile mbr
     C                   eval      bldexc = 'OVRDBF QXXXSRC ' +
     C                             %trimr(ParseSrcLib) + '/' +
     C                             %trimr(srcfile) + ' ' +
     C                             mbrname
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   clear                   srcSeqno
     C                   open      qxxxsrc
     C                   eval      write_flag = *on
      *--------------------------------------------------------------------
      * Compile statement.  Read next record and execute it.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<compile '
     C                   eval      condList= getAttrData('condition':xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('compile')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      *--------------------------------------------------------------------
      * qcmdexc statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qcmdexc '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      release  = getAttrData('release'
     C                                                    :xmlcode:'*CURRENT')
     C                   eval      dltsplf  = getAttrData('dltsplf'
     C                                                    :xmlcode:'*NONE')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('qcmdexc')
     C                   if        isCondition(condList) and
     C                             isRelease(tgtRls: release)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   if        %subst(bldexc: 1: 3) = 'DLT'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   else
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error()
     C                   eval      qm_msgtxt = '0000 Failed to execute: '+bldexc
     C                   exsr      srKill
     C                   endif
     C                   if        dltsplf <> '' and dltsplf <> '*NONE'
     C                   eval      bldexc = 'DLTSPLF FILE(' + dltsplf +
     C                                      ') JOB(*) SPLNBR(*LAST)'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
     C                   endif
     C                   endif
      *--------------------------------------------------------------------
      * SQL statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute SQL statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<execsql '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('execsql')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      srSQLExecute
     C                   endif
      *--------------------------------------------------------------------
      * Send messages to user as program executes
      * Extract message ID, Message Type, from <sendmsg>
      * read a record and get the single line of message text.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<sendmsg '
     C                   eval      qm_msgid = %subst(xmlcode:22:7)
     C                   eval      qm_msgtyp = %subst(xmlcode:46:10)
     C                   read      xmlinput
     C                   eval      qm_msgq   = '*EXT   '
     C                   eval      qm_msgtxt = xmlcode
     C                   exsr      srSndMessage
      *--------------------------------------------------------------------
      * rtvobjd statement. retrieve object description of the specified
      * object. Store attributes in specified fields.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<rtvobjd '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('rtvobjd')
     C                   eval      objd_obj    =getAttrData('obj'    :bldexc:'')
     C                   eval      objd_lib    =getAttrData('lib'    :bldexc:'')
     C                   eval      objd_objtype=getAttrData('objtype':bldexc:'')
     C                   eval      objd_rtnlib =getAttrData('rtnlib' :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srRtvObjD
     C                   endif
      *--------------------------------------------------------------------
      * chgvar statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<chgvar  '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('chgvar')
     C                   eval      var_name  = getAttrData('var'    :bldexc:'')
     C                   eval      var_value = getAttrData('value'  :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srChgVar
     C                   endif
      *--------------------------------------------------------------------
      * Query condition
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qrycond '
     C                   eval      bldexc = readElement('qrycond')
     C                   eval      cnd_msg = getAttrData('msg'   : bldexc: '')
     C                   eval      cnd_values = getAttrData('values': bldexc:'')
     C                   eval      cnd_var = getAttrData('var': bldexc: '*NONE')
     C                   exsr      srQueryCond
     C                   endsl
      *
     C                   read      xmlinput
     C                   enddo
      *
     C                   exsr      srSQLEnd
     C                   eval      *inlr=*on
     C                   return
      *--------------------------------------------------------------------
      * Replace variable names with their associated values.
      *--------------------------------------------------------------------
     C     RplVars       begsr
     C                   eval      aa=%scan('&':bldexc)
     C                   dow       aa>0
     C                   eval      var_name=getVarName(bldexc:aa)
     C                   eval      var_value=getVarValue(var_name)
     C                   eval      bldexc=%replace(var_value:bldexc:aa
     C                                             :%len(var_name))
     C                   eval      aa=%scan('&':bldexc)
     C                   enddo
     C                   endsr
      *--------------------------------------------------------------------
      * Sets the target release according to the optional parameter
      * i_TgtRls.
      *--------------------------------------------------------------------
     C     SetTgtRls     begsr
     C                   if        TgtRls = getCurrentRelease()
     C                   leavesr
     C                   endif
     C                   eval      bldexc =
     C                                setTargetRelease('TGTRLS': bldexc: TgtRls)
     C                   endsr
      *--------------------------------------------------------------------
      * Check of file, lib, member exist.
      *--------------------------------------------------------------------
     C     srValidate    begsr
     C                   callp     QUSRMBRD(
     C                             vrcvar:
     C                             145:
     C                             'MBRD0100':
     C                             ParseSrcFile + ParseSrcLib:
     C                             ParseSrcMbr:
     C                             '0':
     C                             errCode)
      *   --------------------------------------------------------------------------------
      *   If error occurred on call, send appropriate message back to user.
      *   ---------------------------------------------------------------------------------
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   select
      * lib not found
     C                   when      errCode_excID = 'CPF9810'
     C                   eval      qm_msgtxt = '0000 Library ' +
     C                             %trimr(ParseSrcLib) + ' was not found.'
      * src file not found
     C                   when      errCode_excID = 'CPF9812'
     C                   eval      qm_msgtxt = '0000 Source file ' +
     C                             %trimr(ParseSrcFile)+' was not found in ' +
     C                             %trimr(ParseSrcLib) + '.'
      * member not found
     C                   when      errCode_excID = 'CPF9815'
     C                   eval      qm_msgtxt = '0000 Member ' +
     C                             %trimr(ParseSrcMbr)+' was not found in ' +
     C                             %trimr(ParseSrcLib)+'/'+ %trimr(ParseSrcFile)
      * unexpected
     C                   other
     C                   eval      qm_msgtxt = '0000 Unexpected message ' +
     C                             errCode_excID + ' received. '
     C                   endsl
      * send message
     C                   exsr      srKill
     C                   eval      *inlr=*on
     C                   return
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * kill application
      *--------------------------------------------------------------------
     C     srKill        begsr
     C                   eval      qm_msgid  = 'CPD0006'
     C                   eval      qm_msgtyp = '*DIAG'
     C                   eval      qm_msgq   = '*CTLBDY'
     C                   exsr      srSndMessage
     C                   eval      qm_msgtxt = *blanks
     C                   eval      qm_msgid  = 'CPF0002'
     C                   eval      qm_msgtyp = '*ESCAPE'
     C                   exsr      srSndMessage
     C                   endsr
      *--------------------------------------------------------------------
      * call send program message api
      *--------------------------------------------------------------------
     C     srSndMessage  begsr
     C                   callp     QMHSNDPM(
     C                             qm_msgid:
     C                             'QCPFMSG   *LIBL     ':
     C                             qm_msgtxt:
     C                             %size(qm_msgtxt):
     C                             qm_msgtyp:
     C                             qm_msgq:
     C                             1:
     C                             '    ':
     C                             errCode)
     C                   endsr
      *--------------------------------------------------------------------
      * retrieve object description and store attributes
      *--------------------------------------------------------------------
     C     srRtvObjD     begsr
     C                   callp     QUSROBJD(objd0100
     C                                      : %size(objd0100)
     C                                      : 'OBJD0100'
     C                                      : objd_obj + objd_lib
     C                                      : objd_objtype
     C                                      : errCode)
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   eval      qm_msgtxt = '0000 Failed to retrieve +
     C                             object description of object ' +
     C                             %trim(objd_lib) + '/' + %trim(objd_obj) +
     C                             ' type ' + %trim(objd_objtype) + '.'
      * send message
     C                   exsr      srKill
     C                   else
     C                   callp     setVariable(objd_rtnlib: od_rtnlib)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * change variable
      *--------------------------------------------------------------------
     C     srChgVar      begsr
     C                   callp     setVariable(var_name: var_value)
     C                   endsr
      *--------------------------------------------------------------------
      * execute SQL statement.
      *--------------------------------------------------------------------
     C     srSQLExecute  begsr
     C                   exsr      srSQLInit
     C                   Eval      retCode = SQLExecDirect(hstmt    :
     C                                                     bldexc   :
     C                                                     SQL_NTS  )
     C                   endsr
      *--------------------------------------------------------------------
      * query condition.
      *--------------------------------------------------------------------
     C     srQueryCond   begsr
     C                   if        isPreDefCond = *off
     C                   eval      cnd_values = uCase(cnd_values)
     C                   dou       (%scan(cnd_rtnVal: cnd_values) > 0) and
     C                             (cnd_rtnval <> ''                 )
     C                   eval      cnd_rtnval = ' '
     C     cnd_msg       dsply                   cnd_rtnval
     C                   eval      cnd_rtnVal = uCase(cnd_rtnVal)
     C                   enddo
     C                   eval      cnd_ptr = cnd_ptr + 1
     C                   eval      cnd_array(cnd_ptr) = cnd_rtnVal
     C                   endif
     C                   if        (cnd_var <> '*NONE')
     C                   callp     setVariable(cnd_var: cnd_rtnval)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * initialize SQL.
      *--------------------------------------------------------------------
     C     srSQLInit     begsr
      *
     C                   if        sqlInit = *off
     C                   Eval      retCode = SQLAllocEnv(%addr(henv))
     C                   Eval      retCode = SQLAllocConnect(henv: %addr(hdbc))
     C                   Eval      retCode = SQLConnect(hdbc      :
     C                                                  '*LOCAL'  :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   )
     C                   Eval      cOptVal = SQL_COMMIT_NONE
     C                   Eval      retCode = SQLSetConnectOption(hdbc          :
     C                                                          SQL_ATTR_COMMIT:
     C                                                          %addr(cOptVal) )
     C                   Eval      retCode = SQLAllocStmt(hdbc       :
     C                                                  %addr(hstmt) )
     C                   eval      sqlInit = *on
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * end SQL.
      *--------------------------------------------------------------------
     C     srSQLEnd      begsr
     C                   if        sqlInit = *on
     C                   Eval      retCode = SQLFreeStmt(hstmt    :
     C                                                   SQL_DROP )
     C                   Eval      retCode = SQLDisconnect(hdbc)
     C                   Eval      retCode = SQLFreeConnect(hdbc)
     C                   Eval      retCode = SQLFreeEnv(henv)
     C                   eval      sqlInit = *off
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * error handler
      *--------------------------------------------------------------------
     C     *pssr         begsr
     C                   if        errFLag = *off
     C                   eval      errFlag = *on
     C                   exsr      srSQLEnd
     C                   endif
     C                   endsr     '*CANCL'
     Oqxxxsrc   e            write_one
     O                       srcSeqno             6
     O                                           12 '000000'
     O                       xmlcode            112
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     P readElement...
     P                 B
      *
     D readElement     PI                        like(bldexc)
     D  i_element                     9A   value varying
      *
     D i               S             10I 0 inz
     D value           S                   like(bldexc ) inz
     D endTag          S                   like(xmlTag2) inz
      *
     C                   eval      i = 1
     C                   eval      endTag = '</' + i_element + '>'
     C                   dow       xmltag2 <> endTag
     C                   eval      %subst(value: i: %len(xmlcode)) = xmlcode
     C                   eval      i = i + %len(xmlcode)
     C                   read      xmlinput
     C                   enddo
      *
     C                   Return    value
      *
     P readElement...
     P                 E
      *--------------------------------------------------------------------
      * Double quotes
      *--------------------------------------------------------------------
     P dblQuotes...
     P                 B
      *
     D dblQuotes       PI          2048A         varying
     D  i_string                   2048A   value varying
      *
     D x               S             10I 0         inz
     D string          S           2048A   varying inz
      *
     C                   For       x = 1 to %len(i_string)
     C                   Eval      string = string + %subst(i_string: x:1)
     C                   If        %subst(i_string: x : 1) = qs
     C                   Eval      string = string + qs
     C                   Endif
     C                   Endfor
      *
     C                   Return    string
      *
     P dblQuotes...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get Attribute Data from String
      *---------------------------------------------------------------------------------------------
     P getAttrData...
     P                 B
      *
     D getAttrData...
     D                 PI          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *
      *  return value
     D attrData        S           2000A   varying inz                          like(string_t)
      *
      *  local fields
     D attr            S             20a   varying inz
     D lenAttr         S             10i 0 inz
     D aa              S             10i 0 inz
     D cc              S             10i 0 inz
      *
     D Qd              C                   const('"')
      *-------------------------------------------------------------------*
      *
      *  find the keyword
     C                   eval      attr = %trim(i_attr) + '=' + Qd
      *
     C                   eval      aa   = %scan(attr: i_string)
     C                   if        aa = 0
     C                   return    i_default
     C                   endif
      *
     C                   eval      aa   = aa + %len(attr)
     C                   eval      cc   = %scan(Qd: i_string: aa+1)
      *
      *  return the data between the double-quotes
     C                   if        (cc-aa) > 0
     C                   eval      attrData = %subst(i_string: aa: cc-aa)
     C                   endif
      *
     C                   Return    attrData
      *
     P getAttrData...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Load condition array
      *---------------------------------------------------------------------------------------------
     P loadConditions...
     P                 B
      *
     D loadConditions...
     D                 PI                  dim(32) like(condition)
     D  i_conditions                128A   value
      *
      *  return value
     D cnd_array       s                   dim(32) inz like(condition)
     D pValue          s               *   inz
     D x               s             10i 0 inz
      *-------------------------------------------------------------------*
     C                   eval      i_conditions = uCase(i_conditions)
      *
     C                   eval      pValue = strtok(i_conditions: ';')
     C                   dow       pValue <> *null
     C                   eval      x = x + 1
     C                   eval      cnd_array(x) = %str(pValue)
     C                   eval      pValue = strtok(*null: ';')
     C                   enddo
      *
     C                   Return    cnd_array
     P loadConditions...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check for a condition
      *---------------------------------------------------------------------------------------------
     P isCondition...
     P                 B
      *
     D isCondition...
     D                 PI              n
     D  i_condList                 2000A   value
      *
      *  return value
     D isCondition     S               n   inz
     D pValue          S               *   inz
     D aCondition      S             10a   inz
      *-------------------------------------------------------------------*
     C                   eval      i_condList = uCase(i_condList)
      *
     C                   if        (i_condList = '*NONE')  or
     C                             (i_condList = ''     )
     C                   eval      *in01 = *on
     C                   else
      *
     C                   eval      pValue = strtok(i_condList: ' ')
     C                   dow       pValue <> *null
     C                   eval      aCondition = %str(pValue)
     C     aCondition    lookup    cnd_array                              01
     C                   if        not *in01
     C                   leave
     C                   endif
     C                   eval      pValue = strtok(*null     : ' ')
     C                   enddo
      *
     C                   endif
      *
     C                   if        *in01
     C                   eval      isCondition = *on
     C                   else
     C                   eval      isCondition = *off
     C                   endif
      *
     C                   Return    isCondition
     P isCondition...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get the current release level of the operation system
      *---------------------------------------------------------------------------------------------
     P getCurrentRelease...
     P                 B
      *
     D getCurrentRelease...
     D                 PI            10A
      *
      *  QSZRTVPR API
     D QSZRTVPR...
     D                 PR                  extpgm('QSZRTVPR')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  o_prodInf                 65535A   const  options(*varsize)
     D  io_errCode                65535A          options(*varsize)
      *
     D prdi0100        DS                  qualified
     D  productID              1      7A   inz('*OPSYS')
     D  releaseLvl             8     13A   inz('*CUR'  )
     D  productOpt            14     17A   inz('0000'  )
     D  loadID                18     27A   inz('*CODE' )
      *  Shortened!:
     D prdr0100        DS                  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     12I 0
     D  productID             13     19A
     D  releaseLvl            20     25A
      *  API error code
     D errCode         DS
     D  bytPrv                       10i 0 inz(0)
     D  bytAvl                       10i 0 inz(0)
      *-------------------------------------------------------------------*
     C                   Callp     QSZRTVPR(prdr0100: %size(prdr0100):
     C                                      'PRDR0100': prdi0100: errCode)
     C                   Return    prdr0100.releaseLvl
     P getCurrentRelease...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check the release level
      *---------------------------------------------------------------------------------------------
     P isRelease...
     P                 B
      *
     D isRelease...
     D                 PI              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *
      *  return value
     D isRelease       S               n   inz(*off)
      *  Release
     D release         DS
     D  r_operator             1      3a
     D  r_space                4      4a
     D  r_level                5     10a
      *-------------------------------------------------------------------*
     C                   If        i_release = '*CURRENT'
     C                   Eval      isRelease = *on
     C                   Else
     C                   Eval      release = i_release
     C                   Select
     C                   When      r_operator = '*LT' and
     C                             i_os_release < r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*EQ' and
     C                             i_os_release = r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GT' and
     C                             i_os_release > r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*LE' and
     C                             i_os_release <= r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GE' and
     C                             i_os_release >= r_level
     C                   Eval      isRelease = *on
     C                   Other
     C                   Eval      isRelease = *off
     C                   Endsl
     C                   Endif
      *
     C                   Return    isRelease
     P isRelease...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Replaces the value of a given keyword.
      *---------------------------------------------------------------------------------------------
     P setTargetRelease...
     P                 B
      *
     D setTargetRelease...
     D                 PI          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *
      *  return value
     D string          S           2000A   varying inz
      *
      *  helper fields
     D x               S             10I 0 inz
     D l               S             10I 0 inz
     D tmpKeyword      S                   like(i_keyword) inz
     D tmpString       S                   like(i_string ) inz
     D tmpCmd          S             10A   inz
      *-------------------------------------------------------------------*
      /FREE
         tmpKeyword = uCase(%trimR(i_keyword));
         tmpString  = uCase(%trimR(i_string ));
         x = %scan(' ': tmpString);
         if x = 0;
            return i_string;
         endif;
         tmpCmd = %subst(tmpString: 1: x);
         if tmpCmd <> 'CRTRPGMOD' and
            tmpCmd <> 'CRTRPGPGM' and
            tmpCmd <> 'CRTCLMOD'  and
            tmpCmd <> 'CRTCLPGM'  and
            tmpCmd <> 'CRTCBLMOD' and
            tmpCmd <> 'CRTCBLPGM' and
            tmpCmd <> 'CRTCMOD'   and
            tmpCmd <> 'CRTCPPMOD' and
            tmpCmd <> 'CRTBNDC'   and
            tmpCmd <> 'CRTBNDCBL' and
            tmpCmd <> 'CRTBNDCL'  and
            tmpCmd <> 'CRTBNDCPP' and
            tmpCmd <> 'CRTBNDDIR' and
            tmpCmd <> 'CRTBNDRPG' and
            tmpCmd <> 'CRTPGM'    and
            tmpCmd <> 'CRTSRVPGM' ;
            return i_string;
         endif;
         x = %scan(tmpKeyword + '(': tmpString);
         if x = 0;
            return %trimR(i_string) +
                   ' ' + tmpKeyword + '(' + %trimR(i_value) + ')';
         endif;
         l = %scan(')': tmpString: x + %len(i_keyword) + 1);
         if l = 0;
            return i_string;
         endif;
         l = l - x + 1;
         string = %replace(tmpKeyword + '(' + %trimR(i_value) + ')'
                           : i_string: x: l);
         Return string;
      /END-FREE
      *
     P setTargetRelease...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Store field value.
      *---------------------------------------------------------------------------------------------
     P setVariable...
     P                 B
      *
     D setVariable...
     D                 PI
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
     D i               s             10I 0 inz
      *-------------------------------------------------------------------*
      /FREE
         if (i_fldName = '');
            return;
         endif;
         for i = 1 to fld_x;
            if (uCase('&' + %trim(i_fldName)) = uCase(fld_name(fld_x)));
               fld_value(fld_x) = i_value;
               leave;
            endif;
         endfor;
         if (fld_x >= %elem(fld_name));
            return;
         endif;
         fld_x = fld_x + 1;
         fld_name(fld_x)  = uCase('&' + %trim(i_fldName));
         fld_value(fld_x) = i_value;
      /END-FREE
      *
     P setVariable...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable name from statement.
      *---------------------------------------------------------------------------------------------
     P getVarName...
     P                 B
      *
     D getVarName...
     D                 PI            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
     D name            s             11a   varying inz
     D CHARS           c                   '&ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                      abcdefghijklmnopqrstuvwxyz+
     D                                      1234567890_'
      *-------------------------------------------------------------------*
      /FREE
         dow (i_pos<=%len(i_bldexc) and
              %check(CHARS:%subst(i_bldexc:i_pos:1))=0);
            name = name+%subst(i_bldexc:i_pos:1);
            i_pos=i_pos+1;
         enddo;
         return name;
      /END-FREE
      *
     P getVarName...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable value.
      *---------------------------------------------------------------------------------------------
     P getVarValue...
     P                 B
      *
     D getVarValue...
     D                 PI            64a          varying
     D  i_name                       11a   value  varying
     D i               s             10i 0 inz
     D value           s             64a   varying inz('?')
      *-------------------------------------------------------------------*
      /FREE
         for i=1 to fld_x;
            if (ucase(fld_name(i))=uCase(i_name));
               value=%trimR(fld_value(i));
               leave;
            endif;
         endfor;
         return value;
      /END-FREE
      *
     P getVarValue...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  convert to upper case
      *---------------------------------------------------------------------------------------------
     P uCase...
     P                 B
      *
     D uCase...
     D                 PI          2000A          varying
     D  i_string                   2000A   value  varying
     D uCase           s           2000A   inz varying
     D LC              C                   const('abcdefghijklmnopqrstuvwxyz')
     D UC              C                   CONST('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      *-------------------------------------------------------------------*
      /FREE
         uCase = %xlate(LC:UC:i_string);
         return uCase;
      /END-FREE
      *
     P uCase...
     P                 E
      * /// END   OF INSTALL PGM HERE   ****************************************** ///
      * /// do not copy past this point ///
]]>  </install_program>
<qrycond
  msg="'Create sample programs? (YES, NO)'"
  values="YES        NO"
  var="CRTTSTPGM">
<![CDATA[
]]>  </qrycond>
<qrycond
  msg="'C-Compiler available? (C_YES, C_NO)'"
  values="C_YES      C_NO"
  var="C_COMP">
<![CDATA[
]]>  </qrycond>
<chgvar   condition="*NONE" var="SRCFILE" value="QBASICS1">
<![CDATA[
]]>  </chgvar>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_INSTALL  type CLLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_INSTALL "
mbrtype =  "CLLE      "
mbrtext =  "BASICS1 - Installer                               "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* =================================================================== */
     /*                                                                     */
     /*  Documentation:                                                     */
     /*                                                                     */
     /*  Utility . . . : BASICS1                                            */
     /*  Object  . . . : A_INSTALL  (PGM)                                   */
     /*  Source member : A_INSTALL                                          */
     /*  Source type . : CLLE                                               */
     /*  Description   : BASICS1 - Installer                                */
     /*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      */
     /*                                                                     */
     /* =================================================================== */
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /* =================================================================== */
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          nderung                                 */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /* =================================================================== */
     /*   >>PRE-COMPILER<<                                                  */
     /*     >>CRTCMD<<    CRTBNDCL  PGM(QTEMP/&OB) +                        */
     /*                             SRCFILE(&SL/&SF) SRCMBR(&SM);           */
     /*     >>IMPORTANT<<                                                   */
     /*       >>PARM<<    OPTION(*EVENTF);                                  */
     /*     >>END-IMPORTANT<<                                               */
     /*     >>EXECUTE<<                                                     */
     /*     >>CMD<<       CALL   PGM(QTEMP/A_INSTALL) +                     */
     /*                          PARM('*CURRENT' '&SF' '&LI' 'NO' 'C_YES'); */
     /*     >>CMD<<       DLTPGM PGM(QTEMP/A_INSTALL);                      */
     /*   >>END-PRE-COMPILER<<                                              */
     /* =================================================================== */
             PGM        PARM(&TGTRLS &SRCFILE &TOLIB &CRTTSTPGM &C_COMP)

             DCL        VAR(&TGTRLS    ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&SRCFILE   ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&TOLIB     ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&CRTTSTPGM ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&C_COMP    ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&CND_C_COMP) TYPE(*CHAR) LEN(10)

             DCL        VAR(&SRCLIB    ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&BASICS1C7 ) TYPE(*CHAR) LEN(10)

             CHGVAR     VAR(&SRCLIB) VALUE(&TOLIB   )

     /* -------------------------------- */
     /*  Delete old objects              */
     /* -------------------------------- */
             DLTMOD     MODULE(&TOLIB/BASICS1C7)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RA)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RB)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RC)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RD)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RE)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RF)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RG)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1RH)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R1)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R2)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R3)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R4)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R5)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R6)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R7)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R8)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/BASICS1R9)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RA_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RA_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RA_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RB_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RC_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RC_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RC_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RC_04)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RC_05)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RD_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RE_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_RH_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R1_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R1_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R1_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R2_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_04)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_05)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_06)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_07)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_08)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_09)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_10)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_11)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_12)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_13)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R3_14)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R4_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R5_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R5_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R5_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R5_04)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R5_05)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R6_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R6_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_02)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_03)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_04)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_05)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_06)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_07)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_08)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R7_09)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R8_01)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/TEST_R8_02)
             MONMSG     MSGID(CPF2105)

             DLTSRVPGM  SRVPGM(&TOLIB/BASICS1)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RA_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RA_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RA_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RB_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RC_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RC_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RC_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RC_04)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RC_05)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RD_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RE_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_RH_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R1_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R1_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R1_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R2_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_04)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_05)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_06)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_07)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_08)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_09)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_10)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_11)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_12)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_13)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R3_14)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R4_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R5_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R5_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R5_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R5_04)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R5_05)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R6_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R6_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_02)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_03)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_04)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_05)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_06)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_07)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_08)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R7_09)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R8_01)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/TEST_R8_02)
             MONMSG     MSGID(CPF2105)

             RMVMSG     PGMQ(*SAME (*)) CLEAR(*ALL)

     /* -------------------------------- */
     /*  Create modules                  */
     /* -------------------------------- */
             IF         COND(&C_COMP *EQ 'C_YES') THEN(DO)
                CHGVAR     VAR(&BASICS1C7 ) VALUE('BASICS1C7')
                CHGVAR     VAR(&CND_C_COMP) VALUE('C_COMPILER')
                CRTCMOD    MODULE(&TOLIB/&BASICS1C7)   +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             OUTPUT(*PRINT)  +
                             DBGVIEW(*ALL)   +
                             DEFINE(DYNAMIC_CRC_TABLE) +
                             OPTIMIZE(40)    +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(&BASICS1C7) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)
             ENDDO
             ELSE       CMD(DO)
                CHGVAR     VAR(&BASICS1C7) VALUE('*N')
                CHGVAR     VAR(&CND_C_COMP) VALUE('*N')
             ENDDO

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RA) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RA) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RB) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RB) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RC) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RC) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RD) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RD) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RE) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RE) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RF) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RF) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RG) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RG) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1RH) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1RH) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R1) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R1) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R2) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R2) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R3) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R3) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R4) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R4) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R5) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R5) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R6) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R6) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R7) +
                          SRCFILE(&SRCLIB/&SRCFILE) +
                          SRCMBR(*MODULE)  +
                          DBGVIEW(*LIST)   +
                          OPTIMIZE(*FULL ) +
                          TRUNCNBR(*NO)    +
                          DEFINE(&CND_C_COMP) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R7) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R8) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R8) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             CRTRPGMOD  MODULE(&TOLIB/BASICS1R9) +
                          SRCFILE(&TOLIB/QBASICS1) +
                          SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) +
                          TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1R9) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create service programs         */
     /* -------------------------------- */
             CRTSRVPGM  SRVPGM(&TOLIB/BASICS1) +
                          MODULE(&TOLIB/BASICS1R1 +
                                 &TOLIB/BASICS1R2 +
                                 &TOLIB/BASICS1R3 +
                                 &TOLIB/BASICS1R4 +
                                 &TOLIB/BASICS1R5 +
                                 &TOLIB/BASICS1R6 +
                                 &TOLIB/BASICS1R7 +
                                 &TOLIB/&BASICS1C7 +
                                 &TOLIB/BASICS1R8 +
                                 &TOLIB/BASICS1R9 +
                                 &TOLIB/BASICS1RA +
                                 &TOLIB/BASICS1RB +
                                 &TOLIB/BASICS1RC +
                                 &TOLIB/BASICS1RD +
                                 &TOLIB/BASICS1RE +
                                 &TOLIB/BASICS1RF +
                                 &TOLIB/BASICS1RG +
                                 &TOLIB/BASICS1RH) +
                          EXPORT(*SRCFILE) +
                          SRCFILE(&SRCLIB/&SRCFILE) +
                          SRCMBR(BASICS1) +
                          BNDDIR(QC2LE)   +
                          ACTGRP(*CALLER) +
                          DETAIL(*BASIC) +
                          TEXT('Tools/400: Runtime Library') +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(BASICS1  ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create test programs            */
     /* -------------------------------- */
             IF         COND(&CRTTSTPGM *EQ 'YES') THEN(DO)

        /* TEST_RA_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RA_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RA_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RA_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RA_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RA_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RA_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RA_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RA_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RA_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RA_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RA_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RA_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RA_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RA_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RB_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RB_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RB_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RB_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RB_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RC_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RC_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RC_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RC_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RC_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RC_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RC_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RC_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RC_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RC_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RC_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RC_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RC_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RC_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RC_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RC_04 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RC_04) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RC_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RC_04) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RC_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RC_05 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RC_05) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RC_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RC_05) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RC_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RD_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RD_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RD_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RD_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RD_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RE_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RE_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RE_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RE_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RE_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_RH_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_RH_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_RH_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_RH_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_RH_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R1_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R1_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R1_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R1_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R1_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R1_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R1_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R1_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R1_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R1_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R1_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R1_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R1_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R1_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R1_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R2_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R2_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R2_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R2_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R2_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_04 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_04) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_04) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_05 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_05) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_05) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_06 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_06) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_06) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_06) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_06) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_07 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_07) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_07) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_07) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_07) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_08 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_08) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_08) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_08) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_08) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_09 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_09) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_09) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_09) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_09) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_10 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_10) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_10) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_10) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_10) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_11 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_11) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_11) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_11) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_11) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_12 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_12) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_12) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_12) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_12) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_13 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_13) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_13) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_13) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_13) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R3_14 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R3_14) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R3_14) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R3_14) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R3_14 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R4_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R4_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R4_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R4_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R4_01 ) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R5_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R5_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R5_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R5_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R5_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R5_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R5_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R5_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R5_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R5_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R5_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R5_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R5_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R5_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R5_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R5_04 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R5_04) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R5_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R5_04) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R5_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R5_05 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R5_05) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R5_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R5_05) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R5_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R6_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R6_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R6_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R6_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R6_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R6_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R6_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R6_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R6_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R6_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_03 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_03) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_03) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_03) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_04 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_04) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_04) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_04) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_05 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_05) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_05) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_05) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_06 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_06) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_06) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_06) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_06) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_07 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_07) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_07) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_07) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_07) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_08 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_08) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_08) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_08) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_08) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R7_09 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R7_09) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R7_09) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R7_09) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R7_09) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R8_01 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R8_01) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R8_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R8_01) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R8_01) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

        /* TEST_R8_02 */
                CRTRPGMOD  MODULE(&TOLIB/TEST_R8_02) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(TEST_R8_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/TEST_R8_02) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/BASICS1) +
                             BNDDIR(QC2LE) +
                             ACTGRP(*NEW) +
                             TGTRLS(&TGTRLS) +
                             DETAIL(*BASIC)
                DLTSPLF    FILE(TEST_R8_02) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

             ENDDO

     /* -------------------------------- */
     /*  Delete obsolete objects         */
     /* -------------------------------- */
             IF         COND(&C_COMP *EQ 'C_YES') THEN(DO)
                DLTMOD     MODULE(&TOLIB/BASICS1C7)
             ENDDO

             DLTMOD     MODULE(&TOLIB/BASICS1RA)
             DLTMOD     MODULE(&TOLIB/BASICS1RB)
             DLTMOD     MODULE(&TOLIB/BASICS1RC)
             DLTMOD     MODULE(&TOLIB/BASICS1RD)
             DLTMOD     MODULE(&TOLIB/BASICS1RE)
             DLTMOD     MODULE(&TOLIB/BASICS1RF)
             DLTMOD     MODULE(&TOLIB/BASICS1RG)
             DLTMOD     MODULE(&TOLIB/BASICS1RH)
             DLTMOD     MODULE(&TOLIB/BASICS1R1)
             DLTMOD     MODULE(&TOLIB/BASICS1R2)
             DLTMOD     MODULE(&TOLIB/BASICS1R3)
             DLTMOD     MODULE(&TOLIB/BASICS1R4)
             DLTMOD     MODULE(&TOLIB/BASICS1R5)
             DLTMOD     MODULE(&TOLIB/BASICS1R6)
             DLTMOD     MODULE(&TOLIB/BASICS1R7)
             DLTMOD     MODULE(&TOLIB/BASICS1R8)
             DLTMOD     MODULE(&TOLIB/BASICS1R9)

             IF         COND(&CRTTSTPGM *EQ 'YES') THEN(DO)
                DLTMOD     MODULE(&TOLIB/TEST_RA_01)
                DLTMOD     MODULE(&TOLIB/TEST_RA_02)
                DLTMOD     MODULE(&TOLIB/TEST_RA_03)
                DLTMOD     MODULE(&TOLIB/TEST_RB_01)
                DLTMOD     MODULE(&TOLIB/TEST_RC_01)
                DLTMOD     MODULE(&TOLIB/TEST_RC_02)
                DLTMOD     MODULE(&TOLIB/TEST_RC_03)
                DLTMOD     MODULE(&TOLIB/TEST_RC_04)
                DLTMOD     MODULE(&TOLIB/TEST_RC_05)
                DLTMOD     MODULE(&TOLIB/TEST_RD_01)
                DLTMOD     MODULE(&TOLIB/TEST_RE_01)
                DLTMOD     MODULE(&TOLIB/TEST_RH_01)
                DLTMOD     MODULE(&TOLIB/TEST_R1_01)
                DLTMOD     MODULE(&TOLIB/TEST_R1_02)
                DLTMOD     MODULE(&TOLIB/TEST_R1_03)
                DLTMOD     MODULE(&TOLIB/TEST_R2_01)
                DLTMOD     MODULE(&TOLIB/TEST_R3_01)
                DLTMOD     MODULE(&TOLIB/TEST_R3_02)
                DLTMOD     MODULE(&TOLIB/TEST_R3_03)
                DLTMOD     MODULE(&TOLIB/TEST_R3_04)
                DLTMOD     MODULE(&TOLIB/TEST_R3_05)
                DLTMOD     MODULE(&TOLIB/TEST_R3_06)
                DLTMOD     MODULE(&TOLIB/TEST_R3_07)
                DLTMOD     MODULE(&TOLIB/TEST_R3_08)
                DLTMOD     MODULE(&TOLIB/TEST_R3_09)
                DLTMOD     MODULE(&TOLIB/TEST_R3_10)
                DLTMOD     MODULE(&TOLIB/TEST_R3_11)
                DLTMOD     MODULE(&TOLIB/TEST_R3_12)
                DLTMOD     MODULE(&TOLIB/TEST_R3_13)
                DLTMOD     MODULE(&TOLIB/TEST_R3_14)
                DLTMOD     MODULE(&TOLIB/TEST_R4_01)
                DLTMOD     MODULE(&TOLIB/TEST_R5_01)
                DLTMOD     MODULE(&TOLIB/TEST_R5_02)
                DLTMOD     MODULE(&TOLIB/TEST_R5_03)
                DLTMOD     MODULE(&TOLIB/TEST_R5_04)
                DLTMOD     MODULE(&TOLIB/TEST_R5_05)
                DLTMOD     MODULE(&TOLIB/TEST_R6_01)
                DLTMOD     MODULE(&TOLIB/TEST_R6_02)
                DLTMOD     MODULE(&TOLIB/TEST_R7_01)
                DLTMOD     MODULE(&TOLIB/TEST_R7_02)
                DLTMOD     MODULE(&TOLIB/TEST_R7_03)
                DLTMOD     MODULE(&TOLIB/TEST_R7_04)
                DLTMOD     MODULE(&TOLIB/TEST_R7_05)
                DLTMOD     MODULE(&TOLIB/TEST_R7_06)
                DLTMOD     MODULE(&TOLIB/TEST_R7_07)
                DLTMOD     MODULE(&TOLIB/TEST_R7_08)
                DLTMOD     MODULE(&TOLIB/TEST_R7_09)
                DLTMOD     MODULE(&TOLIB/TEST_R8_01)
                DLTMOD     MODULE(&TOLIB/TEST_R8_02)
             ENDDO

             ENDPGM
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_README  type TXT - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_README  "
mbrtype =  "TXT       "
mbrtext =  "History BASICS1 Service Program                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
-----------------------
      History
-----------------------


Version 1.14.5
--------------

Added:   Procedures:
            f_cvtEpochTS()
            f_cvtTSEpoch()
            f_cvtMiTimeTS()
            f_cvtTSMiTime()


Version 1.14.2
--------------

Changed: Changed BasicList to store up to 1.044.473 items.
Changed: Added error message 'Failed to allocate memory' which is sent
         when BasicList could not allocate/reallocate memory.
Added:   Added BasicList_getTotalSize() to return the total size of
         memory used by a given BasicList.


Version 1.14.1
--------------

Changed: Updated member CLIB.


Version 1.14
------------

Added:   Procedures :
            BasicProperties_*
            f_setErrno()
            MemoryReader_*
            MemoryWriter_*
Changed: Renamed the BasicMap_KeySet_* procedures and type templates to:
            BasicMap_newKeySet()
            BasicKeySet_getFirst()
            BasicKeySet_getNext()
            BasicKeySet_delete()
            BasicKeySet_handle_t


Version 1.13.2
--------------

Added:   Procedure f_startsWithIgnoreCase().


Version 1.13.1
--------------

Fixed:   Now passing the right length to f_genSHA1() in order to
         generate a SHA-1 hash from a buffer. (TEST_R7_05)
Changed: Added CCSID(*CHAR: *JOBRUN) to member H_SPEC as recommended
         by Barbara Morris. (RPG Cafe: 'An H spec keyword that you
         might be missing')


Version 1.13
------------

Added:   Procedures BasicMap_getKeys() and BasicMap_getValues().
Added:   Procedure f_getSndInfOfRcvMsg().
Added:   Procedures f_rtvSysVal_char() and f_rtvSysVal_num().
Added:   Procedure f_cvtPtrToHexString().
Added:   Added parameter 'i_heapID' to BasicList_new(), BasicStack_new() and
         BasicMap_new().
Added:   MemoryManager.
Added:   Procedures BasicList_getHeapID(), BasicStack_getHeapID() and BasicMap_getHeapID().


Version 1.12.1
--------------

Fixed:   Changed passing mode of parameter i_followLnk of prototype Qp0lGetAttr
         from 'const' to 'value'.


Version 1.12
------------

Fixed:   Fixed problem in f_genStrCmp() that does not properly
         compare strings that contain multiple dots.


Version 1.11
------------

Changed: Added prompter action support to f_execute().
Changed: Moved declaration of user space APIs to member QUSRSPC.
Changed: Renamed f_getDisplayMode() to Display_getMode().
Fixed:   Fixed problem in f_wordwrap() that caused a runtime error
         in case that the last character of the input string is an
         EOP escape character.
Added:   Test program TEST_R5_04 to check user space procedures.
Added:   Test program TEST_R3_13 to check date formatter and parser.
Added:   Test program TEST_R3_14 to check f_formatMemSize().
Added:   Procedures: f_chgUsrSpcSize()
                     f_getUsrSpcSize()
                     f_chgUsrSpcAutoExt()
                     f_getUsrSpcAutoExt()
                     f_chgUsrSpcInitValue()
                     f_getUsrSpcInitValue()
                     f_rplUnPrtChars()
                     f_formatDate()
                     f_parseDate()
                     f_formatMemSize()
                     Display_supportsDS4()
                     Display_supportsGUI()
                     Display_getRows()
                     Display_getColumns()
                     p_wait()
                     f_dateSerial()

Procedures with V1.11                          Program:
----------------------------------------       ----------------------------------------
BASICS1R5_f_chgUsrSpcSize                      TEST_R5_04
BASICS1R5_f_getUsrSpcSize                      TEST_R5_04
BASICS1R5_f_chgUsrSpcAutoExt                   TEST_R5_04
BASICS1R5_f_getUsrSpcAutoExt                   TEST_R5_04
BASICS1R5_f_chgUsrSpcInitValue                 TEST_R5_04
BASICS1R5_f_getUsrSpcInitValue                 TEST_R5_04


Version 1.10
------------

Fixed:   Changed size of parameter 'i_text' or f_crtUsrSpc() from 10A to 50A.
Added:   Procedures: f_getObjLib()
                     f_objName()
                     f_rcvPgmMsgObj()


Version 1.9
-----------

Changed: Enabled BasicMap to store NULL values.
Changed: Added optional parameter 'offset' to f_caller().
         (Needed for the Log4rpg stub module.)
Added:   Procedures: BasicList_clone()
                     BasicMap_clone()


Version 1.8.1
-------------

Changed: Enabled BasicMap_KeySet_new() to be called more than once.
         Introduced a real KeySet handle.


Version 1.8
-----------

Changed: Changed internal structure of Map object. Introduced a real handle for the Map.
Changed: Changed internal structure of Stack object. Introduced a real handle for the Stack.
Changed: Enabled BasicList to store NULL values.
Added:   Procedures: BasicList_isSorted()
                     BasicList_addNull()
                     BasicList_setNull()
                     BasicList_isNullValue()
                     BasicMap_KeySet_new()
                     BasicMap_KeySet_getFirst()
                     BasicMap_KeySet_getNext()
                     BasicMap_KeySet_delete()
Added:   BasicList   Check type of handle restrictively.
         BasicStack  Check type of handle restrictively.
         BasicMap    Check type of handle restrictively.


Version 1.7.2
-------------

Fixed:   Error in FDMBRD0100. Invalid length of MBRD0100.SRCFILE. Renamed sub field
         'srcFile' to 'isSrcFile'.


Version 1.7.1
-------------

Fixed:   Memory leak in BasicMap. BasicMap_remove() did not properly
         free the memory used by the map entry data.


Version 1.7
-----------

Fixed:   Now BasicStack_pop() correctly removes the list entry
         for NULL pointer returned by BasicList_get(). That happens
         if a NULL string was pushed onto the stack.
Changed: Changed f_execute() to receive an error message directly
         rather that trying to get it from the errorCode parameter.
Changed: Added assert() to BasicMap_put() to ensure that the 'i_key'
         contains a value greater than 0.
Changed: Enhanced f_cvtApiErrCodeToMsg() to
         receive the original error message from the previous call
         stack entry, if possible.
Added:   Procedures: f_endsWith()
                     f_containsInvalidCharAt()
                     f_containsStringAt()
Added:   Procedures: BasicMap_getSizeByIndex()
                     BasicMap_putString()
                     BasicMap_getString()
                     BasicMap_putInteger()
                     BasicMap_getInteger()
Added:   Procedures: Url_new()
                     Url_getFile()
                     Url_getHost()
                     Url_getPath()
                     Url_getPort()
                     Url_getProtocol()
                     Url_getQuery()
                     Url_getMbr()
                     Url_toString()
                     Url_setFile()
                     Url_setHost()
                     Url_setPath()
                     Url_setPort()
                     Url_setProtocol()
                     Url_setQuery()


Version 1.6.3
-------------

Added:   Procedure f_cvtRcvMsgToMsg().


Version 1.6.2
-------------

Fixed:   Fixed problem in f_cvtErrnoToMsg(). Now errors without
         corresponding message description in QC2MSGF are
         returned as CPF9898 message.
Added:   Procedure BasicStack_peek().
Added:   Procedure BasicStack_clear().
Added:   Procedure BasicList_clear().
Added:   Procedure BasicMap_clear().
Changed: Removed external data structures from distribution package.


Version 1.6.1
-------------

Changed: Changed BasicList_get() to initialize only that bytes of
         the return buffer that are beyond the length of the list entry.
Fixed:   Changed f_getEnvVarByIndex to respect the length of the
         environment variable.


Version 1.6
-----------

Procedures with V1.6                           Program:
----------------------------------------       ----------------------------------------
BASICS1R8_MEMORY_allocate                      TEST_R8_02
BASICS1R8_MEMORY_freeAll                       TEST_R8_02
BASICS1R8_MEMORY_free                          TEST_R8_02
BASICS1R5_f_activateSrvPgm                     LOG4RPG
BASICS1R5_f_getProcPtrByName                   LOG4RPG
BASICS1RA_BasicList_add                        TEST_RA_01
BASICS1RA_BasicList_addPointer
BASICS1RA_BasicList_addString                  TEST_RA_01
BASICS1RA_BasicList_delete                     TEST_RA_01
BASICS1RA_BasicList_find                       TEST_RA_01
BASICS1RA_BasicList_findString                 TEST_RA_01
BASICS1RA_BasicList_get                        TEST_RA_01
BASICS1RA_BasicList_getListType                TEST_RA_01
BASICS1RA_BasicList_getNumE                    TEST_RA_01
BASICS1RA_BasicList_getPointer
BASICS1RA_BasicList_getSize                    TEST_RA_01
BASICS1RA_BasicList_getString                  TEST_RA_01
BASICS1RA_BasicList_getType                    TEST_RA_01
BASICS1RA_BasicList_isListTypeOf               TEST_RA_01
BASICS1RA_BasicList_isNull                     TEST_RA_01
BASICS1RA_BasicList_isTypeOf                   TEST_RA_01
BASICS1RA_BasicList_new                        TEST_RA_01
BASICS1RA_BasicList_null
BASICS1RA_BasicList_remove
BASICS1RA_BasicList_set
BASICS1RA_BasicList_setAutoSort
BASICS1RA_BasicList_setPointer
BASICS1RA_BasicList_setString
BASICS1RA_BasicList_sort
BASICS1RB_BasicStack_delete                    TEST_RB_01
BASICS1RB_BasicStack_getNumE                   TEST_RB_01
BASICS1RB_BasicStack_getSize                   TEST_RB_01
BASICS1RB_BasicStack_isNull                    TEST_RB_01
BASICS1RB_BasicStack_new                       TEST_RB_01
BASICS1RB_BasicStack_null                      TEST_RB_01
BASICS1RB_BasicStack_pop                       TEST_RB_01
BASICS1RB_BasicStack_push                      TEST_RB_01
BASICS1RC_BasicMap_containsKey                 TEST_RC_01
BASICS1RC_BasicMap_delete                      TEST_RC_01
BASICS1RC_BasicMap_get                         TEST_RC_01
BASICS1RC_BasicMap_getKeyByIndex
BASICS1RC_BasicMap_getValueByIndex             TEST_RC_01
BASICS1RC_BasicMap_getNumE                     TEST_RC_01
BASICS1RC_BasicMap_getSize                     TEST_RC_01
BASICS1RC_BasicMap_isNull                      TEST_RC_01
BASICS1RC_BasicMap_new                         TEST_RC_01
BASICS1RC_BasicMap_null                        TEST_RC_01
BASICS1RC_BasicMap_put                         TEST_RC_01
BASICS1RC_BasicMap_remove                      TEST_RC_01, TEST_RC_02
BASICS1R3_f_startsWith

Fixed:   Fixed problem in f_wordwrap() that EOL-character was not found
         when it was the last character in the string.
Changed: Changed p_assert(), f_this() and f_caller() to use a static
         buffer of 2048 byte to receive the test message for better
         performance.
Changed: Changed procedure f_caller() to return the statement ID
         as the next optional parameter.
Changed: Changed procedure f_this() to return the statement ID
         as the next optional parameter.
Changed: Changed procedure HANDLE_isTypeOf() to return "invalid handle"
         instead of throwing an exception when the pointer of the handle
         is *NULL.
Added:   Procedures MEMORY_allocate(), MEMORY_free() and MEMORY_freeAll()
         to ease working with dynamic memory allocation.
Added:   Procedure f_activateSrvPgm().
Added:   Procedure f_getProcPtrByName().
Added:   Procedures BasicList_* to enable dynamic lists.
Added:   Procedures BasicStack_* to enable stack support.
Added:   Procedures BasicMap_* to enable map support.
Added:   Procedure f_startsWith.


Version 1.5
-----------

Procedures with V1.5                           Program:
----------------------------------------       ----------------------------------------
BASICS1R9_f_getDisplayMode
BASICS1R6_f_getNumEnvVar                       TEST_R6_02
BASICS1R6_f_getEnvVarByIndex                   TEST_R6_02
BASICS1R7_f_genCRC32                           TEST_R7_08, TEST_R7_09

Changed: Changed BASICS1 to get a clear compile for V5R1M0.
Fixed:   Changed return value of procedure f_ebcdic() from 3I0 to 3U0 to
         avoid negative values.
Added:   Added procedure f_getDisplayMode() to the current display mode.
         This procedure uses the Retrieve Display Mode (QsnRtvMod) API.
Added:   Added procedure f_getNumEnvVar() get the number of environment
         variables.
Added:   Added procedure f_getEnvVarByIndex() get the value of an
         environment variable. The variable is addressed by its index.
Added:   Added procedure f_genCRC32() to calculate a CRC-32 check sum.
         Use the C compiler whenever it is possible because of great
         performance advantages.

Performance measurement results of f_genCRC32() with a 8.517 kByte file:

  iSeries:
  --------
  Model  . . . . :  820
  Main storage . :  System    Pool
                    Pool   Size (M)
                      1      820,60
                      2     1847,79
                      3      679,19
                      4       33,81

  w/o code optimization                   with maximum code optimization
  C_COMPILER    V5R3       V5R2           C_COMPILER    V5R3       V5R2
  ----------   ------     ------          ----------   ------     ------
     636        2970       4496             129         1225       2853
     572        3036       4140             186         1239       3627
     596        2526       4248             124         1343       3465
     714        2506       4896             204         1255       3220
     650        2540       4424             180         1708       2865
     570        2457       4363             173         1231       3017
     606        2506       5115             177         1397       2816
     592        2569       4327             142         1240       2718
     699        2880       4274             146         1231       2885
     628        2479       4308             177         1383       2860
  ----------   ------     ------          ----------   ------     ------
     626,3      2646,9     4459,1           163,8       1325,2     3032,6

  Speed factors:
  --------------
  C to V5R3:      4,2                     C to V5R3:      8,1
  C to V5R2:      7,1                     C to V5R2:     18,5
  V5R3 to V5R2:   1,7                     V5R3 to V5R2:   2,3


Version 1.4
-----------

Procedures with V1.3                           Program:
----------------------------------------       ----------------------------------------
BASICS1R3_f_cvtBufferToHexString               TEST_R3_11
BASICS1R3_f_cvtHexStringToBuffer               TEST_R3_11
BASICS1R7_f_genUUID                            TEST_R7_03
BASICS1R7_f_genMd5                             TEST_R7_04, TEST_R7_06
BASICS1R7_f_genSHA1                            TEST_R7_05, TEST_R7_07
BASICS1R2_f_cvtErrnoToMsg                      TEST_R2_01

Changed: Enhanced f_wordWrap() to support end-of-paragraph markers.
Added:   Added prototype of C-function time() to member CLIB.
Added:   Added procedure f_cvtBufferToHexString() to convert a memory
         buffer to a readable string of hex values.
Added:   Added procedure f_cvtHexStringToBuffer() to convert a
         a readable string of hex values to a buffer.
Added:   Added procedure f_genUUID() to generate a Universal Unique
         Identifier.
Added:   Added procedure f_genMD5() to generate a MD5 fingerprint.
Added:   Added procedure f_genSHA1() to generate a SHA-1 fingerprint.
Added:   Added procedure f_cvtErrnoToMsg() to convert a C error number
         to a message.


Version 1.3.1:
--------------

Changed: Added parameter TGTRLS(*CURRENT) to all creation commands.
Changed: Removed '#' from member names.


Version 1.3:
------------

Procedures with V1.3                           Program:
----------------------------------------       ----------------------------------------
BASICS1R1_f_rtvMsgTextRaw
BASICS1R1_f_rtvMsgHelpTextRaw
BASICS1R3_f_center                             TEST_R3#08
BASICS1R3_f_alignR                             TEST_R3#08
BASICS1R3_f_genStrCmp                          TEST_R3#09
BASICS1R3_f_genStrCmpIgnCase                   TEST_R3#09
BASICS1R1_f_scanR

Changed: Removed useless copy books PBASICS1R2, PBASICS1R4 and PBASICS1R6
         from copy book PBASICS1R5. Added copy book PBASICS1R1 instead.
Changed: Changed f_space() to accept a 0 length.
Changed: Changed f_addQuotes() to add quotes only in case it is not yet
         a quoted string. A quoted string is a string that starts and ends
         with a quote.
Changed: Changed f_rmvQuotes() to removes quotes only in case it is a
         a quoted string. A quoted string is a string that starts and ends
         with a quote.
Added:   Added procedure f_rtvMsgTextRaw() to retrieve the message text
         without replacing substitution variables.
Added:   Added procedure f_rtvMsgHelpTextRaw() to retrieve the message help text
         without replacing substitution variables.
Added:   Added procedure f_center() to center a given string.
Added:   Added procedure f_alignR() to right align a given string.
Added:   Added procedure f_genStrCmp() to perform string compare
         using wildcard characters.
Added:   Added procedure f_genStrCmpIgnCase() to perform string compare
         using wildcard characters. (Ignore case)
Added:   Added procedure f_scanR reverse scan a given string for
         a search argument.
Added:   Added data type definition rtvm0400_t.


Version 1.2:
------------

Procedures with V1.2                           Program:
----------------------------------------       ----------------------------------------
BASICS1R3_f_rmvKeyword                         TEST_R3#07
BASICS1R3_f_rmvQuotes
BASICS1R3_f_addQuotes
BASICS1R5_f_crtUsrSpc                          -+
BASICS1R5_f_rtvUsrSpcPtr                        ]
BASICS1R5_f_dltUsrSpc                           ]
BASICS1R8_HANDLE_new                            ]- Used by my list service programs
BASICS1R8_HANDLE_null                           ]
BASICS1R8_HANDLE_isNull                         ]
BASICS1R8_HANDLE_isTypeOf                       ]
BASICS1R8_HANDLE_getPointer                     ]
BASICS1R8_HANDLE_delete                        -+

Changed: Removed useless parameter i_rtnCtrlChr from f_rtvMsgText()
         procedure!
Changed: Replaced external data structures XD* by copy books FD*.
         External data structures are still shipped until 30.06.2005.
Changed: Changed f_val to use self-written code instead of MI function
         cvtefnd(). cvtefnd() crashes when it encounters an invalid
         digit. Usually VAL() functions just stop when they hit an
         invalid character.
Added:   Added procedure f_rmvKeyword(). The procedures removes a keyword
         from a given string. E.g.: DFT('This is a screen constant') is
         translated to 'This is a screen constant'.
Added:   Added procedure f_rmvQuotes(). The procedure removes quotes from
         a given string. E.g. the quotes string 'Programmer''s guide' is
         translated to Programmer's guide.
Added:   Added procedure f_addQuotes(). The procedure adds quotes to
         a given string. E.g. the string Programmer's guide is
         translated to 'Programmer''s guide'.
Added:   Added procedures to manage user spaces:
         f_crtUsrSpc()       - Creates a user space
         f_rtvUsrSpcPtr()    - Retrieves a pointer to the user space.
         f_dltUsrSpc()       - Deletes a user space.
Added:   Added procedures to manage user handles:
         HANDLE_new()        - Creates a new handle.
         HANDLE_null()       - Returns a NULL handle.
         HANDLE_isNull()     - Checks a handle for a NULL value.
         HANDLE_isTypeOf()   - Checks the type of a given handle.
         HANDLE_getPointer() - Retrieves a pointer to the handle data from
                               a given handle.
         HANDLE_delete()     - Deletes a given handle.


Version 1.1:
------------

Procedures with V1.1                           Program:
----------------------------------------       ----------------------------------------
BASICS1R3_f_editCode                           TEST_R3#06
BASICS1R3_f_editWord                           TEST_R3#06
BASICS1R3_f_getLengthEditCode                  TEST_R3#06
BASICS1R3_f_getLengthEditWord                  TEST_R3#06
BASICS1R7_f_log10                              TEST_R7#02 via f_clcLengthOfRPGIntFieldFromBufSize
BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize  TEST_R7#02


Version 1.0:
------------

Procedure:                                     Program:
----------------------------------------       ----------------------------------------
BASICS1R1_p_setAppMsgFile                      TEST_R1#02
BASICS1R1_f_newMsg                             TEST_R1#02
BASICS1R1_f_sndPgmMsg                          TEST_R1#01/TEST_R1#02
BASICS1R1_f_rcvPgmMsg                          TEST_R1#02
BASICS1R1_p_rmvPgmMsg                          TEST_R1#02
BASICS1R1_f_rtvMsgText                         TEST_R1#01
BASICS1R1_f_rtvMsgHelpText                     TEST_R1#01
BASICS1R2_f_newApiErrCode                      all programs using APIs
BASICS1R2_f_isApiError                         BASICS1R6.f_execute() ==> TEST_R6#01
BASICS1R2_f_cvtApiErrCodeToMsg                 BASICS1R6.f_execute() ==> TEST_R6#01
BASICS1R2_f_errno                              TEST_R2#01
BASICS1R2_f_strerror                           TEST_R2#01
BASICS1R3_f_left                               TEST_R3#03
BASICS1R3_f_right                              TEST_R3#03
BASICS1R3_f_space                              TEST_R3#03
BASICS1R3_f_replace                            TEST_R3#04
BASICS1R3_f_lcase                              TEST_R3#05
BASICS1R3_f_ebcdic                             BASICS1R3.f_space()   ==> TEST_R3#03
BASICS1R3_f_val                                TEST_R3#01
BASICS1R3_f_wordWrap                           TEST_R3#02
BASICS1R4_p_assert                             TEST_R4#01
BASICS1R4_f_this                               TEST_R4#01
BASICS1R5_f_exist                              TEST_R5#01 (object)
BASICS1R5_f_exist                              TEST_R5#02 (member)
BASICS1R5_f_getTmpName                         TEST_R5#03
BASICS1R5_f_getUniqueName                      TEST_R5#03
BASICS1R6_f_execute                            TEST_R6#01
BASICS1R7_f_isBitOn                            TEST_R7#01

]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1  type BND - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1   "
mbrtype =  "BND       "
mbrtext =  "Tools/400: Runtime Library                        "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* ====================================================================== */
     /* >>PRE-COMPILER<<                                                       */
     /*                                                                        */
     /*   >>CRTCMD<< CRTSRVPGM    SRVPGM(&LI/&OB);                             */
     /*                                                                        */
     /*   >>COMPILE<<                                                          */
     /*     >>PARM<< MODULE(&LI/BASICS1R1 +                                    */
     /*                     &LI/BASICS1R2 +                                    */
     /*                     &LI/BASICS1R3 +                                    */
     /*                     &LI/BASICS1R4 +                                    */
     /*                     &LI/BASICS1R5 +                                    */
     /*                     &LI/BASICS1R6 +                                    */
     /*                     &LI/BASICS1R7 +                                    */
     /*                     &LI/BASICS1R8 +                                    */
     /*                     &LI/BASICS1R9 +                                    */
     /*                     &LI/BASICS1RA +                                    */
     /*                     &LI/BASICS1RB +                                    */
     /*                     &LI/BASICS1RC +                                    */
     /*                     &LI/BASICS1C7 +                                    */
     /*                     &LI/BASICS1RD +                                    */
     /*                     &LI/BASICS1RE +                                    */
     /*                     &LI/BASICS1RF +                                    */
     /*                     &LI/BASICS1RG +                                    */
     /*                     &LI/BASICS1RH +                                    */
     /*                                );                                      */
     /*     >>PARM<< EXPORT(*SRCFILE);                                         */
     /*     >>PARM<<   SRCFILE(&SL/&SF);                                       */
     /*     >>PARM<<   SRCMBR(&SM);                                            */
     /*     >>PARM<< ACTGRP(*CALLER);                                          */
     /*     >>PARM<< ALWUPD(*YES);                                             */
     /*     >>PARM<< ALWLIBUPD(*YES);                                          */
     /*     >>PARM<< BNDDIR(QC2LE);                                            */
     /*     >>PARM<< TEXT('Tools/400 - Runtime Library');                      */
     /*     >>PARM<< TGTRLS(V6R1M0);                                           */
     /*     >>PARM<< DETAIL(*BASIC);                                           */
     /*   >>END-COMPILE<<                                                      */
     /*                                                                        */
     /*   >>LINK<<                                                             */
     /*   >>END-LINK<<                                                         */
     /*                                                                        */
     /*   >>EXECUTE<<                                                          */
     /*                                                                        */
     /* >>END-PRE-COMPILER<<                                                   */
     /* ====================================================================== */

STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('Version 1.14')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_Display_getMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

  /* --------------------- */
  /*   Added with V1.10    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R3_f_objName')
  EXPORT SYMBOL('BASICS1R5_f_getObjLib')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsgObj')

  /* --------------------- */
  /*   Added with V1.11    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcInitValue')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcInitValue')

  EXPORT SYMBOL('BASICS1R3_f_rplUnPrtChars')
  EXPORT SYMBOL('BASICS1R3_f_formatDate')
  EXPORT SYMBOL('BASICS1R3_f_parseDate')
  EXPORT SYMBOL('BASICS1R3_f_formatMemSize')
  EXPORT SYMBOL('BASICS1R9_Display_supportsDS4')
  EXPORT SYMBOL('BASICS1R9_Display_supportsGUI')
  EXPORT SYMBOL('BASICS1R9_Display_getRows')
  EXPORT SYMBOL('BASICS1R9_Display_getColumns')
  EXPORT SYMBOL('BASICS1R6_p_wait')

  EXPORT SYMBOL('BASICS1RE_f_dateSerial')

  /* --------------------- */
  /*   Added with V1.12    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R8_MemoryManager_getDefaultManager')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_createHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_deleteHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_allocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_reallocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_free')

  /* --------------------- */
  /*   Added with V1.13    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeys')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValues')

  EXPORT SYMBOL('BASICS1R1_f_getSndInfOfRcvMsg')

  EXPORT SYMBOL('BASICS1RE_f_rtvSysVal_char')
  EXPORT SYMBOL('BASICS1RE_f_rtvSysVal_num')

  EXPORT SYMBOL('BASICS1R3_f_cvtPtrToHexString')

  EXPORT SYMBOL('BASICS1RA_BasicList_getHeapID')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getHeapID')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getHeapID')

  EXPORT SYMBOL('BASICS1R3_f_startsWithIgnoreCase')

  /* --------------------- */
  /*   Added with V1.14    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RG_BasicProperties_new')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_loadFromMember')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_loadFromStmf')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_clone')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_containsKey')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_putString')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_putInteger')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_putBoolean')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_putDecimal')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getString')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getInteger')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getBoolean')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getDecimal')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_remove')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getHeapID')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_getNumE')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_clear')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_delete')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_null')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_isNull')
  EXPORT SYMBOL('BASICS1RG_BasicProperties_newKeySet')

  EXPORT SYMBOL('BASICS1R2_f_setErrno')

  EXPORT SYMBOL('BASICS1RH_MemoryWriter_new')
  EXPORT SYMBOL('BASICS1RH_MemoryWriter_write')
  EXPORT SYMBOL('BASICS1RH_MemoryWriter_delete')
  EXPORT SYMBOL('BASICS1RH_MemoryWriter_writeProc')
  EXPORT SYMBOL('BASICS1RH_MemoryReader_new')
  EXPORT SYMBOL('BASICS1RH_MemoryReader_read')
  EXPORT SYMBOL('BASICS1RH_MemoryReader_delete')
  EXPORT SYMBOL('BASICS1RH_MemoryReader_readProc')

  EXPORT SYMBOL('BASICS1RA_BasicList_getTotalSize')

  EXPORT SYMBOL('BASICS1R3_f_mid')

  EXPORT SYMBOL('BASICS1RE_f_cvtEpochTS')
  EXPORT SYMBOL('BASICS1RE_f_cvtTSEpoch')
  EXPORT SYMBOL('BASICS1RE_f_cvtMiTimeTS')
  EXPORT SYMBOL('BASICS1RE_f_cvtTSMiTime')
  EXPORT SYMBOL('BASICS1R5_f_cvtQSYSObjNameToPath')
  EXPORT SYMBOL('BASICS1R5_f_cvtPathToQSYSObjName')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.13')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_Display_getMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

  /* --------------------- */
  /*   Added with V1.10    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R3_f_objName')
  EXPORT SYMBOL('BASICS1R5_f_getObjLib')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsgObj')

  /* --------------------- */
  /*   Added with V1.11    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcInitValue')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcInitValue')

  EXPORT SYMBOL('BASICS1R3_f_rplUnPrtChars')
  EXPORT SYMBOL('BASICS1R3_f_formatDate')
  EXPORT SYMBOL('BASICS1R3_f_parseDate')
  EXPORT SYMBOL('BASICS1R3_f_formatMemSize')
  EXPORT SYMBOL('BASICS1R9_Display_supportsDS4')
  EXPORT SYMBOL('BASICS1R9_Display_supportsGUI')
  EXPORT SYMBOL('BASICS1R9_Display_getRows')
  EXPORT SYMBOL('BASICS1R9_Display_getColumns')
  EXPORT SYMBOL('BASICS1R6_p_wait')

  EXPORT SYMBOL('BASICS1RE_f_dateSerial')

  /* --------------------- */
  /*   Added with V1.12    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R8_MemoryManager_getDefaultManager')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_createHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_deleteHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_allocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_reallocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_free')

  /* --------------------- */
  /*   Added with V1.13    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeys')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValues')

  EXPORT SYMBOL('BASICS1R1_f_getSndInfOfRcvMsg')

  EXPORT SYMBOL('BASICS1RE_f_rtvSysVal_char')
  EXPORT SYMBOL('BASICS1RE_f_rtvSysVal_num')

  EXPORT SYMBOL('BASICS1R3_f_cvtPtrToHexString')

  EXPORT SYMBOL('BASICS1RA_BasicList_getHeapID')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getHeapID')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getHeapID')

  EXPORT SYMBOL('BASICS1R3_f_startsWithIgnoreCase')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.12')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_Display_getMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

  /* --------------------- */
  /*   Added with V1.10    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R3_f_objName')
  EXPORT SYMBOL('BASICS1R5_f_getObjLib')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsgObj')

  /* --------------------- */
  /*   Added with V1.11    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcInitValue')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcInitValue')

  EXPORT SYMBOL('BASICS1R3_f_rplUnPrtChars')
  EXPORT SYMBOL('BASICS1R3_f_formatDate')
  EXPORT SYMBOL('BASICS1R3_f_parseDate')
  EXPORT SYMBOL('BASICS1R3_f_formatMemSize')
  EXPORT SYMBOL('BASICS1R9_Display_supportsDS4')
  EXPORT SYMBOL('BASICS1R9_Display_supportsGUI')
  EXPORT SYMBOL('BASICS1R9_Display_getRows')
  EXPORT SYMBOL('BASICS1R9_Display_getColumns')
  EXPORT SYMBOL('BASICS1R6_p_wait')

  EXPORT SYMBOL('BASICS1RE_f_dateSerial')

  /* --------------------- */
  /*   Added with V1.12    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R8_MemoryManager_getDefaultManager')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_createHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_deleteHeap')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_allocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_reallocate')
  EXPORT SYMBOL('BASICS1R8_MemoryManager_free')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.11')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_Display_getMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

  /* --------------------- */
  /*   Added with V1.10    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R3_f_objName')
  EXPORT SYMBOL('BASICS1R5_f_getObjLib')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsgObj')

  /* --------------------- */
  /*   Added with V1.11    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcSize')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcAutoExt')
  EXPORT SYMBOL('BASICS1R5_f_chgUsrSpcInitValue')
  EXPORT SYMBOL('BASICS1R5_f_getUsrSpcInitValue')

  EXPORT SYMBOL('BASICS1R3_f_rplUnPrtChars')
  EXPORT SYMBOL('BASICS1R3_f_formatDate')
  EXPORT SYMBOL('BASICS1R3_f_parseDate')
  EXPORT SYMBOL('BASICS1R3_f_formatMemSize')
  EXPORT SYMBOL('BASICS1R9_Display_supportsDS4')
  EXPORT SYMBOL('BASICS1R9_Display_supportsGUI')
  EXPORT SYMBOL('BASICS1R9_Display_getRows')
  EXPORT SYMBOL('BASICS1R9_Display_getColumns')
  EXPORT SYMBOL('BASICS1R6_p_wait')

  EXPORT SYMBOL('BASICS1RE_f_dateSerial')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.10')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

  /* --------------------- */
  /*   Added with V1.10    */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1R3_f_objName')
  EXPORT SYMBOL('BASICS1R5_f_getObjLib')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsgObj')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.9')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

  /* --------------------- */
  /*   Added with V1.9     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_clone')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clone')
  EXPORT SYMBOL('BASICS1RC_BasicMap_clone')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.8')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

  /* --------------------- */
  /*   Added with V1.8     */
  /* --------------------- */

  EXPORT SYMBOL('BASICS1RA_BasicList_isSorted')
  EXPORT SYMBOL('BASICS1RA_BasicList_addNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_setNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNullValue')

  EXPORT SYMBOL('BASICS1RC_BasicMap_newKeySet')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getFirst')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_getNext')
  EXPORT SYMBOL('BASICS1RC_BasicKeySet_delete')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.7')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

  /* --------------------- */
  /*   Added with V1.7     */
  /* --------------------- */

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSizeByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putString')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getString')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_endsWith')
  EXPORT SYMBOL('BASICS1RC_BasicMap_putInteger')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getInteger')
  EXPORT SYMBOL('BASICS1R3_f_containsInvalidCharAt')
  EXPORT SYMBOL('BASICS1R3_f_containsStringAt')

  /*   Module: BASICS1RD   */
  EXPORT SYMBOL('BASICS1RD_Url_new')
  EXPORT SYMBOL('BASICS1RD_Url_getProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_setProtocol')
  EXPORT SYMBOL('BASICS1RD_Url_getHost')
  EXPORT SYMBOL('BASICS1RD_Url_setHost')
  EXPORT SYMBOL('BASICS1RD_Url_getPort')
  EXPORT SYMBOL('BASICS1RD_Url_setPort')
  EXPORT SYMBOL('BASICS1RD_Url_getPath')
  EXPORT SYMBOL('BASICS1RD_Url_setPath')
  EXPORT SYMBOL('BASICS1RD_Url_getQuery')
  EXPORT SYMBOL('BASICS1RD_Url_setQuery')
  EXPORT SYMBOL('BASICS1RD_Url_getFile')
  EXPORT SYMBOL('BASICS1RD_Url_setFile')
  EXPORT SYMBOL('BASICS1RD_Url_toString')
  EXPORT SYMBOL('BASICS1RD_Url_getMbr')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.6')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

  /* --------------------- */
  /*   Added with V1.6     */
  /* --------------------- */

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_allocate')
  EXPORT SYMBOL('BASICS1R8_MEMORY_freeAll')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_activateSrvPgm')
  EXPORT SYMBOL('BASICS1R5_f_getProcPtrByName')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_MEMORY_free')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_add')
  EXPORT SYMBOL('BASICS1RA_BasicList_addPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_addString')
  EXPORT SYMBOL('BASICS1RA_BasicList_delete')
  EXPORT SYMBOL('BASICS1RA_BasicList_find')
  EXPORT SYMBOL('BASICS1RA_BasicList_findString')
  EXPORT SYMBOL('BASICS1RA_BasicList_get')
  EXPORT SYMBOL('BASICS1RA_BasicList_getListType')
  EXPORT SYMBOL('BASICS1RA_BasicList_getNumE')
  EXPORT SYMBOL('BASICS1RA_BasicList_getPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_getSize')
  EXPORT SYMBOL('BASICS1RA_BasicList_getString')
  EXPORT SYMBOL('BASICS1RA_BasicList_getType')
  EXPORT SYMBOL('BASICS1RA_BasicList_isNull')
  EXPORT SYMBOL('BASICS1RA_BasicList_isListTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_isTypeOf')
  EXPORT SYMBOL('BASICS1RA_BasicList_new')
  EXPORT SYMBOL('BASICS1RA_BasicList_null')
  EXPORT SYMBOL('BASICS1RA_BasicList_remove')
  EXPORT SYMBOL('BASICS1RA_BasicList_set')
  EXPORT SYMBOL('BASICS1RA_BasicList_setAutoSort')
  EXPORT SYMBOL('BASICS1RA_BasicList_setString')
  EXPORT SYMBOL('BASICS1RA_BasicList_setPointer')
  EXPORT SYMBOL('BASICS1RA_BasicList_sort')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_delete')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getNumE')
  EXPORT SYMBOL('BASICS1RB_BasicStack_getSize')
  EXPORT SYMBOL('BASICS1RB_BasicStack_isNull')
  EXPORT SYMBOL('BASICS1RB_BasicStack_new')
  EXPORT SYMBOL('BASICS1RB_BasicStack_null')
  EXPORT SYMBOL('BASICS1RB_BasicStack_pop')
  EXPORT SYMBOL('BASICS1RB_BasicStack_push')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_containsKey')
  EXPORT SYMBOL('BASICS1RC_BasicMap_delete')
  EXPORT SYMBOL('BASICS1RC_BasicMap_get')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getKeyByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getValueByIndex')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getNumE')
  EXPORT SYMBOL('BASICS1RC_BasicMap_getSize')
  EXPORT SYMBOL('BASICS1RC_BasicMap_isNull')
  EXPORT SYMBOL('BASICS1RC_BasicMap_new')
  EXPORT SYMBOL('BASICS1RC_BasicMap_null')
  EXPORT SYMBOL('BASICS1RC_BasicMap_put')
  EXPORT SYMBOL('BASICS1RC_BasicMap_remove')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_startsWith')

  /*   Module: BASICS1RB   */
  EXPORT SYMBOL('BASICS1RB_BasicStack_peek')
  EXPORT SYMBOL('BASICS1RB_BasicStack_clear')

  /*   Module: BASICS1RA   */
  EXPORT SYMBOL('BASICS1RA_BasicList_clear')

  /*   Module: BASICS1RC   */
  EXPORT SYMBOL('BASICS1RC_BasicMap_clear')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_cvtRcvMsgToMsg')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.5')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

  /* --------------------- */
  /*   Added with V1.5     */
  /* --------------------- */

  /*   Module: BASICS1R9   */
  EXPORT SYMBOL('BASICS1R9_f_getDisplayMode')
  EXPORT SYMBOL('BASICS1R6_f_getNumEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVarByIndex')
  EXPORT SYMBOL('BASICS1R7_f_genCRC32')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.4')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

  /* --------------------- */
  /*   Added with V1.4     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_cvtBufferToHexString')
  EXPORT SYMBOL('BASICS1R3_f_cvtHexStringToBuffer')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_genUUID')
  EXPORT SYMBOL('BASICS1R7_f_genMD5')
  EXPORT SYMBOL('BASICS1R7_f_genSHA1')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_cvtErrnoToMsg')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.3')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

  /* --------------------- */
  /*   Added with V1.3     */
  /* --------------------- */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgTextRaw')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpTextRaw')
  EXPORT SYMBOL('BASICS1R3_f_center')
  EXPORT SYMBOL('BASICS1R3_f_alignR')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmp')
  EXPORT SYMBOL('BASICS1R3_f_genStrCmpIgnCase')
  EXPORT SYMBOL('BASICS1R3_f_scanR')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV    ) SIGNATURE('Version 1.2')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

  /* --------------------- */
  /*   Added with V1.2     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_rmvKeyword')
  EXPORT SYMBOL('BASICS1R3_f_rmvQuotes')
  EXPORT SYMBOL('BASICS1R3_f_addQuotes')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_crtUsrSpc')
  EXPORT SYMBOL('BASICS1R5_f_rtvUsrSpcPtr')
  EXPORT SYMBOL('BASICS1R5_f_dltUsrSpc')

  /*   Module: BASICS1R8   */
  EXPORT SYMBOL('BASICS1R8_HANDLE_new')
  EXPORT SYMBOL('BASICS1R8_HANDLE_null')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isNull')
  EXPORT SYMBOL('BASICS1R8_HANDLE_isTypeOf')
  EXPORT SYMBOL('BASICS1R8_HANDLE_getPointer')
  EXPORT SYMBOL('BASICS1R8_HANDLE_delete')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV) SIGNATURE('Version 1.1')

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

  /* --------------------- */
  /*   Added with V1.1     */
  /* --------------------- */

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_editCode')
  EXPORT SYMBOL('BASICS1R3_f_editWord')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditCode')
  EXPORT SYMBOL('BASICS1R3_f_getLengthEditWord')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_log10')
  EXPORT SYMBOL('BASICS1R7_f_clcLengthOfRPGIntFieldFromBufSize')

ENDPGMEXP

STRPGMEXP PGMLVL(*PRV)    /* Version 1.0 Signature */

  /*   Module: BASICS1R1   */
  EXPORT SYMBOL('BASICS1R1_f_newMsg')
  EXPORT SYMBOL('BASICS1R1_f_rcvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgHelpText')
  EXPORT SYMBOL('BASICS1R1_f_rtvMsgText')
  EXPORT SYMBOL('BASICS1R1_f_sndPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_rmvPgmMsg')
  EXPORT SYMBOL('BASICS1R1_p_setAppMsgFile')

  /*   Module: BASICS1R2   */
  EXPORT SYMBOL('BASICS1R2_f_clrErrno')
  EXPORT SYMBOL('BASICS1R2_f_cvtApiErrCodeToMsg')
  EXPORT SYMBOL('BASICS1R2_f_errno')
  EXPORT SYMBOL('BASICS1R2_f_isApiError')
  EXPORT SYMBOL('BASICS1R2_f_newApiErrCode')
  EXPORT SYMBOL('BASICS1R2_f_strerror')

  /*   Module: BASICS1R3   */
  EXPORT SYMBOL('BASICS1R3_f_ebcdic')
  EXPORT SYMBOL('BASICS1R3_f_left')
  EXPORT SYMBOL('BASICS1R3_f_replace')
  EXPORT SYMBOL('BASICS1R3_f_right')
  EXPORT SYMBOL('BASICS1R3_f_space')
  EXPORT SYMBOL('BASICS1R3_f_lcase')
  EXPORT SYMBOL('BASICS1R3_f_ucase')
  EXPORT SYMBOL('BASICS1R3_f_val')
  EXPORT SYMBOL('BASICS1R3_f_wordWrap')

  /*   Module: BASICS1R4   */
  EXPORT SYMBOL('BASICS1R4_p_assert')
  EXPORT SYMBOL('BASICS1R4_f_this')
  EXPORT SYMBOL('BASICS1R4_f_caller')

  /*   Module: BASICS1R5   */
  EXPORT SYMBOL('BASICS1R5_f_exist')
  EXPORT SYMBOL('BASICS1R5_f_rtvMbrD')
  EXPORT SYMBOL('BASICS1R5_f_rtvObjD')
  EXPORT SYMBOL('BASICS1R5_f_getTmpName')
  EXPORT SYMBOL('BASICS1R5_f_getUniqueName')

  /*   Module: BASICS1R6   */
  EXPORT SYMBOL('BASICS1R6_f_execute')
  EXPORT SYMBOL('BASICS1R6_f_getEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_setEnvVar')
  EXPORT SYMBOL('BASICS1R6_f_delEnvVar')

  /*   Module: BASICS1R7   */
  EXPORT SYMBOL('BASICS1R7_f_isBitOn')

ENDPGMEXP
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1C7  type CLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1C7 "
mbrtype =  "CLE       "
mbrtext =  "SrvPgm: Basic Routines - C-Helpers                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /*=====================================================================*/
     /*  BASICS1C7  - SrvPgm: Basic Routines - C-Helper                     */
     /*=====================================================================*/
     /*  Author  :  Thomas Raddatz                                          */
     /*  Date    :  28.12.2005                                              */
     /*  E-mail  :  thomas.raddatz@tools400.de                              */
     /*  Homepage:  www.tools400.de                                         */
     /*=====================================================================*/
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /*=====================================================================*/
     /*  This module contains code written by Mark Adler.                   */
     /*                                                                     */
     /*     http://www.stillhq.com/gpg/source-1.0.3/zlib/crc32.html         */
     /*                                                                     */
     /*  For conditions of distribution and use, see copyright              */
     /*  notice in zlib.h.                                                  */
     /*=====================================================================*/
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          nderung                                 */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /*=====================================================================*/
     /*    >>PRE-COMPILER<<                                                 */
     /*                                                                     */
     /*      >>CRTCMD<<     CRTCMOD   MODULE(&LI/&OB) +                     */
     /*                               SRCFILE(&SL/&SF) +                    */
     /*                               SRCMBR(&SM);                          */
     /*                                                                     */
     /*      >>COMPILE<<                                                    */
     /*        >>PARM<< OUTPUT(*PRINT);                                     */
     /*        >>PARM<< DBGVIEW(*ALL );                                     */
     /*        >>PARM<< DEFINE(DYNAMIC_CRC_TABLE);                          */
     /*        >>PARM<< OPTIMIZE(40);                                       */
     /*        >>PARM<< TGTRLS(V6R1M0);                                     */
     /*      >>END-COMPILE<<                                                */
     /*                                                                     */
     /*      >>EXECUTE<<                                                    */
     /*                                                                     */
     /*    >>END-PRE-COMPILER<<                                             */
     /*=====================================================================*/
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id: crc32.c,v 1.2 1999/01/13 13:12:48 koch Exp $ */

#include "zlib"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()

  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);

  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;

#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()

#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;


/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;

    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    // crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc; // ^ 0xffffffffL;

]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RA  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RA "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicList                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RA  - SrvPgm: Basic Routines - BasicList                    *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  18.05.2004                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  24.08.2006  Th.Raddatz    Changed BasicList_get() to initialize    *
      *                            only that bytes of the return buffer     *
      *                            that are beyond the length of the list   *
      *                            entry.                                   *
      *                                                                     *
      *  24.04.2008  Th.Raddatz    Enabled BasicList to store NULL data.    *
      *                            Fixed problem that sortList() did not    *
      *                            return cTrue after having sorted the     *
      *                            list.                                    *
      *                            Renamed findEntryByDataPointer() to      *
      *                            findEntryBySignature() in order to       *
      *                            support NULL list entries.               *
      *                            Added procedures:                        *
      *                               BasicList_isSorted()                  *
      *                               BasicList_isNullValue()               *
      *                                                                     *
      *  28.04.2008  Th.Raddatz    Check type of list handle and send an    *
      *                            ESCAPE message for invalid handles.      *
      *                                                                     *
      *  27.05.2008  Th.Raddatz    Added procedure:                         *
      *                               BasicList_clone()                     *
      *                                                                     *
      *  23.03.2012  Th.Raddatz    Added error message 'Failed to allocate  *
      *                            memory' which is sent when the program   *
      *                            could not allocate/reallocate memory.    *
      *                                                                     *
      *  23.03.2012  Th.Raddatz    Changed 'signature_t' to use an epoch    *
      *                            time instead of a RPG timestamp value.   *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RA
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D hList_t         DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  extType                            like(BasicList_type_t  )
     D  memSize                      10U 0
     D  numE                         10U 0
     D  maxNumE                      10U 0
     D  totalMemSize                 10U 0
     D  increment                    10U 0
      /IF NOT DEFINED(*V5R2M0)
     D  signature                          like(signature_t)
     D  sortSignature                      like(signature_t)
      /ELSE
     D  signature                          likeds(signature_t)
     D  sortSignature                      likeds(signature_t)
      /ENDIF
     D  heapID                       10I 0
     D  pBase                          *
     D  pAutoSortFnc                   *   procptr
     D  memMgr                             likeds(MemoryManager_manager_t)
      *
     D listE_t         DS                  qualified   based(pDummy)   align
     D  type                               like(BasicList_type_t  )
     D  size                         10U 0
     D  maxSize                      10U 0
      /IF NOT DEFINED(*V5R2M0)
     D  signature                          like(signature_t)
      /ELSE
     D  signature                          likeds(signature_t)
      /ENDIF
     D  pData                          *
      *
    * *signature_t     DS                  qualified   based(pDummy)   align
    * * tmStmp                         Z
    * * counter                      10U 0
      *
     D signature_t     DS                  qualified   based(pDummy)   align
     D  time                         10U 0
     D  millitm                      10U 0
     D  counter                      10U 0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Produces a new list entry.
     D newEntry...
     D                 PR            10I 0
     D                                            extproc('newEntry')
     D  io_hList                                  likeds(hList_t   )
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Returns a pointer to the basing pointer of the
      *  liste entry.
     D getPointerArrayE...
     D                 PR              *
     D                                            extproc('getPointerArrayE')
     D  i_hList                            const  likeds(hList_t   )
     D  i_index                      10I 0 const
      *
      *  Returns a pointer to the element at the specified
      *  position in this list.
     D getPointerListE...
     D                 PR              *
     D                                            extproc('getPointerListE')
     D  i_hList                            const  likeds(hList_t   )
     D  i_index                      10I 0 const
      *
      *  Frees the memory of a given element in this list.
     D freeEntryData...
     D                 PR
     D                                            extproc('freeEntryData')
     D  io_hList                                  likeds(hList_t   )
     D  io_listE                                  likeds(listE_t   )
      *
      *  Returns TRUE if a given list contains no data.
     D entryData_isNULL...
     D                 PR              N
     D                                            extproc('entryData_isNULL')
     D  i_listE                            const  likeds(listE_t   )
      *
      *  Create a very basic list handle.
     D newListInternal...
     D                 PR              *
     D                                            extproc('newListInternal')
     D  i_extType                          const  like(BasicList_type_t  )
     D  i_increment                  10I 0 const
     D  i_heapID                     10I 0 const
     D  i_memMgr                           const  likeds(MemoryManager...
     D                                                   _manager_t)
      *
      *  Set the entry data.
     D setEntryData...
     D                 PR            10I 0
     D                                            extproc('setEntryData')
     D  io_hList                                  likeds(hList_t  )
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const
     D  i_length                     10I 0 const
      *
      *  Checks the range of the list index.
     D isIndexOutOfRange...
     D                 PR              N
     D                                            extproc('isIndexOutOfRange')
     D  i_hList                            const  likeds(hList_t  )
     D  i_index                      10I 0 const
      *
      *  Sorts a given list.
     D qsortCallback...
     D                 PR            10I 0
     D                                            extproc('qsortCallback')
     D  i_pKey                         *   value
     D  i_pElement                     *   value
      *
      *  Sorts the list if it is required and if an auto-sort procedure
      *  has been specified.
     D performAutoSort...
     D                 PR              N
     D                                            extproc('performAutoSort')
     D  io_hList                                  likeds(hList_t  )
      *
      *  Sorts the list.
     D sortList...
     D                 PR              N
     D                                            extproc('sortList')
     D  io_hList                                  likeds(hList_t  )
     D  i_pSortFnc                     *   const  procptr
      *
      *  Returns cTrue for a sorted list, else cFalse.                                       R
     D isSortedInternally...
     D                 PR              N
     D                                            extproc('isSortedInternally')
     D  i_hList                            const  likeds(hList_t  )
      *
      *  Searches the list for an entry that matches the specified data pointer
     D findEntryBySignature...
     D                 PR            10I 0
     D                                            extproc('+
     D                                            findEntryBySignature')
     D  i_hList                            const  likeds(hList_t    )
     D  i_signature                        const  likeds(signature_t)
      *
      *  Returns a new list signature.
     D Signature_new...
     D                 PR                         likeds(signature_t )
     D                                            extproc('Signature_new')
      *
      *  Checks, whether a given handle is a valid list handle, or not.
     D checkListHandle...
     D                 PR
     D                                            extproc('checkListHandle')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Sends a DIAG message to signal a problem.
     D signalProblem...
     D                 PR
     D                                            extproc('signalProblem')
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Sends an ESCAPE message to signal an error condition.
     D signalError...
     D                 PR
     D                                            extproc('signalError')
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D cHANDLE_TYPE_LIST...
     D                 C                   const(6688841203191988545)           =  *List
     D cHANDLE_SIZE...
     D                 C                   const(%size(hList_t))
      *
     D cERROR_LIST_HANDLE_NULL...
     D                 C                   const('List handle is NULL')
     D cERROR_LIST_HANDLE_INVALID...
     D                 C                   const('List handle is invalid')
     D cERROR_NO_MEMORY...
     D                 C                   const('Failed to allocate/+
     D                                            reallocate memory')
     D cPROBLEM_LIST_FULL...
     D                 C                   const('Maximum number of +
     D                                            list items reached')
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
     D g_pSortFnc      S               *   inz procptr
      *
      *  Prototype of the external sort function. A procedure pointer
      *  of a function that matches this prototype must be passed to
      *  BasicList_sort().
      *
      *     Return Value          Meaning
      *     ---------------       -------------------------
      *     Less than 0           key less than element
      *     0                     key equal to element
      *     Greater than 0        key greater than element
      *
     D sortFnc...
     D                 PR            10I 0
     D                                     extproc(g_pSortFnc)
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *=========================================================================
      *  Creates a new BasicList.
      *=========================================================================
      *  Parameters:
      *   i_extType     - The type of the list.
      *   i_increment   - The number of empty elements that are added to the
      *                   list when the list needs to be resized.
      *   i_memMgr      - The memory manager to use.
      *
      *  Returns:
      *   pList         - Returns the basing pointer of the list on
      *                   success, else NULL.
      *=========================================================================
     P BasicList_new...
     P                 B                   export
      *
     D BasicList_new...
     D                 PI                         like(BasicList_handle_t)
     D  i_extType                          const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D pList           S                   like(BasicList_handle_t) inz
      *
      *  Parameter positions
     D p_extType       C                   const(1)
     D p_increment     C                   const(2)
     D p_heapID        C                   const(3)
      *
      *  Fields for optional parameters
     D extType         S                   like(i_extType   ) inz
     D increment       S                   like(i_increment ) inz
     D heapID          S                   like(i_heapID    ) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
      *
      *  House keeping:
      *     List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get values of optional parameters
         // ... i_extType
         if %parms() >= p_extType;
            CEETSTA(isPresent: p_extType: *omit);
         else;
            isPresent = 0;
         endif;

         if isPresent = 1;
            extType = i_extType;
         else;
            extType = '';
         endif;

         // ... i_increment
         if %parms() >= p_increment;
            CEETSTA(isPresent: p_increment: *omit);
         else;
            isPresent = 0;
         endif;

         if isPresent = 1;
            increment = i_increment;
         else;
            increment = 256;
         endif;

         // ... i_heapID
         if %parms() >= p_heapID;
            CEETSTA(isPresent: p_heapID: *omit);
         else;
            isPresent = 0;
         endif;

         if isPresent = 1;
            heapID = i_heapID;
         else;
            heapID = 0;
         endif;

         // Set memory manager
         mm_memMgr = MemoryManager_getDefaultManager();

         // Initialize house keeping fields
         pHList = *NULL;

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Create a very basic list
            pHList = newListInternal(extType: increment: heapID: mm_memMgr);

            // Ready
            isDone = cTrue;
         enddo;

         // Error!
         if isError;
            // Free memory of list handle
            if pHList <> *NULL;
               mm_free(pHList);
               pHList = *NULL;
            endif;
         endif;

         // Set return value
         if isDone;
            pList = pHList;
         else;
            pList = BasicList_null();
         endif;

         return pList;

      /END-FREE
      *
     P BasicList_new...
     P                 E
      *
      *=========================================================================
      *  Clones a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   pList         - Returns the basing pointer of the cloned list on
      *                   success, else NULL.
      *=========================================================================
     P BasicList_clone...
     P                 B                   export
      *
     D BasicList_clone...
     D                 PI                         like(BasicList_handle_t)
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D pListRtn        S                   like(BasicList_handle_t) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D x               S             10I 0 inz
     D numE            S             10I 0 inz
     D size            S             10I 0 inz
     D pData           S               *   inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  House keeping:
      *     List handle
     D pTmpList        S                   like(BasicList_handle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         pListRtn = BasicList_null();

         // Initialize house keeping fields
         pTmpList = BasicList_null();

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = i_pList;

            // Create a new and empty list
            pTmpList = BasicList_new(hList.extType: hList.increment);
            if (BasicList_isNull(pTmpList));
               isError = cTrue;
               leave;
            endif;

            // Copy list entries
            numE = BasicList_getNumE(i_pList);
            for x = 1 to numE;
               if (BasicList_isNullValue(i_pList: x));
                  BasicList_addNull(pTmpList);
               else;
                  size  = BasicList_getSize(i_pList: x);
                  pData = BasicList_get(i_pList: x);
                  BasicList_add(pTmpList: pData: size);
               endif;
            endfor;

            // Set return value
            pListRtn = pTmpList;
            pTmpList = BasicList_null();

            // Done.
            isDone = cTrue;
         enddo;

         // House keeping ...
         // ... pTmpList
         if (not BasicList_isNull(pTmpList));
            BasicList_delete(pTmpList);
         endif;

         return pListRtn;

      /END-FREE
      *
     P BasicList_clone...
     P                 E
      *
      *=========================================================================
      *  Returns a given element.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *   i_pEntry      - Address where to copy the entry data to.
      *                   If this parameter is not passed, the address
      *                   of the list entry data is returned. Hence
      *                   you gain direct access to the list entry data!
      *   i_length      - The maximum size of the entry data.
      *
      *  Returns:
      *   pEntry        - Returns a pointer to the entry data on
      *                   success, else NULL.
      *=========================================================================
     P BasicList_get...
     P                 B                   export
      *
     D BasicList_get...
     D                 PI              *
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D pElemData       S               *   inz
      *
      *  Parameter positions
     D p_pEntry        C                   const(3)
     D p_length        C                   const(4)
      *
      *  Fields for optional parameters
     D pEntry          S                   like(i_pEntry     ) inz
     D length          S                   like(i_length     ) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D maxSize         S             10I 0 inz
     D numRemBytes     S             10I 0 inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  List entry
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get values of optional parameters
         // ... pEntry
         p_assert(%parms() <> p_pEntry
                  : 'length must be specified if pEntry is passed');

         // ... length
         if %parms() >= p_length;
            pEntry = i_pEntry;
            length = i_length;
         else;
            pEntry = *NULL;
            length = 0;
         endif;

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = i_pList;

            // Verify range of i_index
            if isIndexOutOfRange(hList: i_index);
               isError = cTrue;
               leave;
            endif;

            // Get access to entry data
            pListE = getPointerListE(hList: i_index);

            // Determine number of bytes to copy
            if length < listE.size;
               maxSize = length;
            else;
               maxSize = listE.size;
            endif;

            // Initialize return buffer (remaining bytes only)
            numRemBytes = length - listE.size;
            if numRemBytes > 0;
               memset((pEntry + listE.size): x'00': numRemBytes);
            endif;

            // Copy entry data
            if maxSize > 0;
               memcpy(pEntry: listE.pData: maxSize);
               pElemData = pEntry;
            else;
               pElemData = listE.pData;
            endif;

            // Done.
            isDone = cTrue;
         enddo;

         return pElemData;

      /END-FREE
      *
     P BasicList_get...
     P                 E
      *
      *=========================================================================
      *  Returns a given string.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   string        - Returns a string on success, else ''.
      *=========================================================================
     P BasicList_getString...
     P                 B                   export
      *
     D BasicList_getString...
     D                 PI          4096A          varying
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D string          S           4096A   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         BasicList_get(i_pList: i_index: %addr(string): %size(string));

         return string;

      /END-FREE
      *
     P BasicList_getString...
     P                 E
      *
      *=========================================================================
      *  Returns a the pointer element from the specified position.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   pointer       - Returns a pointer on success, else *NULL.
      *=========================================================================
     P BasicList_getPointer...
     P                 B                   export
      *
     D BasicList_getPointer...
     D                 PI              *
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D pointer         S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         BasicList_get(i_pList: i_index: %addr(pointer): %size(pointer));

         return pointer;

      /END-FREE
      *
     P BasicList_getPointer...
     P                 E
      *
      *=========================================================================
      *  Returns the external type of the list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   type          - Returns the list type on success, else '';
      *=========================================================================
     P BasicList_getListType...
     P                 B                   export
      *
     D BasicList_getListType...
     D                 PI                         like(BasicList_type_t  )
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D type            S                   like(BasicList_type_t  ) inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         type = hList.extType;

         return type;

      /END-FREE
      *
     P BasicList_getListType...
     P                 E
      *
      *=========================================================================
      *  Checks the list for a given external type.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_type        - The type of the list.
      *
      *  Returns:
      *   isOfType      - Returns TRUE if the list matches the specified type,
      *                   else, FALSE.
      *=========================================================================
     P BasicList_isListTypeOf...
     P                 B                   export
      *
     D BasicList_isListTypeOf...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Return value
     D isValid         S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         if i_type = hList.extType;
            isValid  = cTrue;
         else;
            isValid  = cFalse;
         endif;

         return isValid;

      /END-FREE
      *
     P BasicList_isListTypeOf...
     P                 E
      *
      *=========================================================================
      *  Checks an list entry for a given type.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *   i_type        - The type of the list.
      *
      *  Returns:
      *   isOfType      - Returns TRUE if the list matches the specified type,
      *                   else, FALSE.
      *=========================================================================
     P BasicList_isTypeOf...
     P                 B                   export
      *
     D BasicList_isTypeOf...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Return value
     D isValid         S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         // Verify range of i_index
         if isIndexOutOfRange(hList: i_index);
            isValid = cFalse;
            return isValid;
         endif;

         // Get access to entry data
         pListE = getPointerListE(hList: i_index);

         // Verify entry type
         if listE.type = i_type;
            isvalid = cTrue;
         else;
            isvalid = cFalse;
         endif;

         return isValid;

      /END-FREE
      *
     P BasicList_isTypeOf...
     P                 E
      *
      *=========================================================================
      *  Returns the type of the specified list entry.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   type          - Returns the type on success, else ''.
      *=========================================================================
     P BasicList_getType...
     P                 B                   export
      *
     D BasicList_getType...
     D                 PI                         like(BasicList_type_t  )
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D type            S                   like(BasicList_type_t  ) inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         // Verify range of i_index
         if isIndexOutOfRange(hList: i_index);
            type = '';
            return type;
         endif;

         // Get access to entry data
         pListE = getPointerListE(hList: i_index);

         // Return entry type
         type = listE.type;

         return type;

      /END-FREE
      *
     P BasicList_getType...
     P                 E
      *
      *=========================================================================
      *  Returns the size of of an element.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   size          - Returns the size of the element on success, else -1.
      *=========================================================================
     P BasicList_getSize...
     P                 B                   export
      *
     D BasicList_getSize...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  List entry
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = i_pList;

            // Verify range of i_index
            if isIndexOutOfRange(hList: i_index);
               isError = cTrue;
               leave;
            endif;

            // Get access to entry data
            pListE = getPointerListE(hList: i_index);

            // Ready
            isDone = cTrue;
         enddo;

         // Set return value
         if isDone;
            size = listE.size;
         else;
            size = -1;
         endif;

         return size;

      /END-FREE
      *
     P BasicList_getSize...
     P                 E
      *
      *=========================================================================
      *  Adds a element to a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_pEntry      - The entry to be added to this list.
      *   i_length      - Optional. The size of the entry data.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_add...
     P                 B                   export
      *
     D BasicList_add...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass: *omit)
     D  i_type                             const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_length        C                   const(3)
     D p_type          C                   const(4)
      *
      *  Fields for optional parameters
     D length          S                   like(i_length     ) inz
     D type            S                   like(i_type       ) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D x               S             10U 0 inz
     D pEntryData      S               *   inz
     D prvListSortSignature...
     D                 DS                  likeds(signature_t) inz
     D entrySignature  DS                  likeds(signature_t) inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get length of entry data
            if %parms() >= p_length;
               CEETSTA(isPresent: p_length: *omit);
            else;
               isPresent = 0;
            endif;

            if isPresent = 1;
               length = i_length;
            else;
               if i_pEntry = *NULL;
                  length = 0;
               else;
                  length = strlen(i_pEntry);
               endif;
            endif;

            // Get type of entry data
            if %parms() >= p_type;
               CEETSTA(isPresent: p_type: *omit);
            else;
               isPresent = 0;
            endif;

            if isPresent = 1;
               type = i_type;
            else;
               type = cBASICLIST_TYPE_UNKNOWN;
            endif;

            // Get access to list handle
            pHList = i_pList;

            // Produce new entry
            x = newEntry(hList: type);
            if x = 0;
               isError = cTrue;
               leave;
            endif;

            // Get access to entry data
            pListE = getPointerListE(hList: x);

            // Set entry data
            setEntryData(hList: x: i_pEntry: length);

            // Save pointer to entry signature
            entrySignature = listE.signature;

            // Sort list, if required
            prvListSortSignature = hList.sortSignature;
            performAutoSort(hList);

            // Find entry using its signature if the list
            // had been sorted.
            if (prvListSortSignature <> hList.sortSignature);
               x = findEntryBySignature(hList: entrySignature);
            endif;

            // Ready
            isDone = cTrue;
         enddo;

         // Set return value
         if isDone;
            index = x;
         else;
            index = -1;
         endif;

         return index;

      /END-FREE
      *
     P BasicList_add...
     P                 E
      *
      *=========================================================================
      *  Adds a string to a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_string      - The string to be added to this list.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_addString...
     P                 B                   export
      *
     D BasicList_addString...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_string                   4096A   const  varying
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Helper fields
     D string          S                   like(i_string) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string = i_string;

         index = BasicList_add(i_pList: %addr(string)
                                      : %len(i_string) + 2
                                      : cBASICLIST_TYPE_VSTRING);

         return index;

      /END-FREE
      *
     P BasicList_addString...
     P                 E
      *
      *=========================================================================
      *  Adds a pointer to a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_pointer     - The pointer to be added to this list.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_addPointer...
     P                 B                   export
      *
     D BasicList_addPointer...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pointer                      *   const
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Helper fields
     D pointer         S                   like(i_pointer) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pointer = i_pointer;

         index = BasicList_add(i_pList: %addr(pointer)
                                      : %size(pointer)
                                      : cBASICLIST_TYPE_POINTER);

         return index;

      /END-FREE
      *
     P BasicList_addPointer...
     P                 E
      *
      *=========================================================================
      *  Adds a NULL value to a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_addNull...
     P                 B                   export
      *
     D BasicList_addNull...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         index = BasicList_add(i_pList: *NULL);

         return index;

      /END-FREE
      *
     P BasicList_addNull...
     P                 E
      *
      *=========================================================================
      *  Searches the list for a given element.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_pEntry      - The entry to be added to this list.
      *   i_length      - Optional. The size of the entry data.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_find...
     P                 B                   export
      *
     D BasicList_find...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D length          S                   like(i_length     ) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D ignoreCase      S               N   inz(cFalse)
     D x               S             10U 0 inz
     D rc              S             10I 0 inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get length of entry data
            if %parms() >= p_length;
               length = i_length;
            else;
               length = strlen(i_pEntry);
            endif;

            // Get access to list handle
            pHList = i_pList;

            // Spin through entries in list searching for the request element
            for x = 1 to hList.numE;

               // Get access to entry data
               pListE = getPointerListE(hList: x);

               // Compare entry attributes
               if (length = listE.size);
                  if ignoreCase;
                     rc = memicmp(i_pEntry: listE.pData: length);
                  else;
                     rc = memcmp(i_pEntry: listE.pData: length);
                  endif;
               else;
                  rc = -1;
               endif;

               if rc = 0;
                  index = x;
                  leave;
               endif;

            endfor;

            // Ready
            isDone = cTrue;
         enddo;

         return index;

      /END-FREE
      *
     P BasicList_find...
     P                 E
      *
      *=========================================================================
      *  Searches the list for a given string.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_string      - The string to be added to this list.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_findString...
     P                 B                   export
      *
     D BasicList_findString...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_string                   4096A   const  varying
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D x               S             10U 0                inz
     D string          S                   like(i_string) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string = i_string;

         index = BasicList_find(i_pList: %addr(string): %len(i_string) + 2);

         return index;

      /END-FREE
      *
     P BasicList_findString...
     P                 E
      *
      *=========================================================================
      *  Changes the element at the specified position in this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *   i_pEntry      - The entry to be added to this list.
      *   i_length      - Optional. The size of the entry data.
      *
      *  Returns:
      *   length        - Returns the length of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_set...
     P                 B                   export
      *
     D BasicList_set...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass: *omit)
     D  i_type                             const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D newLength       S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_length        C                   const(4)
     D p_type          C                   const(5)
      *
      *  Fields for optional parameters
     D length          S                   like(i_length     ) inz
     D type            S                   like(i_type       ) inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
      *
      *  Handle Data
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get length of entry data
            if %parms() >= p_length;
               CEETSTA(isPresent: p_length: *omit);
            else;
               isPresent = 0;
            endif;

            if isPresent = 1;
               length = i_length;
            else;
               if i_pEntry = *NULL;
                  length = 0;
               else;
                  length = strlen(i_pEntry);
               endif;
            endif;

            // Get type of entry data
            if %parms() >= p_type;
               CEETSTA(isPresent: p_type: *omit);
            else;
               isPresent = 0;
            endif;

            if isPresent = 1;
               type = i_type;
            else;
               type = cBASICLIST_TYPE_UNKNOWN;
            endif;

            // Get access to list handle
            pHList = i_pList;

            // Set entry data
            newLength = setEntryData(hList: i_index: i_pEntry: length);

            // Sort list, if required
            performAutoSort(hList);

            // Ready
            isDone = cTrue;
         enddo;

         return newLength;

      /END-FREE
      *
     P BasicList_set...
     P                 E
      *
      *=========================================================================
      *  Changes the element at the specified position to NULL.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   length        - Returns the length (always 0) of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_setNull...
     P                 B                   export
      *
     D BasicList_setNull...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D newLength       S             10I 0 inz(-1)
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         newLength = BasicList_set(i_pList: i_index: *NULL);

         return newLength;

      /END-FREE
      *
     P BasicList_setNull...
     P                 E
      *
      *=========================================================================
      *  Changes the string at the specified position in this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *   i_string      - The string that is changed.
      *
      *  Returns:
      *   length        - Returns the length of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_setString...
     P                 B                   export
      *
     D BasicList_setString...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_string                   4096A   const  varying
      *
      *  Return value
     D newLength       S             10I 0 inz(-1)
      *
      *  Helper fields
     D string          S                   like(i_string) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string = i_string;

         newLength = BasicList_set(i_pList: i_index
                                          : %addr(string)
                                          : %len(i_string) + 2
                                          : cBASICLIST_TYPE_VSTRING);

         return newLength;

      /END-FREE
      *
     P BasicList_setString...
     P                 E
      *
      *=========================================================================
      *  Changes the pointer at the specified position in this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *   i_pointer     - The pointer that is changed.
      *
      *  Returns:
      *   length        - Returns the length of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicList_setPointer...
     P                 B                   export
      *
     D BasicList_setPointer...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pointer                      *   const
      *
      *  Return value
     D newLength       S             10I 0 inz(-1)
      *
      *  Helper fields
     D pointer         S                   like(i_pointer) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pointer = i_pointer;

         newLength = BasicList_set(i_pList: i_index
                                          : %addr(pointer)
                                          : %size(pointer)
                                          : cBASICLIST_TYPE_POINTER);

         return newLength;

      /END-FREE
      *
     P BasicList_setPointer...
     P                 E
      *
      *=========================================================================
      *  Removes the element at the specified position in this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Index of a given list element.
      *
      *  Returns:
      *   rc            - Returns 0 success, else -1.
      *=========================================================================
     P BasicList_remove...
     P                 B                   export
      *
     D BasicList_remove...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D pTarget         S               *   inz
     D pSource         S               *   inz
     D size            S             10U 0 inz
     D curIndex        S             10U 0 inz
     D numDeletedE     S             10U 0 inz
      *
     D range           DS                  qualified
     D  from                         10U 0 inz
     D  to                           10U 0 inz
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  List entry
     D listE           DS                  likeds(listE_t    ) based(pListE)
     D pListE          S               *   based(ppListE)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Set memory manager
         mm_memMgr = MemoryManager_getDefaultManager();

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = i_pList;

            // Return to caller if there are no entries in this list
            if hList.numE = 0;
               isDone = cTrue;
               leave;
            endif;

            // Determine the range of elements to remove
            if i_index = cBASICLIST_REMOVE_ALL;
               range.from = 1;
               range.to   = hList.numE;
            else;
               range.from = i_index;
               range.to   = i_index;
            endif;

            // Remove all entries within the specified range:
            numDeletedE = 0;

            for curIndex = range.from to range.to;

               // Increment number of removed entries
               numDeletedE = numDeletedE + 1;

               // Get access to entry data
               ppListE = getPointerArrayE(hList: curIndex);

               // Free entry data:
               if (pListE <> *NULL);
                  if not entryData_isNULL(listE);
                     clear listE.signature;
                     freeEntryData(hList: listE);
                  endif;

                  mm_free(pListE);
                  ppListE = *NULL;

                  hList.totalMemSize = hList.totalMemSize + %size(listE_t);
               endif;

            endfor;

            // If it was not the last entry that was removed
            // from the list, ...
            if range.to < hList.numE;

               // ... then shifts any subsequent elements to the left
               pTarget = getPointerArrayE(hList: range.from);
               pSource = getPointerArrayE(hList: range.to + 1);
               size    = (hList.numE - range.from) * %size(pDummy);
               memmove(pTarget: pSource: size);

            endif;

            // Compute number of elements remaining in this list
            hList.numE = hList.numE - numDeletedE;

            // Set new signature
            hList.signature = Signature_new();

            // Initialize freed memory
            pSource = getPointerArrayE(hList: hList.numE + 1);
            size    = numDeletedE * %size(pDummy);
            memset(pSource: x'00': size);

            // We just removed an element from the list.
            // Hence we do not need to sort the list again.
            hList.sortSignature = hList.signature;

            // Done.
            isDone = cTrue;
         enddo;

         // Set return value
         if isDone;
            rc = 0;
         else;
            rc = -1;
         endif;

         return rc;

      /END-FREE
      *
     P BasicList_remove...
     P                 E
      *
      *=========================================================================
      *  Returns the number of elements in this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   size          - Returns the number of elements in this list on
      *                   success, else -1.
      *=========================================================================
     P BasicList_getNumE...
     P                 B                   export
      *
     D BasicList_getNumE...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D numE            S             10I 0 inz(-1)
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = i_pList;

            // Ready
            isDone = cTrue;
         enddo;

         // Set return value
         if isDone;
            numE = hList.numE;
         else;
            numE = -1;
         endif;

         return numE;

      /END-FREE
      *
     P BasicList_getNumE...
     P                 E
      *
      *=========================================================================
      *  Returns the heap ID of a given BasicList.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   heapID        - ID of the heap this BasicList belongs to.
      *=========================================================================
     P BasicList_getHeapID...
     P                 B                   export
      *
     D BasicList_getHeapID...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D heapID          S             10I 0 inz(-1)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         heapID = hList.heapID;

         return heapID;

      /END-FREE
      *
     P BasicList_getHeapID...
     P                 E
      *
      *=========================================================================
      *  Sorts a list using the specified sort function.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_pSortFnc    - Procedure pointer of sort procedure.
      *
      *  Returns:
      *   isSorted      - Returns TRUE on success, else FALSE.
      *=========================================================================
     P BasicList_sort...
     P                 B                   export
      *
     D BasicList_sort...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pSortFnc                     *   const  procptr
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         // Sort the list.
         isSorted = sortList(hList: i_pSortFnc);

         return isSorted;

      /END-FREE
      *
     P BasicList_sort...
     P                 E
      *
      *=========================================================================
      *  Returns cTrue if a given list is sorted.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   isSorted      - Returns TRUE if the list is sorted, else cFalse.
      *=========================================================================
     P BasicList_isSorted...
     P                 B                   export
      *
     D BasicList_isSorted...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         return isSortedInternally(hList);

      /END-FREE
      *
     P BasicList_isSorted...
     P                 E
      *
      *=========================================================================
      *  Specifies an auto-sort function for this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_pSortFnc    - Procedure pointer of sort procedure.
      *
      *  Returns:
      *   isSet         - Returns TRUE on success, else FALSE.
      *=========================================================================
     P BasicList_setAutoSort...
     P                 B                   export
      *
     D BasicList_setAutoSort...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pSortFnc                     *   const  procptr
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         // Set auto-sort procedure address
         hList.pAutoSortFnc = i_pSortFnc;

         // Sort list
         if performAutoSort(hList);
            isSet = cTrue;
         else;
            isSet = cFalse;
         endif;

         return isSet;

      /END-FREE
      *
     P BasicList_setAutoSort...
     P                 E
      *
      *=========================================================================
      *  Removes all entries from a given list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicList_clear...
     P                 B                   export
      *
     D BasicList_clear...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Return to caller if there are no entries in this list
         if BasicList_getNumE(i_pList) = 0;
            rc = 0;
         else;
            // Remove all entries from the list
            rc = BasicList_remove(i_pList: cBASICLIST_REMOVE_ALL);
         endif;

         return rc;

      /END-FREE
      *
     P BasicList_clear...
     P                 E
      *
      *=========================================================================
      *  Returns the total size of memory used by this list.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   totalSize     - Returns the total size of memory used by the list.
      *=========================================================================
     P BasicList_getTotalSize...
     P                 B                   export
      *
     D BasicList_getTotalSize...
     D                 PI            20I 0
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D totalSize       S             20I 0 inz(-1)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(i_pList);

         // Get access to list handle
         pHList = i_pList;

         // Set return value
         totalSize = hList.totalMemSize;

         return totalSize;

      /END-FREE
      *
     P BasicList_getTotalSize...
     P                 E
      *
      *=========================================================================
      *  Deletes a given BasicList.
      *=========================================================================
      *  Parameters:
      *   io_pList      - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicList_delete...
     P                 B                   export
      *
     D BasicList_delete...
     D                 PI            10I 0
     D  io_pList                                  like(BasicList_handle_t)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkListHandle(io_pList);

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Get access to list handle
            pHList = io_pList;

            // Set memory manager
            mm_memMgr = hList.memMgr;

            // Free all list entries
            dow hList.numE > 0;
               BasicList_remove(io_pList: hList.numE);
            enddo;

            p_assert(hList.numE = 0);

            // Free memory of list handle
            if hList.pBase <> *NULL;
               hList.totalMemSize = hList.totalMemSize - hList.memSize;
               mm_free(hList.pBase);
               hList.memSize = 0;
            endif;

            p_assert(hList.pBase = *NULL);

            // Clear handle data
            clear hList;
            hList.intType       = 0;
            hList.intSize       = 0;
            hList.extType       = *ALLx'00';
            hList.memSize       = 0;
            hList.numE          = 0;
            hList.maxNumE       = 0;
            hList.totalMemSize  = 0;
            hList.increment     = 0;
            hList.signature     = Signature_new();
            hList.sortSignature = hList.signature;
            hList.pBase         = *NULL;
            hList.pAutoSortFnc  = *NULL;

            // Free memory of list handle
            mm_free(pHList);

            // Ready
            isDone = cTrue;
         enddo;

         // Set return parameter value
         if isDone;
            io_pList = BasicList_null();
         endif;

         // Set return value
         if isDone;
            rc = 0;
         else;
            rc = -1;
         endif;

         return rc;

      /END-FREE
      *
     P BasicList_delete...
     P                 E
      *
      *=========================================================================
      *  Returns a BasicList NULL handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pList         - NULL handle of a BasicList.
      *=========================================================================
     P BasicList_null...
     P                 B                   export
      *
     D BasicList_null...
     D                 PI                         like(BasicList_handle_t)
      *
      *  Return value
     D pList           S                   like(BasicList_handle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pList = *NULL;

         return pList;

      /END-FREE
      *
     P BasicList_null...
     P                 E
      *
      *=========================================================================
      *  Checks a given BasicList handle for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *
      *  Returns:
      *   isNull        - Returns TRUE if the handle is null, else FALSE.
      *=========================================================================
     P BasicList_isNull...
     P                 B                   export
      *
     D BasicList_isNull...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Return value
     D isNull          S               N   inz(cTrue)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if i_pList = BasicList_null();
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return isNull;

      /END-FREE
      *
     P BasicList_isNull...
     P                 E
      *
      *=========================================================================
      *  Checks a given BasicList entry for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the list returned by BasicList_new().
      *   i_index       - Position of the element.
      *
      *  Returns:
      *   isNull        - Returns TRUE if the liste entry is null, else FALSE.
      *=========================================================================
     P BasicList_isNullValue...
     P                 B                   export
      *
     D BasicList_isNullValue...
     D                 PI              N
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Return value
     D isNull          S               N   inz(cTrue)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  List entry
     D listE           DS                  likeds(listE_t    ) based(pListE)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get access to list handle
         pHList = i_pList;

         // Verify range of i_index
         if isIndexOutOfRange(hList: i_index);
            p_assert(cFalse:
                     'Index value (' + %char(i_index) + ') is out of range');
         endif;

         // Get access to entry data
         pListE = getPointerListE(hList: i_index);

         if (listE.pData = *NULL);
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return isNull;

      /END-FREE
      *
     P BasicList_isNullValue...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Produces a new list entry.
      *=========================================================================
     P newEntry...
     P                 B
      *
     D newEntry...
     D                 PI            10I 0
     D  i_hList                                   likeds(hList_t   )
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Return value
     D index           S             10I 0 inz
      *
      *  Loop control
     D isDone          S               N   inz(cFalse)
     D isError         S               N   inz(cFalse)
      *
      *  Helper fields
     D newMemSize      S                   like(hList_t.memSize) inz
     D listE           DS                  likeds(listE_t      ) based(pListE)
     D pListE          S               *   based(ppListE)
      *
      *  Maximum size for a non-Teraspace malloc()
     D MAX_MEM_SIZE    C                   16711568
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Do until everything is done or an error occured
         dou isDone or isError;

            // Set memory manager
            mm_memMgr = i_hList.memMgr;

            // If the there are no more free entries in this list, ...
            if i_hList.maxNumE = i_hList.numE;

               // ... then check amout of used memory and
               if i_hList.memSize >= MAX_MEM_SIZE;
                  signalError(cPROBLEM_LIST_FULL: f_caller());
                  // signalProblem(cPROBLEM_LIST_FULL: f_caller());
                  // signalProblem(
                  //       '#list items: ' +
                  //        %char(i_hList.maxNumE): f_caller());
                  // signalProblem(
                  //       '#total size of memory: ' +
                  //        %char(i_hList.totalMemSize): f_caller());
                  // return 0;
               endif;

               // ... (re)allocate additional memory
               newMemSize = i_hList.memSize +
                            (%size(pDummy) * i_hList.increment);

               if (newMemSize > MAX_MEM_SIZE);
                  newMemSize =
                        %div(MAX_MEM_SIZE: %size(pDummy)) * %size(pDummy);
               endif;

               if i_hList.pBase = *NULL;
                  i_hList.pBase = mm_allocate(newMemSize: i_hList.heapID);
               else;
                  i_hList.pBase = mm_reallocate(i_hList.pBase: newMemSize);
               endif;

               if i_hList.pBase = *NULL;
                  signalError(cERROR_NO_MEMORY: f_caller());
               endif;

               i_hList.totalMemSize = i_hList.totalMemSize - i_hList.memSize;

               i_hList.memSize      = newMemSize;
               i_hList.maxNumE      = i_hList.memSize / %size(pDummy);

               i_hList.totalMemSize = i_hList.totalMemSize + i_hList.memSize;
            endif;

            // Increment number of entries in this list
            i_hList.numE = i_hList.numE + 1;

            // Set new signature
            i_hList.signature = Signature_new();

            // Create liste entry
            ppListE = getPointerArrayE(i_hList: i_hList.numE);
            pListE = mm_allocate(%size(listE_t): i_hList.heapID);

            i_hList.totalMemSize = i_hList.totalMemSize + %size(listE_t);

            // Initialize entry data
            clear listE;
            listE.type      = i_type;
            listE.pData     = *NULL;
            listE.size      = 0;
            listE.maxSize   = 0;
            listE.signature = Signature_new();

            // Ready
            isDone = cTrue;
         enddo;

         // Set return value
         if isDone;
            index = i_hList.numE;
         else;
            index = 0;
         endif;

         return index;

      /END-FREE
      *
     P newEntry...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns a pointer to the basing pointer of the
      *  liste entry.
      *=========================================================================
     P getPointerArrayE...
     P                 B
      *
     D getPointerArrayE...
     D                 PI              *
     D  i_hList                            const  likeds(hList_t   )
     D  i_index                      10I 0 const
      *
      *  Return value
     D ppListE         S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Compute memory address of list entry
         ppListE = i_hList.pBase + ((i_index-1) * %size(pDummy));

         return ppListE;

      /END-FREE
      *
     P getPointerArrayE...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns a pointer to the element at the specified
      *  position in this list.
      *=========================================================================
     P getPointerListE...
     P                 B
      *
     D getPointerListE...
     D                 PI              *
     D  i_hList                            const  likeds(hList_t   )
     D  i_index                      10I 0 const
      *
      *  Return value
     D pListE          S               *   based(ppListE)
     D ppListE         S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Compute memory address of list entry
         ppListE = getPointerArrayE(i_hList: i_index);

         return pListE;

      /END-FREE
      *
     P getPointerListE...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Frees the memory of a given element in this list.
      *=========================================================================
     P freeEntryData...
     P                 B
      *
     D freeEntryData...
     D                 PI
     D  i_hList                                   likeds(hList_t   )
     D  io_listE                                  likeds(listE_t   )
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Do until everything is done or an error occured
         dou '1';

            // Set memory manager
            mm_memMgr = i_hList.memMgr;

            // Keep track of the sized of memory used by the list
            i_hList.totalMemSize = i_hList.totalMemSize - io_listE.maxSize;

            // Initialize entry data
            if io_listE.size > 0;
               memset(io_listE.pData: x'00': io_listE.maxSize);
            endif;

            // Free memory of entry entry
            mm_free(io_listE.pData);
            io_listE.type    = '';
            io_listE.size    = 0;
            io_listE.maxSize = 0;

            i_hList.totalMemSize = i_hList.totalMemSize + io_listE.maxSize;
         enddo;

         return;

      /END-FREE
      *
     P freeEntryData...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns TRUE if a given list contains no data.
      *=========================================================================
     P entryData_isNULL...
     P                 B
      *
     D entryData_isNULL...
     D                 PI              N
     D  i_listE                            const  likeds(listE_t   )
      *
      *  Return value
     D isNULL          S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_listE.size = 0) and (i_listE.pData = *NULL);
            isNULL = cTrue;
         else;
            isNULL = cFalse;
         endif;

         return isNULL;

      /END-FREE
      *
     P entryData_isNULL...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Create a very basic list handle.
      *=========================================================================
     P newListInternal...
     P                 B
      *
     D newListInternal...
     D                 PI              *
     D  i_extType                          const  like(BasicList_type_t  )
     D  i_increment                  10I 0 const
     D  i_heapID                     10I 0 const
     D  i_memMgr                           const  likeds(MemoryManager...
     D                                                   _manager_t)
      *
      *  Return value
     D hList           DS                  likeds(hList_t    ) based(pHList)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Set memory manager
         mm_memMgr = i_memMgr;

         // Allocate memory for list handle
         pHList = mm_allocate(%size(hList_t): i_heapID);

         if pHList = *NULL;
            signalError(cERROR_NO_MEMORY: f_caller());
         endif;

         // Initialize list handle
         clear hList;
         hList.intType       = cHANDLE_TYPE_LIST;
         hList.intSize       = %size(hList);
         hList.extType       = i_extType;
         hList.memSize       = 0;
         hList.numE          = 0;
         hList.maxNumE       = 0;
         hList.totalMemSize  = 0;
         hList.increment     = i_increment;
         hList.signature     = Signature_new();
         hList.sortSignature = hList.signature;
         hList.pBase         = *NULL;
         hList.pAutoSortFnc  = *NULL;
         hList.memMgr        = i_memMgr;
         hList.heapID        = i_heapID;

         return pHList;

      /END-FREE
      *
     P newListInternal...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Set the entry data.
      *=========================================================================
     P setEntryData...
     P                 B
      *
     D setEntryData...
     D                 PI            10I 0
     D  io_hList                                  likeds(hList_t  )
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const
     D  i_length                     10I 0 const
      *
      *  Return Value
     D newLength       S             10I 0 inz(-1)
      *
      *  Entry Data
     D listE           DS                  likeds(listE_t    ) based(pListE)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Set memory manager
         mm_memMgr = io_hList.memMgr;

         // Get access to entry data
         pListE = getPointerListE(io_hList: i_index);

         // If the lenth of the entry data exceeds the
         // size of the allocated memory ...
         if i_length > listE.maxSize;
            // ... (re)allocate memory buffer
            if listE.pData = *NULL;
               listE.pData = mm_allocate(i_length: io_hList.heapID);
            else;
               listE.pData = mm_reallocate(listE.pData: i_length);
            endif;

            if listE.pData = *NULL;
               signalError(cERROR_NO_MEMORY: f_caller());
            endif;

            io_hList.totalMemSize = io_hList.totalMemSize - listE.maxSize;

            listE.maxSize = i_length;

            io_hList.totalMemSize = io_hList.totalMemSize + listE.maxSize;
         endif;

         // If entry data is available ...
         if i_length > 0;
            // ... then copy entry data to buffer
            memcpy(listE.pData: i_pEntry: i_length);
            // ... clear remaining data
            if i_length < listE.maxSize;
               memset(listE.pData + i_length: x'00': listE.maxSize - i_length);
            endif;
         else;
            // ... else clear entry data
            memset(listE.pData: x'00': listE.maxSize);
         endif;

         // Set new signature
         io_hList.signature = Signature_new();

         // Save current length of entry data
         listE.size = i_length;

         // Free entry data if applicable:
         if not entryData_isNULL(listE) and (listE.size = 0);
            freeEntryData(io_hList: listE);
         endif;

         newLength = listE.size;

         return newLength;

      /END-FREE
      *
     P setEntryData...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks the range of the list index.
      *=========================================================================
     P isIndexOutOfRange...
     P                 B
      *
     D isIndexOutOfRange...
     D                 PI              N
     D  i_hList                            const  likeds(hList_t  )
     D  i_index                      10I 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_index < 1) or (i_index > i_hList.numE);
            return cTrue;
         else;
            return cFalse;
         endif;

      /END-FREE
      *
     P isIndexOutOfRange...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sorts a given list.
      *=========================================================================
     P qsortCallback...
     P                 B
      *
     D qsortCallback...
     D                 PI            10I 0
     D  i_pKey                         *   value
     D  i_pElement                     *   value
      *
     D pKey            S               *   based(i_pKey)
     D pElement        S               *   based(i_pElement)
      *
     D key             DS                  likeds(listE_t) based(pKey    )
     D element         DS                  likeds(listE_t) based(pElement)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return sortFnc(key.pData: key.size: element.pData: element.size);

      /END-FREE
      *
     P qsortCallback...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sorts the list if it is required and if an auto-sort procedure
      *  has been specified.
      *=========================================================================
     P performAutoSort...
     P                 B
      *
     D performAutoSort...
     D                 PI              N
     D  io_hList                                  likeds(hList_t  )
      *
      *  Parameter positions
     D p_currentE      C                   const(2)
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if io_hList.pAutoSortFnc <> *NULL;
            isSorted = sortList(io_hList: io_hList.pAutoSortFnc);
         else;
            isSorted = cTrue;
         endif;

         return isSorted;

      /END-FREE
      *
     P performAutoSort...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sorts the list.
      *=========================================================================
     P sortList...
     P                 B
      *
     D sortList...
     D                 PI              N
     D  io_hList                                  likeds(hList_t  )
     D  i_pSortFnc                     *   const  procptr
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (isSortedInternally(io_hList));
            isSorted = cTrue;
         else;

            p_assert(g_pSortFnc = *NULL
                     : 'g_pSortFnc should be NULL');

            // Set global variable to hold address of sort procedure
            g_pSortFnc = i_pSortFnc;

            // Sort list
            qsort(io_hList.pBase: io_hList.numE
                                : %size(pDummy)
                                : %paddr('qsortCallback'));

            // Set sort signature
            io_hList.sortSignature = io_hList.signature;

            // Clear global sort function pointer
            g_pSortFnc = *NULL;

            isSorted = cTrue;
         endif;

         return isSorted;

      /END-FREE
      *
     P sortList...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns cTrue for a sorted list, else cFalse.                                       R
      *=========================================================================
     P isSortedInternally...
     P                 B
      *
     D isSortedInternally...
     D                 PI              N
     D  i_hList                            const  likeds(hList_t  )
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if i_hList.signature = i_hList.sortSignature;
            isSorted = cTrue;
         else;
            isSorted = cFalse;
         endif;

         return isSorted;

      /END-FREE
      *
     P isSortedInternally...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Searches the list for an entry using the data pointer of the entry
      *=========================================================================
     P findEntryBySignature...
     P                 B
      *
     D findEntryBySignature...
     D                 PI            10I 0
     D  i_hList                            const  likeds(hList_t    )
     D  i_signature                        const  likeds(signature_t)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  List entry
     D listE           DS                  likeds(listE_t    ) based(pListE)
      *
      *  Helper fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         for x = 1 to i_hList.numE;
            pListE = getPointerListE(i_hList: x);
            if listE.signature = i_signature;
               index = x;
               leave;
            endif;
         endfor;

         return index;

      /END-FREE
      *
     P findEntryBySignature...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns a new list signature.
      *=========================================================================
     P Signature_new...
     P                 B
      *
     D Signature_new...
     D                 PI                         likeds(signature_t )
      *
      *  Return value
     D signature       DS                  likeds(signature_t ) inz
      *
      *  Endless counter
     D lastCounter     S             10U 0 inz           static
     D maxCounter      S             10U 0 inz(*HIVAL)   static
     D now             DS                  likeds(timeb_t ) inz
      *
     D ftime           PR            10I 0 extproc('ftime')
     D  tp                                 const  likeds(timeb_t)
      *
     D timeb_t         DS                  qualified               based(pDummy)
     D  time                         10I 0
     D  millitm                      10I 0
     D  timezone                     10I 0
     D  dstflag                      10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // signature.tmStmp  = %timestamp();
      /IF NOT DEFINED(*V5R3M0)
         signature.time = time(*NULL);
         signature.millitm = 0;
      /ELSE
         ftime(now);   // API introduced: V5R3
         signature.time = now.time;
         signature.millitm = now.millitm;
      /ENDIF

         if lastCounter < maxCounter;
            signature.counter = lastCounter + 1;
         else;
            signature.counter = 1;
         endif;

         lastCounter = signature.counter;

         return signature;

      /END-FREE
      *
     P Signature_new...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks, whether a given handle is a valid list handle, or not.
      *  Returns TRUE for a valid list handle, else FALSE.
      *=========================================================================
     P checkListHandle...
     P                 B
      *
     D checkListHandle...
     D                 PI
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  List handle
     D hList           DS                  likeds(hList_t    ) based(i_pList)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicList_isNull(i_pList));
            signalError(cERROR_LIST_HANDLE_NULL: f_caller());
         endif;

         if (hList.intType <> cHANDLE_TYPE_LIST);
            signalError(cERROR_LIST_HANDLE_INVALID: f_caller());
         endif;

         if (hList.intSize <> cHANDLE_SIZE);
            signalError(cERROR_LIST_HANDLE_INVALID: f_caller());
         endif;

         return;

      /END-FREE
      *
     P checkListHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends a DIAG message to signal a problem.
      *=========================================================================
     P signalProblem...
     P                 B
      *
     D signalProblem...
     D                 PI
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg('CPF9897'
                        : 'BasicList: ERROR - ' + i_text
                        : cMsg_Diag: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: i_proc);

         return;

      /END-FREE
      *
     P signalProblem...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends an ESCAPE message to signal an error condition.
      *=========================================================================
     P signalError...
     P                 B
      *
     D signalError...
     D                 PI
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg('CPF9898'
                        : 'BasicList: ERROR - ' + i_text
                        : cMsg_Escape: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: i_proc);

         return;

      /END-FREE
      *
     P signalError...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RB "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicStack               "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RB  - SrvPgm: Basic Routines - BasicStack                   *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  09.06.2004                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  28.04.2008  Th.Raddatz    Introduced a real stack handle (hStack_t)*
      *                                                                     *
      *  28.04.2008  Th.Raddatz    Check type of stack handle and send an   *
      *                            ESCAPE message for invalid handles.      *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RB
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D hStack_t        DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  heapID                       10I 0
     D  pList                              like(BasicList_handle_t)
     D  memMgr                             likeds(MemoryManager_manager_t)
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Checks, whether a given handle is a valid stack handle, or not.
     D checkStackHandle...
     D                 PR
     D                                            extproc('checkStackHandle')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Sends an ESCAPE message to signal an error condition.
     D signalError...
     D                 PR
     D                                            extproc('signalError')
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D cHANDLE_TYPE_STACK...
     D                 C                   const(6693091772879487297)           =  *Stack
     D cHANDLE_SIZE...
     D                 C                   const(%size(hStack_t))
      *
     D cERROR_STACK_HANDLE_NULL...
     D                 C                   const('Stack handle is NULL')
     D cERROR_STACK_HANDLE_INVALID...
     D                 C                   const('Stack handle is invalid')
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a new BasicStack.
      *=========================================================================
      *  Parameters:
      *   i_increment   - The number of empty elements that are added to the
      *                   stack when the stack needs to be resized.
      *
      *  Returns:
      *   pStack        - Returns the basing pointer of the stack on
      *                   success, else NULL.
      *=========================================================================
     P BasicStack_new...
     P                 B                   export
      *
     D BasicStack_new...
     D                 PI                         like(BasicStack_handle_t  )
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10U 0 const  options(*nopass: *omit)
      *
      *  Return value
     D pStack          S                   like(BasicStack_handle_t  ) inz
      *
      *  Parameter positions
     D p_increment     C                   const(1)
     D p_heapID        C                   const(2)
      *
      *  Fields for optional parameters
     D increment       S                   like(i_increment ) inz
     D heapID          S                   like(i_heapID    ) inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get values of optional parameters
         // i_increment
         if (%parms() >= p_increment and %addr(i_increment) <> *NULL);
            increment = i_increment;
         else;
            increment = 256;
         endif;

         // ... i_heapID
         if (%parms() >= p_heapID and %addr(i_heapID) <> *NULL);
            heapID = i_heapID;
         else;
            heapID = 0;
         endif;

         // Set memory manager
         mm_memMgr = MemoryManager_getDefaultManager();

         // Allocate memory for stack handle
         pStack = mm_allocate(%size(hStack_t): heapID);

         // Initialize stack handle
         clear hStack;
         hStack.intType = cHANDLE_TYPE_STACK;
         hStack.intSize = %size(hStack);
         hStack.pList   = BasicList_new('*BASICSTACK': increment);
         hStack.heapID  = heapID;
         hStack.memMgr  = mm_memMgr;

         return pStack;

      /END-FREE
      *
     P BasicStack_new...
     P                 E
      *
      *=========================================================================
      *  Clones a given BasicStack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   pStack        - Returns the basing pointer of the cloned stack on
      *                   success, else NULL.
      *=========================================================================
     P BasicStack_clone...
     P                 B                   export
      *
     D BasicStack_clone...
     D                 PI                         like(BasicStack_handle_t  )
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D pStackRtn       S                   like(BasicStack_handle_t  ) inz
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(cFalse
                  : 'Procedure not yet implemented');

         return pStackRtn;

      /END-FREE
      *
     P BasicStack_clone...
     P                 E
      *
      *=========================================================================
      *  Gets the last entry from top of the stack without removing it from stack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *   i_pEntry      - Optional. Address where to copy the entry data to.
      *   i_length      - Optional. The maximum size of the entry data.
      *
      *  Returns:
      *   pEntry        - Returns a pointer to the entry data on
      *                   success, else NULL.
      *=========================================================================
     P BasicStack_peek...
     P                 B                   export
      *
     D BasicStack_peek...
     D                 PI              *
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D pElemData       S               *   inz
      *
      *  Parameter positions
     D p_pEntry        C                   const(2)
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D pEntry          S                   like(i_pEntry    ) inz
     D length          S                   like(i_length    ) inz
      *
      *  Local fields
     D numElements     S             10I 0 inz
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         p_assert(%parms() <> p_pEntry
                  : 'Invalid number of arguments: i_length is missing');

         // Get element from underlaying BasicList
         numElements = BasicList_getNumE(hStack.pList);
         if numElements <> -1;
            if %parms() >= p_length;
               pElemData = BasicList_get(hStack.pList: numElements
                                         : i_pEntry: i_length);
            else;
               pElemData = BasicList_get(hStack.pList: numElements);
            endif;
         else;
            pElemData = *NULL;
         endif;

         return pElemData;

      /END-FREE
      *
     P BasicStack_peek...
     P                 E
      *
      *=========================================================================
      *  Removes the lement at the top of the stack and returnns that element.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *   i_pEntry      - Address where to copy the entry data to.
      *   i_length      - The maximum size of the entry data.
      *
      *  Returns:
      *   pEntry        - Returns a pointer to the entry data on
      *                   success, else NULL.
      *=========================================================================
     P BasicStack_pop...
     P                 B                   export
      *
     D BasicStack_pop...
     D                 PI              *
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const
     D  i_length                     10I 0 const
      *
      *  Return value
     D pElemData       S               *   inz
      *
      *  Local fields
     D numElements     S             10I 0 inz
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Get element from underlaying BasicList
         numElements = BasicList_getNumE(hStack.pList);
         if numElements <> -1;
            pElemData = BasicList_get(
                             hStack.pList: numElements: i_pEntry: i_length);
            BasicList_remove(hStack.pList: numElements);
         else;
            pElemData = *NULL;
         endif;

         return pElemData;

      /END-FREE
      *
     P BasicStack_pop...
     P                 E
      *
      *=========================================================================
      *  Pushes an item onto the top of the stack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *   i_pEntry      - The entry to be added to this stack.
      *   i_length      - Optional. The size of the entry data.
      *
      *  Returns:
      *   index         - Returns the index of the element on
      *                   success, else -1.
      *=========================================================================
     P BasicStack_push...
     P                 B                   export
      *
     D BasicStack_push...
     D                 PI            10I 0
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D length          S                   like(i_length     ) inz
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Get length of entry data
         if %parms() >= p_length;
            length = i_length;
         else;
            length = strlen(i_pEntry);
         endif;

         // Add entry to underlaying BasicList
         index = BasicList_add(hStack.pList: i_pEntry: length);

         return index;

      /END-FREE
      *
     P BasicStack_push...
     P                 E
      *
      *=========================================================================
      *  Returns the size of of the element that is on top of this stack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   size          - Returns the size of the element on success, else -1.
      *=========================================================================
     P BasicStack_getSize...
     P                 B                   export
      *
     D BasicStack_getSize...
     D                 PI            10I 0
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Local fields
     D numElements     S             10I 0 inz
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Get index of last element of this stack
         numElements = BasicList_getNumE(hStack.pList);

         // Get size of that element
         if numElements <> -1;
            size = BasicList_getSize(hStack.pList: numElements);
         endif;

         return size;

      /END-FREE
      *
     P BasicStack_getSize...
     P                 E
      *
      *=========================================================================
      *  Returns the number of elements in this stack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   size          - Returns the number of elements in this list on
      *                   success, else -1.
      *=========================================================================
     P BasicStack_getNumE...
     P                 B                   export
      *
     D BasicStack_getNumE...
     D                 PI            10I 0
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D numE            S             10I 0 inz(-1)
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Return number of elements of underlaying list
         numE = BasicList_getNumE(hStack.pList);

         return numE;

      /END-FREE
      *
     P BasicStack_getNumE...
     P                 E
      *
      *=========================================================================
      *  Returns the heap ID of a given BasicStack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   heapID        - ID of the heap this BasicStack belongs to.
      *=========================================================================
     P BasicStack_getHeapID...
     P                 B                   export
      *
     D BasicStack_getHeapID...
     D                 PI            10I 0
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D heapID          S             10I 0 inz(-1)
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Return the heap ID of underlaying list
         heapID = BasicList_getHeapID(hStack.pList);

         return heapID;

      /END-FREE
      *
     P BasicStack_getHeapID...
     P                 E
      *
      *=========================================================================
      *  Removes all entries from a given stack.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicStack_clear...
     P                 B                   export
      *
     D BasicStack_clear...
     D                 PI            10I 0
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(i_pStack);

         // Clear underlaying BasicList
         rc = BasicList_clear(hStack.pList);

         return rc;

      /END-FREE
      *
     P BasicStack_clear...
     P                 E
      *
      *=========================================================================
      *  Deletes a given BasicStack.
      *=========================================================================
      *  Parameters:
      *   io_pStack     - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicStack_delete...
     P                 B                   export
      *
     D BasicStack_delete...
     D                 PI            10I 0
     D  io_pStack                                 like(BasicStack_handle_t  )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(io_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkStackHandle(io_pStack);

         // Set memory manager
         mm_memMgr = hStack.memMgr;

         // Delete underlaying BasicList.
         rc = BasicList_delete(hStack.pList);

         // Clear stack handle
         clear hStack;
         hStack.intType = 0;
         hStack.intSize = 0;
         hStack.pList   = BasicList_null();
         hStack.heapID  = 0;
         clear hStack.memMgr;

         // Free memory of map handle
         mm_free(io_pStack);

         io_pStack = BasicStack_null();

         return rc;

      /END-FREE
      *
     P BasicStack_delete...
     P                 E
      *
      *=========================================================================
      *  Returns a BasicStack NULL handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pStack        - NULL handle of a BasicStack.
      *=========================================================================
     P BasicStack_null...
     P                 B                   export
      *
     D BasicStack_null...
     D                 PI                         like(BasicStack_handle_t  )
      *
      *  Return value
     D pStack          S                   like(BasicStack_handle_t  ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pStack = *NULL;

         return pStack;

      /END-FREE
      *
     P BasicStack_null...
     P                 E
      *
      *=========================================================================
      *  Checks a given BasicStack handle for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_pStack      - Basing pointer of the stack returned by BasicStack_new().
      *
      *  Returns:
      *   isNull        - Returns TRUE if the handle is null, else FALSE.
      *=========================================================================
     P BasicStack_isNull...
     P                 B                   export
      *
     D BasicStack_isNull...
     D                 PI              N
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Return value
     D isNull          S               N   inz(cTrue)
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pStack = BasicStack_null());
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return isNull;

      /END-FREE
      *
     P BasicStack_isNull...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks, whether a given handle is a valid stack handle, or not.
      *  Returns TRUE for a valid stack handle, else FALSE.
      *=========================================================================
     P checkStackHandle...
     P                 B
      *
     D checkStackHandle...
     D                 PI
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Stack handle
     D hStack          DS                  likeds(hStack_t   ) based(i_pStack)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicStack_isNull(i_pStack));
            signalError(cERROR_STACK_HANDLE_NULL: f_caller());
         endif;

         if (hStack.intType <> cHANDLE_TYPE_STACK);
            signalError(cERROR_STACK_HANDLE_INVALID: f_caller());
         endif;

         if (hStack.intSize <> cHANDLE_SIZE);
            signalError(cERROR_STACK_HANDLE_INVALID: f_caller());
         endif;

         return;

      /END-FREE
      *
     P checkStackHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends an ESCAPE message to signal an error condition.
      *=========================================================================
     P signalError...
     P                 B
      *
     D signalError...
     D                 PI
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg('CPF9898'
                        : 'BasicStack: ERROR - ' + i_text
                        : cMsg_Escape: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: i_proc);

         return;

      /END-FREE
      *
     P signalError...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RC "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicMap                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RC  - SrvPgm: Basic Routines - BasicMap                     *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  09.06.2004                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  08.11.2007  Th.Raddatz    Added procedures:                        *
      *                            BasicMap_getSizeByIndex()                *
      *                            BasicMap_putString()                     *
      *                            BasicMap_getString()                     *
      *                                                                     *
      *  05.12.2007  Th.Raddatz    Added procedures:                        *
      *                            BasicMap_putInteger()                    *
      *                            BasicMap_getInteger()                    *
      *                                                                     *
      *  14.12.2007  Th.Raddatz    Added assert() to BasicMap_put() to      *
      *                            ensure that key length is greater 0.     *
      *                                                                     *
      *  25.02.2008  Th.Raddatz    Fixed memory leak. BasicMap_remove()     *
      *                            did remove the map entry from the        *
      *                            underlaying list but did not free the    *
      *                            memory allocted for that map entry.      *
      *                                                                     *
      *  24.04.2008  Th.Raddatz    Introduced a real map handle (hMap_t).   *
      *                                                                     *
      *  28.04.2008  Th.Raddatz    Check type of map handle and send an     *
      *                            ESCAPE message for invalid handles.      *
      *                            Added procedures:                        *
      *                               BasicMap_KeySet_new()                 *
      *                               BasicMap_KeySet_getFirst()            *
      *                               BasicMap_KeySet_getNext()             *
      *                               BasicMap_KeySet_delete()              *
      *                                                                     *
      *  14.05.2008  Th.Raddatz    Enabled BasicMap_KeySet_new() to be      *
      *                            called more than once. Introduced        *
      *                            counter to keep track of the number of   *
      *                            references. (hMap.keySetNumRef)          *
      *                                                                     *
      *  27.05.2008  Th.Raddatz    Added procedures:                        *
      *                               BasicMap_clone()                      *
      *                            Enabled BasicMap to store NULL data.     *
      *                                                                     *
      *  09.05.2011  Th.Raddatz    Renamed the KeySet procedures and        *
      *                            type templates to:                       *
      *                               BasicMap_newKeySet()                  *
      *                               BasicKeySet_getFirst()                *
      *                               BasicKeySet_getNext()                 *
      *                               BasicKeySet_delete()                  *
      *                               BasicKeySet_handle_t                  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RC
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D hMap_t          DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  pList                              like(BasicList_handle_t)
     D  pKeySet                            like(BasicList_handle_t)
     D  keySetRefList                  *   dim(64)
     D  keySetNumRef                 10I 0
     D  increment                    10I 0
     D  heapID                       10I 0
     D  memMgr                             likeds(MemoryManager_manager_t)
      *
     D hKeySet_t       DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  x                            10I 0
     D  pMap                               like(BasicMap_handle_t )
      *
     D mapE_t          DS                  qualified
     D  pKey                           *
     D  pData                          *
     D  size                         10I 0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Produces a new KeySet handle.
     D produceKeySetHandle...
     D                 PR                         like(BasicKeySet_handle_t)
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Frees a given KeySet handle.
     D freeKeySetHandle...
     D                 PR
     D  io_pKeySet                                like(BasicKeySet_handle_t)
      *
      *  Adds a key to the associated key set of a given map.
     D addKeySetEntry...
     D                 PR            10I 0
     D                                            extproc('addKeySetEntry')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_key                              const  like(BasicMap_key_t    )
      *
      *  Removes a key from the associated key set of a given map.
     D removeKeySetEntry...
     D                 PR            10I 0
     D                                            extproc('removeKeySetEntry')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_key                              const  like(BasicMap_key_t    )
      *
      *  Frees the memory of a given map entry.
     D freeMapE...
     D                 PR            10I 0
     D                                            extproc('freeMapE')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Searches the underlaying list for a given key.
     D findMapE...
     D                 PR            10I 0
     D                                            extproc('findMapE')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Sorts the map.
     D sortMap...
     D                 PR
     D                                            extproc('sortMap')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
     D sortCallback...
     D                 PR            10I 0
     D                                     extproc('sortCallback')
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *  Checks, whether a given handle is a valid map handle, or not.
     D checkMapHandle...
     D                 PR
     D                                            extproc('checkMapHandle')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Checks, whether a given handle is a valid KeySet handle, or not.
     D checkKeySetHandle...
     D                 PR
     D                                            extproc('checkKeySetHandle')
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  Sends an ESCAPE message to signal an error condition.
     D signalError...
     D                 PR
     D                                            extproc('signalError')
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D cHANDLE_TYPE_MAP...
     D                 C                   const(6689113833186869569)           =  *Map
     D cHANDLE_MAP_SIZE...
     D                 C                   const(%size(hMap_t))
      *
     D cERROR_MAP_HANDLE_NULL...
     D                 C                   const('Map handle is NULL')
     D cERROR_MAP_HANDLE_INVALID...
     D                 C                   const('Map handle is invalid')
      *
     D cHANDLE_TYPE_KEYSET...
     D                 C                   const(6688555357000016705)           =  *KeySet
     D cHANDLE_KEYSET_SIZE...
     D                 C                   const(%size(hKeySet_t))
      *
     D cERROR_KEYSET_HANDLE_NULL...
     D                 C                   const('KeySet handle is NULL')
     D cERROR_KEYSET_HANDLE_INVALID...
     D                 C                   const('KeySet handle is invalid')
      *
     D cTYPE_KEYSET...
     D                 C                   const('*BASIC_KEYSET')
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a new BasicMap.
      *=========================================================================
      *  Parameters:
      *   i_increment   - The number of empty elements that are added to the
      *                   map when the map needs to be resized.
      *
      *  Returns:
      *   pMap          - Returns the basing pointer of the map on
      *                   success, else NULL.
      *=========================================================================
     P BasicMap_new...
     P                 B                   export
      *
     D BasicMap_new...
     D                 PI                         like(BasicMap_handle_t )
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D pMap            S                   like(BasicMap_handle_t ) inz
      *
      *  Parameter positions
     D p_increment     C                   const(1)
     D p_heapID        C                   const(2)
      *
      *  Fields for optional parameters
     D increment       S                   like(i_increment ) inz
     D heapID          S                   like(i_heapID    ) inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get values of optional parameters
         // ... i_increment
         if (%parms() >= p_increment and %addr(i_increment) <> *NULL);
            increment = i_increment;
         else;
            increment = 256;
         endif;

         // ... i_heapID
         if (%parms() >= p_heapID and %addr(i_heapID) <> *NULL);
            heapID = i_heapID;
         else;
            heapID = 0;
         endif;

         // Set memory manager
         mm_memMgr = MemoryManager_getDefaultManager();

         // Allocate memory for map handle
         pMap = mm_allocate(%size(hMap_t): heapID);

         // Initialize map handle
         clear hMap;
         hMap.intType   = cHANDLE_TYPE_MAP;
         hMap.intSize   = %size(hMap);
         hMap.pList     = BasicList_new('*BASICMAP': increment: heapID);
         hMap.pKeySet   = BasicList_null();
         clear hMap.keySetRefList;
         hMap.keySetNumRef = 0;
         hMap.increment = increment;
         hMap.heapID    = heapID;
         hMap.memMgr    = mm_memMgr;

         return pMap;

      /END-FREE
      *
     P BasicMap_new...
     P                 E
      *
      *=========================================================================
      *  Clones a given BasicMap.
      *=========================================================================
      *  Parameters:
      *   i_increment   - The number of empty elements that are added to the
      *                   map when the map needs to be resized.
      *
      *  Returns:
      *   pMap          - Returns the basing pointer of the map on
      *                   success, else NULL.
      *=========================================================================
     P BasicMap_clone...
     P                 B                   export
      *
     D BasicMap_clone...
     D                 PI                         like(BasicMap_handle_t )
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D pMapRtn         S                   like(BasicMap_handle_t ) inz
      *
      *  Local fields
     D x               S             10I 0 inz
     D numE            S             10I 0 inz
     D key             S                   like(BasicMap_key_t ) inz
     D size            S             10I 0 inz
     D pData           S               *   inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create a new and empty map
         pMapRtn = BasicMap_new(hMap.increment);

         // Copy map entries
         numE = BasicMap_getNumE(i_pMap);
         for x = 1 to numE;
            key   = BasicMap_getKeyByIndex(i_pMap: x);
            pData = BasicMap_getValueByIndex(i_pMap: x);
            size  = BasicMap_getSizeByIndex(i_pMap: x);
            BasicMap_put(pMapRtn: key: pData: size);
         endfor;

         // Create a key set if the base map has a key set
         if (not BasicList_isNull(hMap.pKeySet));
            BasicMap_newKeySet(i_pMap);
         endif;

         return pMapRtn;

      /END-FREE
      *
     P BasicMap_clone...
     P                 E
      *
      *=========================================================================
      *  Removes the entry to which this map maps the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key whose associated value is to be removed.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_remove...
     P                 B                   export
      *
     D BasicMap_remove...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Local fields
     D x               S             10I 0 inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by key in list
         x = findMapE(i_pMap: i_key);
         if x = -1;
            return rc;
         endif;

         // Free memory of map entry
         rc = freeMapE(i_pMap: x);

         return rc;

      /END-FREE
      *
     P BasicMap_remove...
     P                 E
      *
      *=========================================================================
      *  Returns true if this map contains a mapping for the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key whose associated value is to be returned.
      *
      *  Returns:
      *   isFound       - Returns TRUE is this map contains a mapping for the
      *                   specified key, else FALSE.
      *=========================================================================
     P BasicMap_containsKey...
     P                 B                   export
      *
     D BasicMap_containsKey...
     D                 PI              N
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D isFound         S               N   inz(cFalse)
      *
      *  Local fields
     D x               S             10I 0                       inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by key in list
         if findMapE(i_pMap: i_key) = -1;
            isFound = cFalse;
         else;
            isFound = cTrue;
         endif;

         return isFound;

      /END-FREE
      *
     P BasicMap_containsKey...
     P                 E
      *
      *=========================================================================
      *  Returns the value to which this map maps the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key whose associated value is to be returned.
      *   i_pEntry      - Value to be associated with the specified key.
      *   i_length      - Optional. The size of the value.
      *
      *  Returns:
      *   pElemData     - Pointer to the value addressed by 'i_key'.
      *=========================================================================
     P BasicMap_get...
     P                 B                   export
      *
     D BasicMap_get...
     D                 PI              *
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D pElemData       S               *   inz
      *
      *  Parameter positions
     D p_pEntry        C                   const(3)
     D p_length        C                   const(4)
      *
      *  Fields for optional parameters
     D pEntry          S                   like(i_pEntry     ) inz
     D length          S                   like(i_length     ) inz
      *
      *  Local fields
     D x               S             10I 0                       inz
     D maxSize         S             10I 0                       inz
     D mapE            DS                  likeds(mapE_t       )
     D                                     based(pMapE         )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Get values of optional parameters
         // ... pEntry
         p_assert(%parms() <> p_pEntry
                  : 'length must be specified if pEntry is passed');

         // ... length
         if %parms() >= p_length;
            pEntry = i_pEntry;
            length = i_length;
         else;
            pEntry = *NULL;
            length = 0;
         endif;

         // Locate element by key in list
         x = findMapE(i_pMap: i_key);
         if x = -1;
            return pElemData;
         endif;

         // Get element from underlaying list
         pMapE = BasicList_get(hMap.pList: x);
         if pMapE = *NULL;
            return pElemData;
         endif;

         // Determine number of bytes to copy
         if length < mapE.size;
            maxSize = length;
         else;
            maxSize = mapE.size;
         endif;

         // Initialize return buffer
         if length > 0;
            memset(pEntry: x'00': length);
         endif;

         // Copy entry data
         if maxSize > 0;
            memcpy(pEntry: mapE.pData: maxSize);
            pElemData = pEntry;
         else;
            pElemData = mapE.pData;
         endif;

         return pElemData;

      /END-FREE
      *
     P BasicMap_get...
     P                 E
      *
      *=========================================================================
      *  Returns the string value to which this map maps the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key whose associated value is to be returned.
      *
      *  Returns:
      *   string        - String value addressed by 'i_key'.
      *=========================================================================
     P BasicMap_getString...
     P                 B                   export
      *
     D BasicMap_getString...
     D                 PI          4096A          varying
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D string          S           4096A   varying inz
      *
      *  Local fields
     D x               S             10I 0 inz
     D length          S             10I 0 inz
     D maxSize         S             10I 0 inz
     D mapE            DS                  likeds(mapE_t       )
     D                                     based(pMapE         )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by key in list
         x = findMapE(i_pMap: i_key);
         if x = -1;
            return string;
         endif;

         // Get element from underlaying list
         pMapE = BasicList_get(hMap.pList: x);
         if pMapE = *NULL;
            return string;
         endif;

         // Determine size of return value
         length = %size(string);

         // Determine number of bytes to copy
         if length < mapE.size;
            maxSize = length;
         else;
            maxSize = mapE.size;
         endif;

         // Initialize return buffer
         if length > 0;
            memset(%addr(string): x'00': length);
         endif;

         // Copy entry data
         if maxSize > 0;
            memcpy(%addr(string): mapE.pData: maxSize);
         endif;

         return string;

      /END-FREE
      *
     P BasicMap_getString...
     P                 E
      *
      *=========================================================================
      *  Returns the integer value to which this map maps the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key whose associated value is to be returned.
      *
      *  Returns:
      *   integer       - Integer value addressed by 'i_key'.
      *=========================================================================
     P BasicMap_getInteger...
     P                 B                   export
      *
     D BasicMap_getInteger...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D integer         S             10I 0 inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicMap_get(i_pMap:i_key:%addr(integer):%size(integer)) = *NULL);
            integer = 0;
         endif;

         return integer;

      /END-FREE
      *
     P BasicMap_getInteger...
     P                 E
      *
      *=========================================================================
      *  Returns the key addressed by a given index.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_index       - Index whose associated value is to be returned.
      *
      *  Returns:
      *   key           - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_getKeyByIndex...
     P                 B                   export
      *
     D BasicMap_getKeyByIndex...
     D                 PI                         like(BasicMap_key_t    )
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Return value
     D key             S                   like(BasicMap_key_t    ) inz
      *
      *  Local fields
     D x               S             10I 0                       inz
     D mapE_key        S                   like(BasicMap_key_t )
     D                                     based(mapE.pKey)
     D mapE            DS                  likeds(mapE_t       )
     D                                     based(pMapE         )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by index
         x = i_index;
         if (x < 1) and (x > BasicList_getNumE(hMap.pList));
            return key;
         endif;

         // Sort list, to keep order stable in case the user performs
         // a BasicMap_get() once that he got the key.
         sortMap(i_pMap);

         // Get element from underlaying list
         pMapE = BasicList_get(hMap.pList: x);
         if pMapE = *NULL;
            return key;
         endif;

         key = %subst(mapE_key: 1: %len(mapE_key));

         return key;

      /END-FREE
      *
     P BasicMap_getKeyByIndex...
     P                 E
      *
      *=========================================================================
      *  Returns the value addressed by a given index.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_index       - Index whose associated value is to be returned.
      *   i_pEntry      - Value to be associated with the specified key.
      *   i_length      - Optional. The size of the value.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_getValueByIndex...
     P                 B                   export
      *
     D BasicMap_getValueByIndex...
     D                 PI              *
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D pElemData       S               *   inz
      *
      *  Parameter positions
     D p_pEntry        C                   const(3)
     D p_length        C                   const(4)
      *
      *  Fields for optional parameters
     D pEntry          S                   like(i_pEntry     ) inz
     D length          S                   like(i_length     ) inz
      *
      *  Local fields
     D x               S             10I 0                       inz
     D maxSize         S             10I 0                       inz
     D mapE            DS                  likeds(mapE_t       )
     D                                     based(pMapE         )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Get values of optional parameters
         // ... pEntry
         p_assert(%parms() <> p_pEntry
                  : 'length must be specified if pEntry is passed');

         // ... length
         if %parms() >= p_length;
            pEntry = i_pEntry;
            length = i_length;
         else;
            pEntry = *NULL;
            length = 0;
         endif;

         // Locate element by index
         x = i_index;
         if (x < 1) and (x > BasicList_getNumE(hMap.pList));
            return pElemData;
         endif;

         // Sort list, to keep order stable in case the user performs
         // a BasicMap_get() once that he got the key.
         sortMap(i_pMap);

         // Get element from underlaying list
         pMapE = BasicList_get(hMap.pList: x);
         if pMapE = *NULL;
            return pElemData;
         endif;

         // Determine number of bytes to copy
         if length < mapE.size;
            maxSize = length;
         else;
            maxSize = mapE.size;
         endif;

         // Initialize return buffer
         if length > 0;
            memset(pEntry: x'00': length);
         endif;

         // Copy entry data
         if maxSize > 0;
            memcpy(pEntry: mapE.pData: maxSize);
            pElemData = pEntry;
         else;
            pElemData = mapE.pData;
         endif;

         return pElemData;

      /END-FREE
      *
     P BasicMap_getValueByIndex...
     P                 E
      *
      *=========================================================================
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key with which the specified value is to be associated.
      *   i_pEntry      - Value to be associated with the specified key.
      *   i_length      - Optional. The size of the value.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_put...
     P                 B                   export
      *
     D BasicMap_put...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_length        C                   const(4)
      *
      *  Fields for optional parameters
     D length          S                   like(i_length     ) inz
      *
      *  Local fields
     D x               S             10I 0 inz
     D key             S                   like(BasicMap_key_t ) inz
     D mapE            DS                  likeds(mapE_t       ) inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         p_assert(%len(i_key) > 0:
                  'Key length must be greater 0');

         // Get length of entry data
         if %parms() >= p_length;
            length = i_length;
         else;
            if i_pEntry = *NULL;
               length = 0;
            else;
               length = strlen(i_pEntry);
            endif;
         endif;

         // Set memory manager
         mm_memMgr = hMap.memMgr;

         // Locate element by key in list
         x = findMapE(i_pMap: i_key);
         if x = -1;
            // Add new entry to map
            key = i_key;

            clear mapE;
            mapE.pKey  = mm_allocate(%len(key) + 2: hMap.heapID);
            if (length = 0);
               mapE.pData = *NULL;
            else;
               mapE.pData = mm_allocate(length: hMap.heapID);
            endif;
            mapE.size  = length;
            memcpy(mapE.pKey : %addr(key): %len(key) + 2);
            memcpy(mapE.pData: i_pEntry  : length       );
            if BasicList_add(hMap.pList: %addr(mapE): %size(MapE)) <> -1;
               addKeySetEntry(hMap.pKeySet: key);
               rc = 0;
            endif;
            return rc;
         endif;

         // Get existing map entry from underlaying list
         if BasicList_get(hMap.pList: x: %addr(mapE): %size(mapE)) = *NULL;
            return rc;
         endif;

         // Associate new value to key
         mapE.pData = mm_reallocate(mapE.pData: length);
         mapE.size  = length;
         memcpy(mapE.pData: i_pEntry: length);

         // Write back map entry to list
         if BasicList_set(hMap.pList: x: %addr(mapE): %size(MapE)) <> -1;
            rc = 0;
         endif;

         return rc;

      /END-FREE
      *
     P BasicMap_put...
     P                 E
      *
      *=========================================================================
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key with which the specified value is to be associated.
      *   i_string      - String value to be associated with the specified key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_putString...
     P                 B                   export
      *
     D BasicMap_putString...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_string                   4096A   const  varying
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Local fields
     D string          S                   like(i_string       ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string = i_string;
         rc = BasicMap_put(i_pMap: i_key: %addr(string): %len(string) + 2);

         return rc;

      /END-FREE
      *
     P BasicMap_putString...
     P                 E
      *
      *=========================================================================
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key with which the specified value is to be associated.
      *   i_integer     - Integer value to be associated with the specified key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicMap_putInteger...
     P                 B                   export
      *
     D BasicMap_putInteger...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_integer                    10I 0 const
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Local fields
     D integer         S                   like(i_integer      ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         integer = i_integer;
         rc = BasicMap_put(i_pMap: i_key: %addr(integer): %size(integer));

         return rc;

      /END-FREE
      *
     P BasicMap_putInteger...
     P                 E
      *
      *=========================================================================
      *  Returns the size of of the element that is associated with this key.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_key         - Key of the value.
      *
      *  Returns:
      *   size          - Returns the size of the element on success, else -1.
      *=========================================================================
     P BasicMap_getSize...
     P                 B                   export
      *
     D BasicMap_getSize...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Local fields
     D x               S             10I 0 inz
     D mapE            DS                  likeds(mapE_t       ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by key in list
         x = findMapE(i_pMap: i_key);
         if x = -1;
            return size;
         endif;

         // Get map entry from underlaying list
         if BasicList_get(hMap.pList: x: %addr(mapE): %size(mapE)) = *NULL;
            return size;
         endif;

         size = mapE.size;

         return size;

      /END-FREE
      *
     P BasicMap_getSize...
     P                 E
      *
      *=========================================================================
      *  Returns the size of of the element that is addressed by a given index.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_index       - Index whose associated value is to be returned.
      *
      *  Returns:
      *   size          - Returns the size of the element on success, else -1.
      *=========================================================================
     P BasicMap_getSizeByIndex...
     P                 B                   export
      *
     D BasicMap_getSizeByIndex...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Local fields
     D x               S             10I 0 inz
     D mapE            DS                  likeds(mapE_t       ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Locate element by index
         x = i_index;
         if (x < 1) and (x > BasicList_getNumE(hMap.pList));
            return size;
         endif;

         // Get element from underlaying list
         if BasicList_get(hMap.pList: x: %addr(mapE): %size(mapE)) = *NULL;
            return size;
         endif;

         size = mapE.size;

         return size;

      /END-FREE
      *
     P BasicMap_getSizeByIndex...
     P                 E
      *
      *=========================================================================
      *  Returns the number of key-value mappings in this map.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   size          - Returns the number of elements in this list on
      *                   success, else -1.
      *=========================================================================
     P BasicMap_getNumE...
     P                 B                   export
      *
     D BasicMap_getNumE...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D numE            S             10I 0 inz(-1)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Return number of elements of underlaying list
         numE = BasicList_getNumE(hMap.pList);

         return numE;

      /END-FREE
      *
     P BasicMap_getNumE...
     P                 E
      *
      *=========================================================================
      *  Returns the heap ID of a given BasicMap.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   heapID        - ID of the heap this BasicMap belongs to.
      *=========================================================================
     P BasicMap_getHeapID...
     P                 B                   export
      *
     D BasicMap_getHeapID...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D heapID          S             10I 0 inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Return the heap ID of underlaying list
         heapID = BasicList_getHeapID(hMap.pList);

         return heapID;

      /END-FREE
      *
     P BasicMap_getHeapID...
     P                 E
      *
      *=========================================================================
      *  Returns a list of all keys that are in a given map.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_pSortFnc    - Optional: Procedure pointer of sort procedure.
      *
      *  Returns:
      *   hList         - List, containing all keys of the map.
      *=========================================================================
     P BasicMap_getKeys...
     P                 B                   export
      *
     D BasicMap_getKeys...
     D                 PI                         like(BasicList_handle_t)
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_pSortFnc                     *   const  procptr
     D                                            options(*nopass)
      *
      *  Return value
     D hList           S                   like(BasicList_handle_t ) inz
      *
      *  Parameter positions
     D p_pSortFnc      C                   2
      *
      *  Fields for optional parameters
     D pSortFnc        S                   like(i_pSortFnc  ) inz
      *
      *  Helper fields
     D x               S             10I 0 inz
     D key             S                   like(BasicMap_key_t ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Get optional parameter values:
         // ... pSortFnc
         if (%parms() >= p_pSortFnc and %addr(i_pSortFnc) <> *NULL);
            pSortFnc = i_pSortFnc;
         else;
            pSortFnc = *NULL;
         endif;

         // Create a new BasicList
         hList = BasicList_new('*BASICMAP_KEYS'
                               : hMap.increment
                               : hMap.heapID);

         // Add map values to list
         for x = 1 to BasicMap_getNumE(i_pMap);
            key = BasicMap_getKeyByIndex(i_pMap: x);
            BasicList_addString(hList: key);
         endfor;

         // Sort list if the user passed a comparator
         if (pSortFnc <> *NULL);
            BasicList_sort(hList: pSortFnc);
         endif;

         return hList;

      /END-FREE
      *
     P BasicMap_getKeys...
     P                 E
      *
      *=========================================================================
      *  Returns a list of all values that are in a given map.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_pSortFnc    - Optional: Procedure pointer of sort procedure.
      *
      *  Returns:
      *   hList         - List, containing all values of the map.
      *=========================================================================
     P BasicMap_getValues...
     P                 B                   export
      *
     D BasicMap_getValues...
     D                 PI                         like(BasicList_handle_t)
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_pSortFnc                     *   const  procptr
     D                                            options(*nopass)
      *
      *  Return value
     D hList           S                   like(BasicList_handle_t ) inz
      *
      *  Parameter positions
     D p_pSortFnc      C                   2
      *
      *  Fields for optional parameters
     D pSortFnc        S                   like(i_pSortFnc  ) inz
      *
      *  Helper fields
     D x               S             10I 0 inz
     D size            S             10I 0 inz
     D pData           S               *   inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Get optional parameter values:
         // ... pSortFnc
         if (%parms() >= p_pSortFnc and %addr(i_pSortFnc) <> *NULL);
            pSortFnc = i_pSortFnc;
         else;
            pSortFnc = *NULL;
         endif;

         // Create a new BasicList
         hList = BasicList_new('*BASICMAP_VALUES'
                               : hMap.increment
                               : hMap.heapID);

         // Add map values to list
         for x = 1 to BasicMap_getNumE(i_pMap);
            pData = BasicMap_getValueByIndex(i_pMap: x);
            size  = BasicMap_getSizeByIndex(i_pMap: x);
            BasicList_add(hList: pData: size);
         endfor;

         // Sort list if the user passed a comparator
         if (pSortFnc <> *NULL);
            BasicList_sort(hList: pSortFnc);
         endif;

         return hList;

      /END-FREE
      *
     P BasicMap_getValues...
     P                 E
      *
      *=========================================================================
      *  Removes all entries from a given map.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicMap_clear...
     P                 B                   export
      *
     D BasicMap_clear...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D x               S             10I 0 inz
     D numE            S             10I 0 inz
     D aPointer        S               *   inz
     D mapE            DS                  likeds(mapE_t       ) inz
      *
      *  Debug:
     D key             S                   like(BasicMap_key_t )
     D                                     based(mapE.pKey)
     D data            S          65535A   based(mapE.pData)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         // Remove elements from map.
         numE = BasicList_getNumE(hMap.pList);

         dow numE > 0;

            // Free memory of map entry
            freeMapE(i_pMap: numE);

            numE = BasicList_getNumE(hMap.pList);
         enddo;

         rc = 0;

         return rc;

      /END-FREE
      *
     P BasicMap_clear...
     P                 E
      *
      *=========================================================================
      *  Deletes a given BasicMap.
      *=========================================================================
      *  Parameters:
      *   io_pMap       - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicMap_delete...
     P                 B                   export
      *
     D BasicMap_delete...
     D                 PI            10I 0
     D  io_pMap                                   like(BasicMap_handle_t )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D x               S             10I 0 inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(io_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(io_pMap);

         dou 1=1;

            // Set memory manager
            mm_memMgr = hMap.memMgr;

            // Free KeySet handles.
            for x = 1 to %elem(hMap.keySetRefList);
               if (hMap.keySetRefList(x) <> *NULL);
                  freeKeySetHandle(hMap.keySetRefList(x));
               endif;
            endfor;

            // Remove elements from map.
            rc = BasicMap_clear(io_pMap);
            if rc <> 0;
               leave;
            endif;

            // Delete underlaying BasicList.
            BasicList_delete(hMap.pList);

            // Delete key set if present.
            if (not BasicList_isNull(hMap.pKeySet));
               BasicList_delete(hMap.pKeySet);
            endif;

            // Clear map handle
            clear hMap;
            hMap.intType       = 0;
            hMap.intSize       = 0;
            hMap.pList         = BasicList_null();
            hMap.pKeySet       = BasicList_null();
            for x = 1 to %elem(hMap.keySetRefList);
               p_assert(hMap.keySetRefList(x) = *NULL:
                        'hMap.keySetRefList does not match +
                         expected value *NULL');
            endfor;
            p_assert(hMap.keySetNumRef = 0:
                     'hMap.keySetNumRef does not match expected value 0');
            hMap.increment     = 0;
            hMap.heapID        = 0;
            clear hMap.memMgr;

            // Free memory of map handle
            mm_free(io_pMap);

            io_pMap = BasicMap_null();

         enddo;

         return rc;

      /END-FREE
      *
     P BasicMap_delete...
     P                 E
      *
      *=========================================================================
      *  Returns a BasicMap NULL handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pMap          - NULL handle of a BasicMap.
      *=========================================================================
     P BasicMap_null...
     P                 B                   export
      *
     D BasicMap_null...
     D                 PI                         like(BasicMap_handle_t )
      *
      *  Return value
     D pMap            S                   like(BasicMap_handle_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pMap = *NULL;

         return pMap;

      /END-FREE
      *
     P BasicMap_null...
     P                 E
      *
      *=========================================================================
      *  Checks a given BasicMap handle for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   isNull        - Returns TRUE if the handle is null, else FALSE.
      *=========================================================================
     P BasicMap_isNull...
     P                 B                   export
      *
     D BasicMap_isNull...
     D                 PI              N
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D isNull          S               N   inz(cTrue)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pMap = BasicMap_null());
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return isNull;

      /END-FREE
      *
     P BasicMap_isNull...
     P                 E
      *
      *=========================================================================
      *  Produces a list of keys from a given map.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   pList         - Handle of the list which contains all keys of
      *                   the map.
      *=========================================================================
      *  Note:            Do not delete the list with BasicList_delete()!
      *                   Use BasicKeySet_delete() to delete the list.
      *=========================================================================
     P BasicMap_newKeySet...
     P                 B                   export
      *
     D BasicMap_newKeySet...
     D                 PI                         like(BasicKeySet_handle_t)
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      *
      *  Helper fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkMapHandle(i_pMap);

         if (not BasicList_isNull(hMap.pKeySet));
            return produceKeySetHandle(i_pMap);
         endif;

         p_assert(hMap.keySetNumRef = 0
                  : 'Expected 0 in hMap.keySetNumRef');

         hMap.pKeySet = BasicList_new(cTYPE_KEYSET: hMap.increment);

         for x = 1 to BasicMap_getNumE(i_pMap);
            BasicList_addString(hMap.pKeySet
                                : BasicMap_getKeyByIndex(i_pMap: x));
         endfor;

         return produceKeySetHandle(i_pMap);

      /END-FREE
      *
     P BasicMap_newKeySet...
     P                 E
      *
      *=========================================================================
      *  Returns the first entry of a given key set.
      *=========================================================================
      *  Parameters:
      *   i_pKeySet     - Handle of a given KeySet, returned by
      *                   BasicMap_newKeySet().
      *
      *  Returns:
      *   key           - Returns the key of a map entry on success, else ''.
      *=========================================================================
     P BasicKeySet_getFirst...
     P                 B                   export
      *
     D BasicKeySet_getFirst...
     D                 PI                         like(BasicMap_key_t    )
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  KeySet handle
     D hKeySet         DS                  likeds(hKeySet_t  )
     D                                     based(i_pKeySet)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     )
     D                                     based(hKeySet.pMap)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkKeySetHandle(i_pKeySet);

         checkMapHandle(hKeySet.pMap);

         if (BasicList_isNull(hMap.pKeySet));
            return '';
         endif;

         hKeySet.x = 0;

         return BasicKeySet_getNext(i_pKeySet);

      /END-FREE
      *
     P BasicKeySet_getFirst...
     P                 E
      *
      *=========================================================================
      *  Returns the next entry of a given key set.
      *=========================================================================
      *  Parameters:
      *   i_pKeySet     - Handle of a given KeySet, returned by
      *                   BasicMap_newKeySet().
      *
      *  Returns:
      *   key           - Returns the key of a map entry on success, else ''.
      *=========================================================================
     P BasicKeySet_getNext...
     P                 B                   export
      *
     D BasicKeySet_getNext...
     D                 PI                         like(BasicMap_key_t    )
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  KeySet handle
     D hKeySet         DS                  likeds(hKeySet_t  )
     D                                     based(i_pKeySet)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     )
     D                                     based(hKeySet.pMap)
      *
      *  Helper fields
     D numE            S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkKeySetHandle(i_pKeySet);

         checkMapHandle(hKeySet.pMap);

         if (BasicList_isNull(hMap.pKeySet));
            return '';
         endif;

         numE = BasicList_getNumE(hMap.pKeySet);
         if (hKeySet.x >= numE);
            return '';
         endif;

         dow (hKeySet.x < numE);
            hKeySet.x = hKeySet.x + 1;
            if (not BasicList_isNullValue(hMap.pKeySet: hKeySet.x));
               return BasicList_getString(hMap.pKeySet: hKeySet.x);
            endif;
         enddo;

         return '';

      /END-FREE
      *
     P BasicKeySet_getNext...
     P                 E
      *
      *=========================================================================
      *  Deletes the key list associated to a given map.
      *=========================================================================
      *  Parameters:
      *   io_pKeySet    - Handle of a given KeySet, returned by
      *                   BasicMap_newKeySet().
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicKeySet_delete...
     P                 B                   export
      *
     D BasicKeySet_delete...
     D                 PI            10I 0
     D  io_pKeySet                                like(BasicKeySet_handle_t)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  KeySet handle
     D hKeySet         DS                  likeds(hKeySet_t  )
     D                                     based(io_pKeySet  )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     )
     D                                     based(pMap        )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkKeySetHandle(io_pKeySet);

         checkMapHandle(hKeySet.pMap);

         pMap = hKeySet.pMap;

         if (not BasicList_isNull(hMap.pKeySet));
            freeKeySetHandle(io_pKeySet);
            if (hMap.keySetNumRef = 0);
               BasicList_delete(hMap.pKeySet);
               hMap.pKeySet = BasicList_null();
            endif;
         endif;

         rc = 0;

         return rc;

      /END-FREE
      *
     P BasicKeySet_delete...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Produces a new KeySet handle.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Handle of a given map.
      *
      *  Returns:
      *   pKeySet       - Returns a handle for the KeySet on success, else
      *                   *NULL.
      *=========================================================================
     P produceKeySetHandle...
     P                 B
      *
     D produceKeySetHandle...
     D                 PI                         like(BasicKeySet_handle_t)
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D pKeySet         S                   like(BasicKeySet_handle_t)
      *
      *  Helper fields
     D x               S             10I 0 inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      *
      *  KeySet handle
     D hKeySet         DS                  likeds(hKeySet_t  ) based(pKeySet)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(hMap.keySetNumRef < %elem(hMap.keySetRefList):
                  'No more space for another KeySet');

         // Set memory manager
         mm_memMgr = hMap.memMgr;

         pKeySet = mm_allocate(%size(hKeySet): hMap.heapID);

         clear hKeySet;
         hKeySet.intType = cHANDLE_TYPE_KEYSET;
         hKeySet.intSize = %size(hKeySet);
         hKeySet.x       = 0;
         hKeySet.pMap    = i_pMap;

         x = %lookup(*NULL: hMap.keySetRefList);
         hMap.keySetRefList(x) = pKeySet;

         hMap.keySetNumRef = hMap.keySetNumRef + 1;

         return pKeySet;

      /END-FREE
      *
     P produceKeySetHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Frees a given KeySet handle.
      *=========================================================================
      *  Parameters:
      *   io_pKeySet    - Handle of a given KeySet.
      *
      *  Returns:
      *   void
      *=========================================================================
     P freeKeySetHandle...
     P                 B
      *
     D freeKeySetHandle...
     D                 PI
     D  io_pKeySet                     *
      *
      *  Helper fields
     D x               S             10I 0 inz
      *
      *  KeySet handle
     D hKeySet         DS                  likeds(hKeySet_t  )
     D                                     based(io_pKeySet  )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     )
     D                                     based(pMap        )
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pMap = hKeyset.pMap;

         // Set memory manager
         mm_memMgr = hMap.memMgr;

         x = %lookup(io_pKeySet: hMap.keySetRefList);
         p_assert(x > 0:
                  'KeySet handle not found in list');

         mm_free(io_pKeySet);

         hMap.keySetRefList(x) = *NULL;
         hMap.keySetNumRef     = hMap.keySetNumRef - 1;

         return;

      /END-FREE
      *
     P freeKeySetHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Adds a key to the associated key set of a given map.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the key set (list).
      *   i_key         - Key to add.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P addKeySetEntry...
     P                 B
      *
     D addKeySetEntry...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_key                              const  like(BasicMap_key_t    )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicList_isNull(i_pList));
            rc = 0;
            return rc;
         endif;

         x = BasicList_findString(i_pList: i_key);

         p_assert(x = -1
                  : 'Key already in key set');

         BasicList_addString(i_pList: i_key);

         rc = 0;

         return rc;

      /END-FREE
      *
     P addKeySetEntry...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Removes a key from the associated key set of a given map.
      *=========================================================================
      *  Parameters:
      *   i_pList       - Basing pointer of the key set (list).
      *   i_key         - Key to remove.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P removeKeySetEntry...
     P                 B
      *
     D removeKeySetEntry...
     D                 PI            10I 0
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_key                              const  like(BasicMap_key_t    )
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicList_isNull(i_pList));
            rc = 0;
            return rc;
         endif;

         x = BasicList_findString(i_pList: i_key);

         p_assert(x > 0
                  : 'Key in key set not found');

         // Actually the entry is not removed but set to NULL in order
         // to keep the positions of the list entries stable.
         BasicList_set(i_pList: x: *NULL);

         rc = 0;

         return rc;

      /END-FREE
      *
     P removeKeySetEntry...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Frees the memory of a given map entry.
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *   i_index       - Index of the map entry.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P freeMapE...
     P                 B
      *
     D freeMapE...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D aPointer        S               *   inz
     D key             S                   like(BasicMap_key_t )
     D                                     based(mapE.pKey)
     D mapE            DS                  likeds(mapE_t       ) inz
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Set memory manager
         mm_memMgr = hMap.memMgr;

         // Get map entry from underlaying list
         aPointer = BasicList_get(hMap.pList: i_index
                                            : %addr(mapE)
                                            : %size(mapE) );

         p_assert(aPointer <> *NULL
                  : 'BasicList_get() failed');

         // Remove entry from an associated key set
         removeKeySetEntry(hMap.pKeySet: key);

         // Free memory of map entry
         mm_free(mapE.pKey);           // key

         if (mapE.pData <> *NULL);
            mm_free(mapE.pData);       // data
         endif;

         clear mapE;

         // Remove that map entry from the underlaying list
         rc = BasicList_remove(hMap.pList: i_index);

         p_assert(rc <> -1
                  : 'BasicList_remove() failed');

         return rc;

      /END-FREE
      *
     P freeMapE...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Searches the underlaying list for a given key.
      *  (Binary search algorithm)
      *=========================================================================
      *  Parameters:
      *   i_pMap        - Basing pointer of the map returned by BasicMap_new().
      *
      *  Returns:
      *   isNull        - Returns TRUE if the handle is null, else FALSE.
      *=========================================================================
     P findMapE...
     P                 B
      *
     D findMapE...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D index           S             10I 0 inz(-1)
      *
      *  Helper fields
     D currentE        S             10I 0                       inz
     D lowerE          S             10I 0                       inz
     D upperE          S             10I 0                       inz
     D mapE_key        S                   like(BasicMap_key_t )
     D                                     based(mapE.pKey)
     D mapE            DS                  likeds(mapE_t )
     D                                     based(pMapE   )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         sortMap(i_pMap);

         lowerE   = 1;
         upperE   = BasicList_getNumE(hMap.pList);

         dow (index = -1) and (lowerE <= upperE);

            currentE = %int((lowerE + upperE) / 2);

            pMapE = BasicList_get(hMap.pList: currentE);
            select;
               when i_key < mapE_key;
                  upperE = currentE - 1;
               when i_key > mapE_key;
                  lowerE = currentE + 1;
            other;
               index = currentE;
            endsl;

         enddo;

         return index;

      /END-FREE
      *
     P findMapE...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sorts the map.
      *=========================================================================
     P sortMap...
     P                 B
      *
     D sortMap...
     D                 PI
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Return value
     D isSorted        S               N   inz(cFalse)
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         BasicList_sort(hMap.pList: %paddr('sortCallback'));

         return;

      /END-FREE
      *
     P sortMap...
     P                 E
      *
      *=========================================================================
      *  Procedure used by BasicList to sort this map.
      *=========================================================================
     P sortCallback...
     P                 B
      *
     D sortCallback...
     D                 PI            10I 0
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D keyMapE         DS                  likeds(mapE_t )
     D                                     based(i_pKeyData )
     D elemMapE        DS                  likeds(mapE_t )
     D                                     based(i_pElemData)
     D keyMapE_key     S                   like(BasicMap_key_t )
     D                                     based(keyMapE.pKey)
     D elemMapE_key    S                   like(BasicMap_key_t )
     D                                     based(elemMapE.pKey)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         select;
         when %subst(keyMapE_key : 1: %len(keyMapE_key )) >
              %subst(elemMapE_key: 1: %len(elemMapE_key));
            rc = 1;
         when %subst(keyMapE_key : 1: %len(keyMapE_key )) <
              %subst(elemMapE_key: 1: %len(elemMapE_key));
            rc = -1;
         other;
            rc = 0;
         endsl;

         return rc;

      /END-FREE
      *
     P sortCallback...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks, whether a given handle is a valid map handle, or not.
      *  Returns TRUE for a valid map handle, else FALSE.
      *=========================================================================
     P checkMapHandle...
     P                 B
      *
     D checkMapHandle...
     D                 PI
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Map handle
     D hMap            DS                  likeds(hMap_t     ) based(i_pMap )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicMap_isNull(i_pMap));
            signalError(cERROR_MAP_HANDLE_NULL: f_caller());
         endif;

         if (hMap.intType <> cHANDLE_TYPE_MAP);
            signalError(cERROR_MAP_HANDLE_INVALID: f_caller());
         endif;

         if (hMap.intSize <> cHANDLE_MAP_SIZE);
            signalError(cERROR_MAP_HANDLE_INVALID: f_caller());
         endif;

         return;

      /END-FREE
      *
     P checkMapHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks, whether a given handle is a valid KeySet handle, or not.
      *  Returns TRUE for a valid map handle, else FALSE.
      *=========================================================================
     P checkKeySetHandle...
     P                 B
      *
     D checkKeySetHandle...
     D                 PI
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  Map handle
     D hKeySet         DS                  likeds(hKeySet_t  ) based(i_pKeySet)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pKeySet = *NULL);
            signalError(cERROR_KEYSET_HANDLE_NULL: f_caller());
         endif;

         if (hKeySet.intType <> cHANDLE_TYPE_KEYSET);
            signalError(cERROR_KEYSET_HANDLE_INVALID: f_caller());
         endif;

         if (hKeySet.intSize <> cHANDLE_KEYSET_SIZE);
            signalError(cERROR_KEYSET_HANDLE_INVALID: f_caller());
         endif;

         return;

      /END-FREE
      *
     P checkKeySetHandle...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends an ESCAPE message to signal an error condition.
      *=========================================================================
     P signalError...
     P                 B
      *
     D signalError...
     D                 PI
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg('CPF9898'
                        : 'BasicMap: ERROR - ' + i_text
                        : cMsg_Escape: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: i_proc);

         return;

      /END-FREE
      *
     P signalError...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RD  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RD "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - URL                      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RC  - SrvPgm: Basic Routines - URL                          *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  20.12.2007                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RD
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      /COPY QBASICS1,FDURL
      *
      *  Parsed URL
     D parsedUrl_t...
     D                 DS           512    qualified               based(pDummy)
     D  type                         10A
     D  pos                           5U 0
     D  protocol                           likeds(substr_t)
     D  host                               likeds(substr_t)
     D  port                               likeds(substr_t)
     D  file                               likeds(substr_t)
     D  path                               likeds(substr_t)
     D  query                              likeds(substr_t)
     D  data                               like(url_t     )
      *
      *  For internal use only
     D substr_t...
     D                 DS                  qualified               based(pDummy)
     D  start                         5U 0
     D  length                        5U 0
     D  baseStart                     5U 0
     D  totalLength                   5U 0
      *
      * -----------------------------------------
      *  Imported Prototypes
      * -----------------------------------------
      /COPY QBASICS1,CEELIB
      *
      /COPY QBASICS1,PBASICS1R3
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Parses a given URL.
     D parseUrl...
     D                 PR                         likeds(parsedUrl_t )
     D  i_url                              const  like(url_t         )
     D  o_rc                         10I 0
      *
      *  Parsen Standard-URL
     D parseStandardUrl...
     D                 PR                         likeds(parsedUrl_t )
     D  i_parsedUrl                        const  likeds(parsedUrl_t )
     D  o_rc                         10I 0
      *
      *  Returns the sub-string defined by 'i_subString'.
     D getSubstring...
     D                 PR           512A          varying
     D  i_string                    512A   const  varying
     D  i_subString                        const  likeds(substr_t )
      *
      *  Breaks the path of a given URL into the pieces: library, file and member
     D splittPath...
     D                 PR              N   opdesc
     D  i_url                              const  likeds(parsedUrl_t )
     D  i_dftObj                    256A   const  options(*varsize)
     D  o_file                       10A
     D  o_lib                        10A
     D  o_obj                       256A          options(*varsize)
     D  o_rc                         10I 0
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
     D cEND_OF_PROTOCOL...
     D                 C                   const(':')
     D cSTART_OF_HOST...
     D                 C                   const('//')
     D cSTART_OF_FILE...
     D                 C                   const('/')
     D cSTART_OF_PORT...
     D                 C                   const(':')
     D cSTART_OF_QUERY...
     D                 C                   const('?')
     D cHANDLE_TYPE...
     D                 C                   const('*URL')
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a new Url.
      *=========================================================================
      *  Parameters:
      *   i_url         - The string representation of a Url.
      *
      *  Returns:
      *   parsedUrl     - A parsed Url.
      *=========================================================================
     P Url_new...
     P                 B                   export
      *
     D Url_new...
     D                 PI                         like(url_t )
     D  i_url                              const  like(url_t )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to create URL. Error code: ' + %char(rc));
            endif;
         endif;

         return parsedUrl;

      /END-FREE
      *
     P Url_new...
     P                 E
      *
      *=========================================================================
      *  Returns the protocol of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   protocol      - The protocol of the URL.
      *=========================================================================
     P Url_getProtocol...
     P                 B                   export
      *
     D Url_getProtocol...
     D                 PI                         like(url_t )
     D  i_url                              const  like(url_t )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D protocol        S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);

         if (rc = 0);
            protocol = f_lcase(getSubstring(parsedUrl.data
                                            : parsedUrl.protocol));
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve protocol. Error code: ' +
                         %char(rc));
            endif;
         endif;

         return protocol;

      /END-FREE
      *
     P Url_getProtocol...
     P                 E
      *
      *=========================================================================
      *  Sets the protocol of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_protocol    - The protocol of the URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the protocol could be set,
      *                   else cFalse.
      *=========================================================================
     P Url_setProtocol...
     P                 B                   export
      *
     D Url_setProtocol...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_protocol                         const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpProtocol     S                   like(i_protocol    ) inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            tmpProtocol = %trimR(%subst(i_protocol: 1: %len(i_protocol)));

            // replace protocol of URL
            if (tmpProtocol = '');
               parsedUrl.data = %replace(''
                                         : parsedUrl.data
                                         : parsedUrl.protocol.baseStart
                                         : parsedUrl.protocol.totalLength);
            else;
               if (not f_endsWith(cEND_OF_PROTOCOL: tmpProtocol));
                  tmpProtocol = tmpProtocol + cEND_OF_PROTOCOL;
               endif;
               parsedUrl.data = %replace(tmpProtocol
                                         : parsedUrl.data
                                         : parsedUrl.protocol.baseStart
                                         : parsedUrl.protocol.totalLength);
            endif;

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_URL = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set protocol. Error code: ' + %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setProtocol...
     P                 E
      *
      *=========================================================================
      *  Returns the host name of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   host          - The host name of the URL.
      *=========================================================================
     P Url_getHost...
     P                 B                   export
      *
     D Url_getHost...
     D                 PI                         like(url_t    )
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D host            S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);
         if (rc = 0);
            host = getSubstring(parsedUrl.data: parsedUrl.host);
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve host name. Error code: ' +
                         %char(rc));
            endif;
         endif;

         return host;

      /END-FREE
      *
     P Url_getHost...
     P                 E
      *
      *=========================================================================
      *  Sets the host name of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_host        - The name of the host.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the host name could be set,
      *                   else cFalse.
      *=========================================================================
     P Url_setHost...
     P                 B                   export
      *
     D Url_setHost...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_host                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpHost         S                   like(i_host        ) inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            tmpHost = %trimR(%subst(i_host: 1: %len(i_host)));

            // replace host name of URL
            if (tmpHost = '');
               parsedUrl.data = %replace(''
                                         : parsedUrl.data
                                         : parsedUrl.host.baseStart
                                         : parsedUrl.host.totalLength);
            else;
               if not f_startsWith(cSTART_OF_HOST: tmpHost);
                  tmpHost = cSTART_OF_HOST + tmpHost;
               endif;
               parsedUrl.data = %replace(tmpHost
                                         : parsedUrl.data
                                         : parsedUrl.host.baseStart
                                         : parsedUrl.host.totalLength);
            endif;

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_url = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set host name. Error code: ' + %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setHost...
     P                 E
      *
      *=========================================================================
      *  Returns the port of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   port          - The port of the URL.
      *=========================================================================
     P Url_getPort...
     P                 B                   export
      *
     D Url_getPort...
     D                 PI            10I 0
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D port            S             10I 0 inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);
         if (rc = 0);
            port = atoi(getSubstring(parsedUrl.data: parsedUrl.port));
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve port. Error code: ' + %char(rc));
            endif;
         endif;

         return port;

      /END-FREE
      *
     P Url_getPort...
     P                 E
      *
      *=========================================================================
      *  Sets the port number of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_port        - The port number.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the port number could be set,
      *                   else cFalse.
      *=========================================================================
     P Url_setPort...
     P                 B                   export
      *
     D Url_setPort...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_port                       10I 0 const
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpPort         S             30A   varying              inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            // replace port of URL
            if (i_port = 0);
               parsedUrl.data = %replace(''
                                         : parsedUrl.data
                                         : parsedUrl.port.baseStart
                                         : parsedUrl.port.totalLength);
            else;
               tmpPort = cSTART_OF_PORT + %char(i_port);
               parsedUrl.data = %replace(tmpPort
                                         : parsedUrl.data
                                         : parsedUrl.port.baseStart
                                         : parsedUrl.port.totalLength);
            endif;

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_url = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set port number. Error code: ' + %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setPort...
     P                 E
      *
      *=========================================================================
      *  Returns the path of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   path          - The path of the URL. The path of a URL is the
      *                   file name without the query parameters.
      *=========================================================================
     P Url_getPath...
     P                 B                   export
      *
     D Url_getPath...
     D                 PI                         like(url_t    )
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D path            S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);
         if (rc = 0);
            path = getSubstring(parsedUrl.data: parsedUrl.path);
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve path. Error code: ' + %char(rc));
            endif;
         endif;

         return path;

      /END-FREE
      *
     P Url_getPath...
     P                 E
      *
      *=========================================================================
      *  Sets the path of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_path        - The path. The path of a URL is the file name
      *                   without the query parameters.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the path could be set, else cFalse.
      *=========================================================================
     P Url_setPath...
     P                 B                   export
      *
     D Url_setPath...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_path                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            // replace path of URL
            parsedUrl.data = %replace(%trimR(%subst(i_path: 1: %len(i_path)))
                                      : parsedUrl.data
                                      : parsedUrl.path.baseStart
                                      : parsedUrl.path.totalLength);

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_url = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set path. Error code: ' + %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setPath...
     P                 E
      *
      *=========================================================================
      *  Returns the file of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   file          - The file of the URL. The file of a URL is everything
      *                   behind the host name (and port number).
      *=========================================================================
     P Url_getFile...
     P                 B                   export
      *
     D Url_getFile...
     D                 PI                         like(url_t    )
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D file            S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);
         if (rc = 0);
            file = getSubstring(parsedUrl.data: parsedUrl.file);
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve file. Error code: ' + %char(rc));
            endif;
         endif;

         return file;

      /END-FREE
      *
     P Url_getFile...
     P                 E
      *
      *=========================================================================
      *  Sets the file of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_file        - The file. The file of a URL is everything behind the
      *                   hostname (and port number).
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the file could be set, else cFalse.
      *=========================================================================
     P Url_setFile...
     P                 B                   export
      *
     D Url_setFile...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_file                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            // replace file of URL
            parsedUrl.data = %replace(%trimR(%subst(i_file: 1: %len(i_file)))
                                      : parsedUrl.data
                                      : parsedUrl.file.baseStart
                                      : parsedUrl.file.totalLength);

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_url = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set file. Error code: ' + %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setFile...
     P                 E
      *
      *=========================================================================
      *  Returns the query part of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   query         - The query part of the URL.
      *=========================================================================
     P Url_getQuery...
     P                 B                   export
      *
     D Url_getQuery...
     D                 PI                         like(url_t    )
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D query           S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(i_url: rc);
         if (rc = 0);
            query = getSubstring(parsedUrl.data: parsedUrl.query);
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to retrieve query. Error code: ' + %char(rc));
            endif;
         endif;

         return query;

      /END-FREE
      *
     P Url_getQuery...
     P                 E
      *
      *=========================================================================
      *  Sets the query part of a given URL.
      *=========================================================================
      *  Parameters:
      *   io_url        - The URL.
      *   i_query       - The query part of the URL.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isSet         - Returns cTrue if the query part could be set,
      *                   else cFalse.
      *=========================================================================
     P Url_setQuery...
     P                 B                   export
      *
     D Url_setQuery...
     D                 PI              N
     D  io_url                                    like(url_t )
     D  i_query                            const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_rc            C                   3
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D tmpQuery        S                   like(i_query       ) inz
     D tmpUrl          S                   like(io_URL        ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(%trim(io_url): rc);
            if (rc <> 0);
               leave;
            endif;

            tmpQuery = %trimR(%subst(i_query: 1: %len(i_query)));

            // replace query part of the URL
            if (tmpQuery = '');
               parsedUrl.data = %replace(''
                                         : parsedUrl.data
                                         : parsedUrl.query.baseStart
                                         : parsedUrl.query.totalLength);
            else;
               if not f_startsWith(cSTART_OF_QUERY: tmpQuery);
                  tmpQuery = cSTART_OF_QUERY + tmpQuery;
               endif;
               parsedUrl.data = %replace(tmpQuery
                                         : parsedUrl.data
                                         : parsedUrl.query.baseStart
                                         : parsedUrl.query.totalLength);
            endif;

            // parse changed URL
            tmpUrl = parseUrl(parsedUrl.data: rc);
            if (rc <> 0);
               leave;
            endif;

            io_url = tmpUrl;
            isSet = cTrue;
         enddo;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to set query parameters. Error code: ' +
                         %char(rc));
            endif;
         endif;

         return isSet;

      /END-FREE
      *
     P Url_setQuery...
     P                 E
      *
      *=========================================================================
      *  Returns the string representation of a given URL.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *
      *  Returns:
      *   string        - The string representation of the URL.
      *=========================================================================
     P Url_toString...
     P                 B                   export
      *
     D Url_toString...
     D                 PI           512A          varying
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Return value
     D string          S                   like(url_t ) inz
      *
      *  Parameter positions
     D p_rc            C                   2
      *
      *  Fields for optional parameters
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = parseUrl(%trim(i_URL): rc);
         if (rc = 0);
            string = %trimR(parsedUrl.data);
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to get string representation. Error code: ' +
                         %char(rc));
            endif;
         endif;

         return string;

      /END-FREE
      *
     P Url_toString...
     P                 E
      *
      *=========================================================================
      *  Returns the library, file and member of a URL of type 'mbr'.
      *=========================================================================
      *  Parameters:
      *   i_url         - The URL.
      *   o_file        - The file name of a URL of type 'mbr'.
      *   o_lib         - The library name of a URL of type 'mbr'.
      *   o_mbr         - The member name of a URL of type 'mbr'.
      *   o_rc          - Return code. 0 = no errror.
      *
      *  Returns:
      *   isOK          - Returns cTrue on success, else cFalse.
      *=========================================================================
     P Url_getMbr...
     P                 B                   export
      *
     D Url_getMbr...
     D                 PI              N
     D  i_url                              const  like(url_t    )
     D  o_file                       10A          options(*nopass: *omit)
     D  o_lib                        10A          options(*nopass: *omit)
     D  o_mbr                        10A          options(*nopass: *omit)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Funktionswert
     D isDone          S               N   inz(cFalse)
      *
      *  Parameterpositionen
     D p_file          C                   const(2)
     D p_lib           C                   const(3)
     D p_mbr           C                   const(4)
     D p_rc            C                   const(5)
      *
      *  Felder fr optionale Parameter
     D file            S                   like(o_file   ) inz
     D lib             S                   like(o_lib    ) inz
     D mbr             S                   like(o_mbr    ) inz
     D rc              S                   like(o_rc     ) inz
      *
      *  Lokale Arbeitsfelder
     D isPresent       S             10I 0 inz
     D protocol        S                   like(url_t         ) inz
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dou '1';
            parsedUrl = parseUrl(i_URL: rc);
            if (rc <> 0);
               leave;
            endif;

            protocol = Url_getProtocol(parsedUrl: rc);
            if (rc <> 0);
               leave;
            endif;

            if (protocol <> 'mbr');
               o_rc = cURL_ERROR_UNSUPPORTED_OPERATION;
               leave;
            endif;

            if (not splittPath(parsedUrl: '*FIRST': file: lib: mbr: rc));
               leave;
            endif;

         enddo;

         // Set values of optional parameters ...
         // ... file
         if (%parms() >= p_file);
            CEETSTA(isPresent: p_file: *omit);
            if (isPresent = 1);
               o_file = file;
            endif;
         endif;

         // ... lib
         if %parms() >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
            if (isPresent = 1);
               o_lib = lib;
            endif;
         endif;

         // ... mbr
         if %parms() >= p_mbr;
            CEETSTA(isPresent: p_mbr: *omit);
            if (isPresent = 1);
               o_mbr = mbr;
            endif;
         endif;

         if (%parms() >= p_rc);
            CEETSTA(isPresent: p_rc: *omit);
            if (isPresent = 1);
               o_rc = rc;
            endif;
         else;
            if (rc <> 0);
               p_assert(cFalse:
                        'Failed to get file, library, member. Error code: ' +
                         %char(rc));
            endif;
         endif;

         return cTrue;

      /END-FREE
      *
     P Url_getMbr...
     P                 E
      *
      *=========================================================================
      *  Parses a given URL.
      *=========================================================================
     P parseUrl...
     P                 B
      *
     D parseUrl...
     D                 PI                         likeds(parsedUrl_t )
     D  i_url                              const  like(url_t         )
     D  o_rc                         10I 0
      *
      *  Return value
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      *
      *  Helper fields
     D itemStart       S             10I 0 inz
     D protocol        S             20A   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_url = '');
            o_rc = cURL_ERROR_EMPTY_URL;
            return parsedUrl;
         endif;

         if f_left(i_url: %len(parsedUrl_t.type)) = cHANDLE_TYPE;
            o_rc = 0;
            return i_url;
         endif;

         clear parsedUrl;
         parsedUrl.data = %trimR(i_url);

         // Get protocol from URL
         parsedUrl.pos = 1;
         itemStart = parsedUrl.pos;
         dow (parsedUrl.pos <= %len(parsedUrl.data)) and
             (parsedUrl.protocol.start = 0);
            select;
            when f_containsStringAt(parsedUrl.data: parsedUrl.pos
                                                  : cEND_OF_PROTOCOL);

               parsedUrl.protocol.start  = itemStart;
               parsedUrl.protocol.length = parsedUrl.pos - itemStart;

               parsedUrl.protocol.baseStart   = itemStart;
               parsedUrl.protocol.totalLength = parsedUrl.pos - itemStart + 1;

               parsedUrl.pos = parsedUrl.pos + %len(cEND_OF_PROTOCOL);
            other;
               parsedUrl.pos = parsedUrl.pos + 1;
            endsl;
         enddo;

         // Failed to retrieve protocol ==> error
         if parsedUrl.protocol.length = 0;
            o_rc = cURL_ERROR_NO_PROTOCOL;
            return parsedUrl;
         endif;

         protocol = f_lcase(getSubstring(parsedUrl.data: parsedUrl.protocol));

         // Unknown protocol ==> error
         if (protocol <> 'http' ) and (protocol <> 'https' ) and
            (protocol <> 'ftp'  ) and (protocol <> 'ftps'  ) and
            (protocol <> 'file' ) and (protocol <> 'mbr'   );
            o_rc = cURL_ERROR_UNSUPPORTED_PROTOCOL;
            return parsedUrl;
         endif;

         // Parse URL for protocol ...
         select;
         other;
            parsedUrl = parseStandardUrl(parsedUrl: o_rc);
         endsl;

         // Set missing start position and length information ...
         // ... protocol (should not happen)
         if (parsedUrl.protocol.length = 0);
            parsedUrl.protocol.start     = 1;
            parsedUrl.protocol.baseStart = parsedUrl.protocol.start;
         endif;
         // ... host
         if (parsedUrl.host.length = 0);
            parsedUrl.host.start     = parsedUrl.protocol.baseStart +
                                       parsedUrl.protocol.totalLength;
            parsedUrl.host.baseStart = parsedUrl.host.start;
         endif;
         // ... port
         if (parsedUrl.port.length = 0);
            parsedUrl.port.start     = parsedUrl.host.baseStart +
                                       parsedUrl.host.totalLength;
            parsedUrl.port.baseStart = parsedUrl.port.start;
         endif;
         // ... path
         if (parsedUrl.path.length) = 0;
            parsedUrl.path.start     = parsedUrl.port.baseStart +
                                       parsedUrl.port.totalLength;
            parsedUrl.path.baseStart = parsedUrl.path.start;
         endif;
         // ... file
         if (parsedUrl.file.length) = 0;
            parsedUrl.file.start     = parsedUrl.port.baseStart +
                                       parsedUrl.port.totalLength;
            parsedUrl.file.baseStart = parsedUrl.file.start;
         endif;
         // ... query
         if (parsedUrl.query.length) = 0;
            parsedUrl.query.start     = parsedUrl.path.baseStart +
                                        parsedUrl.path.totalLength;
            parsedUrl.query.baseStart = parsedUrl.query.start;
         endif;

         o_rc = 0;

         return parsedUrl;

      /END-FREE
      *
     P parseUrl...
     P                 E
      *
      *=========================================================================
      *  Parsen Standard-URL
      *=========================================================================
     P parseStandardUrl...
     P                 B
      *
     D parseStandardUrl...
     D                 PI                         likeds(parsedUrl_t )
     D  i_parsedUrl                        const  likeds(parsedUrl_t )
     D  o_rc                         10I 0
      *
      *  Funktionswert
     D parsedUrl       DS                  likeds(parsedUrl_t ) inz
      *
      *  Lokale Arbeitsfelder
     D baseStart       S             10I 0 inz
     D itemStart       S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         parsedUrl = i_parsedUrl;

         // Get host name from URL
         if (f_containsStringAt(parsedUrl.data
                                : parsedUrl.pos
                                : cSTART_OF_HOST));
            baseStart = parsedUrl.pos;
            parsedUrl.pos = parsedUrl.pos + %len(cSTART_OF_HOST);
            itemStart = parsedUrl.pos;
            dow (parsedUrl.pos <= %len(parsedUrl.data)) and
                (parsedUrl.host.start = 0);
               select;
               when f_containsStringAt(parsedUrl.data: parsedUrl.pos
                                                     : cSTART_OF_FILE);
                  parsedUrl.host.start  = itemStart;
                  parsedUrl.host.length = parsedUrl.pos - itemStart;

                  parsedUrl.host.baseStart   = baseStart;
                  parsedUrl.host.totalLength = parsedUrl.pos - baseStart;

               when f_containsStringAt(parsedUrl.data: parsedUrl.pos
                                                     : cSTART_OF_PORT);
                  parsedUrl.host.start  = itemStart;
                  parsedUrl.host.length = parsedUrl.pos - itemStart;

                  parsedUrl.host.baseStart   = baseStart;
                  parsedUrl.host.totalLength = parsedUrl.pos - baseStart;

               other;
                  parsedUrl.pos = parsedUrl.pos + 1;
               endsl;
            enddo;
         endif;

         // Get port number from URL
         if (f_containsStringAt(parsedUrl.data: parsedUrl.pos: cSTART_OF_PORT));
            baseStart = parsedUrl.pos;
            parsedUrl.pos = parsedUrl.pos + %len(cSTART_OF_PORT);
            itemStart = parsedUrl.pos;
            dow (parsedUrl.pos <= %len(parsedUrl.data)) and
                (parsedUrl.port.start = 0);
               select;
               when parsedUrl.pos = %len(parsedUrl.data) or
                    f_containsStringAt(parsedUrl.data: parsedUrl.pos
                                                     : cSTART_OF_FILE);
                  if (parsedUrl.pos = %len(parsedUrl.data));
                     parsedUrl.pos = parsedUrl.pos + 1;
                  endif;

                  parsedUrl.port.start  = itemStart;
                  parsedUrl.port.length = parsedUrl.pos - itemStart;

                  parsedUrl.port.baseStart   = baseStart;
                  parsedUrl.port.totalLength = parsedUrl.pos - baseStart;

               when f_containsInvalidCharAt(parsedUrl.data: parsedUrl.pos
                                                          : '0123456789');
                  // Stop parsing on invalid character
                  o_rc = cURL_ERROR_INVALID_PORT_NUMBER;
                  return parsedUrl;
               other;
                  parsedUrl.pos = parsedUrl.pos + 1;
               endsl;
            enddo;
         endif;

         // Get file / path / query from URL
         //    File  :  path + query
         //    Path  :  path of the file without trailing parameters (query)
         //    Query :  parameters (query)
         if (parsedUrl.pos <= %len(parsedUrl.data));

            // Info: File = Path + Query
            parsedUrl.file.start  = parsedUrl.pos;
            parsedUrl.file.length = %len(parsedUrl.data) - parsedUrl.pos + 1;
            parsedUrl.file.baseStart   = parsedUrl.file.start;
            parsedUrl.file.totalLength = parsedUrl.file.length;

            parsedUrl.path = parsedUrl.file;

            dow (parsedUrl.pos <= %len(parsedUrl.data));
               if (f_containsStringAt(parsedUrl.data: parsedUrl.pos
                                                    : cSTART_OF_QUERY));

                  parsedUrl.path.length = parsedUrl.pos -
                                          parsedUrl.path.start;
                  parsedUrl.path.totalLength = parsedUrl.path.length;

                  if (parsedUrl.pos < %len(parsedUrl.data));
                     parsedUrl.query.start  = parsedUrl.pos + 1;
                     parsedUrl.query.length = %len(parsedUrl.data) -
                                              parsedUrl.pos;
                     parsedUrl.query.baseStart   = parsedUrl.query.start - 1;
                     parsedUrl.query.totalLength = parsedUrl.query.length + 1;
                  else;
                     parsedUrl.query.start  = 0;
                     parsedUrl.query.length = 0;
                     parsedUrl.query.baseStart   = 0;
                     parsedUrl.query.totalLength = 0;
                  endif;

                  leave;
               endif;

               parsedUrl.pos = parsedUrl.pos + 1;
            enddo;

         endif;

         parsedUrl.type = cHANDLE_TYPE;

         o_rc = 0;

         return parsedUrl;

      /END-FREE
      *
     P parseStandardUrl...
     P                 E
      *
      *=========================================================================
      *  Returns the sub-string defined by 'i_subString'.
      *=========================================================================
     P getSubstring...
     P                 B
      *
     D getSubstring...
     D                 PI           512A          varying
     D  i_string                    512A   const  varying
     D  i_subString                        const  likeds(substr_t )
      *
      *  Return value
     D string          S            512A   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_subString.start  > 0) and
            (i_subString.length > 0) and
            (%len(i_string) >= i_subString.start + i_subString.length - 1);
            string = %subst(i_string: i_subString.start: i_subString.length);
         else;
            string = '';
         endif;

         return string;

      /END-FREE
      *
     P getSubstring...
     P                 E
      *
      *=========================================================================
      *  Breaks a given URL into the pieces: library, file and member
      *=========================================================================
     P splittPath...
     P                 B
      *
     D splittPath...
     D                 PI              N   opdesc
     D  i_url                              const  likeds(parsedUrl_t )
     D  i_dftObj                    256A   const  options(*varsize)
     D  o_file                       10A
     D  o_lib                        10A
     D  o_obj                       256A          options(*varsize)
     D  o_rc                         10I 0
      *
      *  Parameter positions
     D p_dftObj        C                   const(2)
     D p_obj           C                   const(5)
      *
      *  Helper fields
     D x               S             10I 0 inz
     D path            S                   like(url_t    ) inz
     D closingChar     S              1A   inz
      *
     D isError         S               N   inz(cFalse)
      *
     D dftObj          S                   like(i_dftObj ) inz
     D file            S                   like(o_file   ) inz
     D lib             S                   like(o_lib    ) inz
     D obj             S                   like(o_obj    ) inz
      *
     D dftObjInf       DS                  likeds(strInf_t) inz
     D objInf          DS                  likeds(strInf_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         CEEGSI(p_dftObj: dftObjInf.dataType
                        : dftObjInf.curlen
                        : dftObjInf.maxlen  : *omit);

         CEEGSI(p_obj: objInf.dataType
                     : objInf.curlen
                     : objInf.maxlen  : *omit);

         if (dftObjInf.curlen > 0);
            dftObj = %subst(i_dftObj: 1: dftObjInf.curlen);
         else;
            dftObj = '';
         endif;

         o_file = '';
         o_lib  = '';
         %subst(o_obj: 1 : objInf.curlen ) = '';
         o_rc   = 0;

         dou '1';

            path = f_ucase(%trim(Url_getPath(i_url: o_rc)));
            if (o_rc <> 0);
               isError = cTrue;
               leave;
            endif;

            // Get library name from path
            x = %scan('/': path);

            select;
            when x > 11;
               isError = cTrue;
               leave;
            when x > 1;
               lib = %subst(path: 1: x-1);
               if (x < %len(path));
                  path = %subst(path: x+1);
               else;
                  isError = cTrue;
                  leave;
               endif;
            when x = 1;
               lib = '*LIBL';
               path = %subst(path: x+1);
            other;
               lib = '*LIBL';
            endsl;

            // Get file name from path
            x = %scan('(': path);
            if (x > 0);
               closingChar = ')';
            else;
               x = %scan('.': path);
               if (x > 0);
                  closingChar = '';
               else;
                  x = %len(path) + 1;
               endif;
            endif;

            select;
            when x > 11;
               isError = cTrue;
               leave;
            when x > 1;
               file = %subst(path: 1: x-1);
               if (x < %len(path));
                  path = %subst(path: x+1);
               else;
                  if (dftObj <> '');
                     obj = dftObj;
                  else;
                     isError = cTrue;
                  endif;
                  leave;
               endif;
            when x = 1;
               isError = cTrue;
               leave;
            endsl;

            // Get member name from path
            if (closingChar = '');
               x = %len(path) + 1;
            else;
               x = %scan(closingChar: path);
               if (x = 0);
                  isError = cTrue;
                  leave;
               endif;
            endif;

            select;
            when x > 11;
               isError = cTrue;
               leave;
            when x > 1;
               obj = %subst(path: 1: x-1);
            other;
               isError = cTrue;
               leave;
            endsl;

         enddo;

         if (isError);
            o_rc = cURL_ERROR_INVALID_OBJECT_DATA;
            return cFalse;
         endif;

         o_file = file;
         o_lib  = lib;
         %subst(o_obj: 1 : objInf.curlen ) = obj;

         return cTrue;

      /END-FREE
      *
     P splittPath...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RE  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RE "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Date and Time            "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      // -------------------------------------------------------------------
      //  BASICS1RC  - SrvPgm: Basic Routines - Date and Time
      // -------------------------------------------------------------------
      //  Author  :  Thomas Raddatz
      //  Date    :  19.02.2009
      //  E-mail  :  thomas.raddatz@Tools400.de
      //  Homepage:  www.tools400.de
      // -------------------------------------------------------------------
      //
      //  This software is free software, you can redistribute it and/or
      //  modify it under the terms of the GNU General Public License (GPL)
      //  as published by the Free Software Foundation.
      //
      //  See GNU General Public License for details.
      //          http://www.opensource.org
      //          http://www.opensource.org/licenses/gpl-license.html
      //
      // -------------------------------------------------------------------
      //  History:
      //
      //  Datum       Name          nderung
      //  ----------  ------------  ---------------------------------------
      //
      // -------------------------------------------------------------------
      //   >>PRE-COMPILER<<
      //
      //     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +
      //                              SRCFILE(&SL/&SF) +
      //                              SRCMBR(&SM);
      //
      //     >>COMPILE<<
      //       >>PARM<< TRUNCNBR(*NO);
      //       >>PARM<< DBGVIEW(*LIST);
      //       >>PARM<< TGTRLS(V6R1M0);
      //     >>END-COMPILE<<
      //
      //     >>EXECUTE<<
      //
      //   >>END-PRE-COMPILER<<
      // -------------------------------------------------------------------
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*

      // -----------------------------------------
      //  Exported functions
      // -----------------------------------------
      /COPY QBASICS1,PBASICS1RE

      // -----------------------------------------
      //  Reference fields
      // -----------------------------------------
      /COPY QBASICS1,BASICS1R0

      // -----------------------------------------
      //  Imported Prototypes
      // -----------------------------------------
      /COPY QBASICS1,QWCCVTDT                      Convert Date and Time Format (QWCCVTDT) API
      /COPY QBASICS1,PBASICS1R2                    API Error Handling

      // -----------------------------------------
      //  Private prototypes
      // -----------------------------------------

      // -----------------------------------------
      //  Global constants
      // -----------------------------------------

     D EPOCHSTART      s               z   inz(z'1970-01-01-00.00.00.000000')

      // -----------------------------------------
      //  Global fields
      // -----------------------------------------

      // -----------------------------------------------------------------------
      //  Produces a date from a given year, month and day.
      // -----------------------------------------------------------------------
      //  Parameters:
      //   i_year        - Year of the date. Range: 1-9999
      //   i_month       - Day of the date. Any numeric value.
      //   i_day         - Day of the date. Any numeric value.
      //
      //  Returns:
      //   date          - Date.
      // -----------------------------------------------------------------------
     P f_dateSerial...
     P                 b                   export
     D                 pi              D
     D  i_year                       10I 0 const
     D  i_month                      10I 0 const
     D  i_day                        10I 0 const

      //  Return value
     D date            s               D   inz

      //  Helper fields
     D tmpDate         s             10A   inz
      /free

         tmpDate = %editc(%dec(i_year: 4: 0): 'X') + '-' + '01' + '-' + '01';
         date = %date(tmpDate: *ISO);
         date = date + %months(i_month-1);
         date = date + %days(i_day-1);

         return date;

      /end-free
     P                 e

      // -----------------------------------------------------------------------
      //  Converts an epoch date to a RPG timestamp.
      // -----------------------------------------------------------------------
      //  Parameters:
      //
      //   i_epochSecs   - The UNIX timestamp, in UNIX epoch format (number of
      //                   seconds since midnight, Jan 1, 1970).
      //   i_adjustUTC   - Determine whether the time should be adjusted by the
      //                   UTC offset.
      //                   true  - adjust for UTC offset
      //                   false - do not adjust for UTC offset
      //
      //  Returns:
      //   timestamp     - RPG timestamp value
      // -----------------------------------------------------------------------
     P f_cvtEpochTS...
     P                 b                   export
     D                 pi              z
     D  i_epochSecs                  10i 0 const
     D  i_adjustUTC                    n   const options(*nopass: *omit)

      // Return value
     D timestamp       s               z   inz

      // Parameter position
     D p_adjustUTC     c                   2

      // Optional parameters
     D adjustUTC       s                   like(i_adjustUTC)

      // Variables.
     D utc             ds                  likeds(cee_utco_t) inz
      /free

         if (%parms() >= p_adjustUTC and %addr(i_adjustUTC) <> *null);
            adjustUTC = i_adjustUTC;
         else;
            adjustUTC = cTrue;
         endif;

         timestamp = EPOCHSTART + %seconds(i_epochSecs);
         if (adjustUTC);
              CEEUTCO(utc.offHours: utc.offMins: utc.offSecs);
              timestamp = timestamp + %seconds(%int(utc.offSecs));
         endif;

         return timestamp;

      /end-free
     p                 e

      // -----------------------------------------------------------------------
      //  Converts a RPG timestamp to an epoch value.
      // -----------------------------------------------------------------------
      //  Parameters:
      //
      //   i_timestamp   - The OS/400 timestamp value.
      //   i_adjustUTC   - Determine whether the time should be adjusted by the
      //                   UTC offset.
      //                   true  - adjust for UTC offset
      //                   false - do not adjust for UTC offset
      //
      //  Returns:
      //   epoch         - Epoch value
      // -----------------------------------------------------------------------
     P f_cvtTSEpoch...
     P                 b                   export
     D                 pi            10i 0
     D  i_timestamp                    z   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)

      // Return value
     D epochSecs       s             10i 0 inz

      // Parameter position
     D p_adjustUTC     c                   2

      // Optional parameters
     D adjustUTC       s                   like(i_adjustUTC)

      // Constants.
     D PIC_TIMESTAMP   c                   'YYYY-MM-DD-HH.MI.SS.999999'

      // Variables.
     D utc             ds                  likeds(cee_utco_t) inz
     D tsSecs          s              8f   inz
     D epochStartSecs  s              8f   inz
      /free

         if (%parms() >= p_adjustUTC and %addr(i_adjustUTC) <> *null);
            adjustUTC = i_adjustUTC;
         else;
            adjustUTC = cTrue;
         endif;

         CEESECS(%char(i_timestamp): PIC_TIMESTAMP: tsSecs: *omit);
         CEESECS(%char(EPOCHSTART): PIC_TIMESTAMP: epochStartSecs: *omit);

         epochSecs = tsSecs - epochStartSecs;
         if (adjustUTC);
              CEEUTCO(utc.offHours: utc.offMins: utc.offSecs);
              epochSecs = epochSecs - %int(utc.offSecs);
         endif;

         return epochSecs;

      /end-free
     p                 e

      // -----------------------------------------------------------------------
      //  Converts a MI time value to a RPG timestamp.
      // -----------------------------------------------------------------------
      //  Parameters:
      //
      //   i_miTime      - MI time value.
      //   i_adjustUTC   - Determine whether the time should be adjusted by the
      //                   UTC offset.
      //                   true  - adjust for UTC offset
      //                   false - do not adjust for UTC offset
      //
      //  Returns:
      //   timestamp     - RPG timestamp value
      // -----------------------------------------------------------------------
     P f_cvtMiTimeTS...
     P                 b                   export
     D                 pi              z
     D  i_miTime                     20a   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)

      // Return value
     D timestamp       s               z   inz

      // Parameter position
     D p_adjustUTC     c                   2

      // Optional parameters
     D adjustUTC       s                   like(i_adjustUTC)

      // Variables
     D tmpDate         ds                  qualified
     D  date                   1      8a   inz('00010101')
     D  time                   9     14a   inz('000000')
     D  mSecs                 15     20a   inz('000000')
     D utc             ds                  likeds(cee_utco_t) inz
     D timeZone        s            116a
     D errCode         ds                  likeds(errCode_t) inz
      /free

         if (%parms() >= p_adjustUTC and %addr(i_adjustUTC) <> *null);
            adjustUTC = i_adjustUTC;
         else;
            adjustUTC = cTrue;
         endif;

         errCode = f_newApiErrCode(cFalse);
         QWCCVTDT('*DTS' : i_miTime : '*YYMD' : tmpDate: errCode
                  : '*JOB': '*JOB': timeZone: %len(timeZone): '1');

         timestamp = %date(tmpDate.date: *ISO0) +
                     %time(tmpDate.time: *ISO0);
         timestamp += %mseconds(%int(tmpDate.mSecs));

         if (not adjustUTC);
              CEEUTCO(utc.offHours: utc.offMins: utc.offSecs);
              timestamp = timestamp - %seconds(%int(utc.offSecs));
         endif;

         return timestamp;

      /end-free
     p                 e

      // -----------------------------------------------------------------------
      //  Converts a RPG timestamp to an epoch value.
      // -----------------------------------------------------------------------
      //  Parameters:
      //
      //   i_timestamp   - The OS/400 timestamp value.
      //   i_adjustUTC   - Determine whether the time should be adjusted by the
      //                   UTC offset.
      //                   true  - adjust for UTC offset
      //                   false - do not adjust for UTC offset
      //
      //  Returns:
      //   epoch         - Epoch value
      // -----------------------------------------------------------------------
     P f_cvtTSMiTime...
     P                 b                   export
     D                 pi            20a
     D  i_timestamp                    z   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)

      // Return value
     D miTime          s             20a   inz(*ALLx'00')

      // Parameter position
     D p_adjustUTC     c                   2

      // Optional parameters
     D adjustUTC       s                   like(i_adjustUTC)

      // Variables
     D timestamp       s                   like(i_timestamp)
     D tmpDate         ds                  qualified
     D  date                   1      8a   inz('00010101')
     D  time                   9     14a   inz('000000')
     D  mSecs                 15     20a   inz('000000')
     D utc             ds                  likeds(cee_utco_t) inz
     D timeZone        s            116a
     D errCode         ds                  likeds(errCode_t) inz
      /free

         if (%parms() >= p_adjustUTC and %addr(i_adjustUTC) <> *null);
            adjustUTC = i_adjustUTC;
         else;
            adjustUTC = cTrue;
         endif;

         timestamp = i_timestamp;

         if (not adjustUTC);
              CEEUTCO(utc.offHours: utc.offMins: utc.offSecs);
              timestamp = timestamp + %seconds(%int(utc.offSecs));
         endif;

         errCode = f_newApiErrCode(cFalse);
         QWCCVTDT('*YYMD' : %char(timestamp: *ISO0) : '*DTS' : miTime: errCode
                  : '*JOB': '*JOB': timeZone: %len(timeZone): '1');

         return miTime;

      /end-free
     p                 e
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RF  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RF "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - System Values            "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RF  - SrvPgm: Basic Routines - System Values                *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  11.04.2010                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RF
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Imported Prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R1
      /COPY QBASICS1,QWCRSVAL                      Retrieve System Values (QWCRSVAL) API
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Retrieves an alpha-numeric system value.
      *=========================================================================
      *  Parameters:
      *   i_name        - System value name.
      *
      *  Returns:
      *   value         - The value of the specified system value.
      *=========================================================================
     P f_rtvSysVal_char...
     P                 B                   export
      *
     D f_rtvSysVal_char...
     D                 PI          4096A          varying
     D  i_name                       10A   const
     D  o_msg                                     likeds(msg_t )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D value           S           4096A   varying inz
      *
      *  Parameter positions
     D p_msg           C                   2
      *
      *  Fields for optional parameters
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Helper fields
     D errCode         DS                  likeds(errCode_t ) inz
     D sysVal          DS                  likeds(QWCRSVAL_rtnValue_t    ) inz
     D sysValTbl       DS                  likeds(QWCRSVAL_sysValInfTbl_t)
     D                                     based(pSysValTbl)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg(cMSG_ID_OK);

         // Check system value name
         p_assert(i_name   = 'QABNORMSW'    or   //  Character    1
                  i_name   = 'QACGLVL'      or   //  Character    80
                  i_name   = 'QALWOBJRST'   or   //  Character    150
                  i_name   = 'QALWUSRDMN'   or   //  Character    500
                  i_name   = 'QASTLVL'      or   //  Character    10
                  i_name   = 'QATNPGM'      or   //  Character    20
                  i_name   = 'QAUDCTL'      or   //  Character    50
                  i_name   = 'QAUDENDACN'   or   //  Character    10
                  i_name   = 'QAUDLVL'      or   //  Character    160
                  i_name   = 'QAUTOCFG'     or   //  Character    1
                  i_name   = 'QAUTORMT'     or   //  Character    1
                  i_name   = 'QAUTOSPRPT'   or   //  Character    1
                  i_name   = 'QCENTURY'     or   //  Character    1
                  i_name   = 'QCFGMSGQ'     or   //  Character    20
                  i_name   = 'QCHRID'       or   //  Character    20
                  i_name   = 'QCHRIDCTL'    or   //  Character    10
                  i_name   = 'QCMNARB'      or   //  Character    10
                  i_name   = 'QCMNRCYLMT'   or   //  Character    20
                  i_name   = 'QCNTRYID'     or   //  Character    2
                  i_name   = 'QCONSOLE'     or   //  Character    10
                  i_name   = 'QCRTAUT'      or   //  Character    10
                  i_name   = 'QCRTOBJAUD'   or   //  Character    10
                  i_name   = 'QCTLSBSD'     or   //  Character    20
                  i_name   = 'QCURSYM'      or   //  Character    1
                  i_name   = 'QDATE'        or   //  Character    5 (for Julian dates) or 6
                  i_name   = 'QDATFMT'      or   //  Character    3
                  i_name   = 'QDATSEP'      or   //  Character    1
                  i_name   = 'QDAY'         or   //  Character    2 or 3 (for Julian dates)
                  i_name   = 'QDAYOFWEEK'   or   //  Character    4
                  i_name   = 'QDBFSTCCOL'   or   //  Character    10
                  i_name   = 'QDBRCVYWT'    or   //  Character    1
                  i_name   = 'QDECFMT'      or   //  Character    1
                  i_name   = 'QDEVNAMING'   or   //  Character    10
                  i_name   = 'QDEVRCYACN'   or   //  Character    20
                  i_name   = 'QDSCJOBITV'   or   //  Character    10
                  i_name   = 'QDSPSGNINF'   or   //  Character    1
                  i_name   = 'QDYNPTYADJ'   or   //  Character    1
                  i_name   = 'QDYNPTYSCD'   or   //  Character    1
                  i_name   = 'QFRCCVNRST'   or   //  Character    1
                  i_name   = 'QHOUR'        or   //  Character    2
                  i_name   = 'QIGC'         or   //  Character    1
                  i_name   = 'QIGCCDEFNT'   or   //  Character    20
                  i_name   = 'QINACTITV'    or   //  Character    10
                  i_name   = 'QINACTMSGQ'   or   //  Character    20
                  i_name   = 'QIPLDATTIM'   or   //  Character    20
                  i_name   = 'QIPLSTS'      or   //  Character    1
                  i_name   = 'QIPLTYPE'     or   //  Character    1
                  i_name   = 'QJOBMSGQFL'   or   //  Character    10
                  i_name   = 'QKBDBUF'      or   //  Character    10
                  i_name   = 'QKBDTYPE'     or   //  Character    3
                  i_name   = 'QLANGID'      or   //  Character    3
                  i_name   = 'QLIBLCKLVL'   or   //  Character    1
                  i_name   = 'QLMTDEVSSN'   or   //  Character    1
                  i_name   = 'QLMTSECOFR'   or   //  Character    1
                  i_name   = 'QLOCALE'      or   //  Character    1024
                  i_name   = 'QMAXSGNACN'   or   //  Character    1
                  i_name   = 'QMAXSIGN'     or   //  Character    6
                  i_name   = 'QMINUTE'      or   //  Character    2
                  i_name   = 'QMLTTHDACN'   or   //  Character    1
                  i_name   = 'QMODEL'       or   //  Character    4
                  i_name   = 'QMONTH'       or   //  Character    2
                  i_name   = 'QPASTHRSVR'   or   //  Character    10
                  i_name   = 'QPFRADJ'      or   //  Character    1
                  i_name   = 'QPRBFTR'      or   //  Character    20
                  i_name   = 'QPRCFEAT'     or   //  Character    4
                  i_name   = 'QPRCMLTTSK'   or   //  Character    1
                  i_name   = 'QPRTDEV'      or   //  Character    10
                  i_name   = 'QPRTKEYFMT'   or   //  Character    10
                  i_name   = 'QPRTTXT'      or   //  Character    30
                  i_name   = 'QPWDEXPITV'   or   //  Character    6
                  i_name   = 'QPWDLMTAJC'   or   //  Character    1
                  i_name   = 'QPWDLMTCHR'   or   //  Character    10
                  i_name   = 'QPWDLMTREP'   or   //  Character    1
                  i_name   = 'QPWDPOSDIF'   or   //  Character    1
                  i_name   = 'QPWDRQDDGT'   or   //  Character    1
                  i_name   = 'QPWDRQDDIF'   or   //  Character    1
                  i_name   = 'QPWDVLDPGM'   or   //  Character    20
                  i_name   = 'QPWRRSTIPL'   or   //  Character    1
                  i_name   = 'QQRYDEGREE'   or   //  Character    10
                  i_name   = 'QQRYTIMLMT'   or   //  Character    10
                  i_name   = 'QRCLSPLSTG'   or   //  Character    10
                  i_name   = 'QRETSVRSEC'   or   //  Character    1
                  i_name   = 'QRMTIPL'      or   //  Character    1
                  i_name   = 'QRMTSRVATR'   or   //  Character    1
                  i_name   = 'QRMTSIGN'     or   //  Character    20
                  i_name   = 'QSCPFCONS'    or   //  Character    1
                  i_name   = 'QSECOND'      or   //  Character    2
                  i_name   = 'QSECURITY'    or   //  Character    2
                  i_name   = 'QSETJOBATR'   or   //  Character    160
                  i_name   = 'QSFWERRLOG'   or   //  Character    10
                  i_name   = 'QSHRMEMCTL'   or   //  Character    1
                  i_name   = 'QSPCENV'      or   //  Character    10
                  i_name   = 'QSPLFACN'     or   //  Character    10
                  i_name   = 'QSRLNBR'      or   //  Character    8
                  i_name   = 'QSRTSEQ'      or   //  Character    20
                  i_name   = 'QSRVDMP'      or   //  Character    10
                  i_name   = 'QSTGLOWACN'   or   //  Character    10
                  i_name   = 'QSTRPRTWTR'   or   //  Character    1
                  i_name   = 'QSTRUPPGM'    or   //  Character    20
                  i_name   = 'QSTSMSG'      or   //  Character    10
                  i_name   = 'QSYSLIBL'     or   //  Character    150
                  i_name   = 'QTIME'        or   //  Character    7, 8, or 9
                  i_name   = 'QTIMSEP'      or   //  Character    1
                  i_name   = 'QTSEPOOL'     or   //  Character    10
                  i_name   = 'QUPSDLYTIM'   or   //  Character    20
                  i_name   = 'QUPSMSGQ'     or   //  Character    20
                  i_name   = 'QUSEADPAUT'   or   //  Character    10
                  i_name   = 'QUSRLIBL'     or   //  Character    2750
                  i_name   = 'QUTCOFFSET'   or   //  Character    5
                  i_name   = 'QVFYOBJRST'   or   //  Character    1
                  i_name   = 'QYEAR'        :    //  Character    2                         //RADDAT
                  'Invalid system value name specified: ' + i_name);

         dou '1';

            errCode = f_newApiErrCode(cTrue);
            QWCRSVAL(sysVal: %size(sysVal): 1: i_name: errCode);

            if (f_isApiError(errCode));
               msg = f_cvtApiErrCodeToMsg(errCode);
               leave;
            endif;

            pSysValTbl = %addr(sysVal) + sysVal.ofsSysValTbl(1);

            p_assert(sysValTbl.length <= %len(sysValTbl.data):
                     'Value ' + %char(sysValTbl.length) +
                     ' exceeds maximum length of ' + %char(%size(value)-2));

            value = %subst(sysValTbl.data: 1: sysValTbl.length);
         enddo;

         // Set optional/omissible message parameter
         if (%parms() >= p_msg);
            if (%addr(o_msg) <> *NULL);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return value;

      /END-FREE
      *
     P f_rtvSysVal_char...
     P                 E
      *
      *=========================================================================
      *  Retrieves a numeric system value.
      *=========================================================================
      *  Parameters:
      *   i_name        - System value name.
      *
      *  Returns:
      *   value         - The value of the specified system value.
      *=========================================================================
     P f_rtvSysVal_num...
     P                 B                   export
      *
     D f_rtvSysVal_num...
     D                 PI            15P 5
     D  i_name                       10A   const
     D  o_msg                                     likeds(msg_t )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D value           S             15P 5 inz
      *
      *  Parameter positions
     D p_msg           C                   2
      *
      *  Fields for optional parameters
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Helper fields
     D errCode         DS                  likeds(errCode_t ) inz
     D sysVal          DS                  likeds(QWCRSVAL_rtnValue_t    ) inz
     D sysValTbl       DS                  likeds(QWCRSVAL_sysValInfTbl_t)
     D                                     based(pSysValTbl)
     D fraction        S             10I 0 inz
     D x               S             10I 0 inz
     D binary4         S             10I 0 based(pBinary4)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg(cMSG_ID_OK);

         // Check system value name
         p_assert(i_name   = 'QACTJOB'      or   //  Decimal      (5 0)
                  i_name   = 'QADLACTJ'     or   //  Decimal      (5 0)
                  i_name   = 'QADLSPLA'     or   //  Decimal      (5 0)
                  i_name   = 'QADLTOTJ'     or   //  Decimal      (5 0)
                  i_name   = 'QAUDFRCLVL'   or   //  Decimal      (5 0)
                  i_name   = 'QAUTOVRT'     or   //  Decimal      (5 0)
                  i_name   = 'QBASACTLVL'   or   //  Zoned        (5 0)
                  i_name   = 'QBASPOOL'     or   //  Zoned        (10 0)
                  i_name   = 'QCCSID'       or   //  Decimal      (5 0)
                  i_name   = 'QHSTLOGSIZ'   or   //  Decimal      (5 0)
                  i_name   = 'QIGCFNTSIZ'   or   //  Decimal      (4 1)
                  i_name   = 'QJOBMSGQMX'   or   //  Decimal      (5 0)
                  i_name   = 'QJOBMSGQSZ'   or   //  Decimal      (5 0)
                  i_name   = 'QJOBMSGQTL'   or   //  Decimal      (5 0)
                  i_name   = 'QJOBSPLA'     or   //  Decimal      (5 0)
                  i_name   = 'QLEAPADJ'     or   //  Decimal      (5 0)
                  i_name   = 'QMAXACTLVL'   or   //  Decimal      (5 0)
                  i_name   = 'QMAXJOB'      or   //  Zoned        (10 0)
                  i_name   = 'QMAXSPLF'     or   //  Zoned        (10 0)
                  i_name   = 'QMCHPOOL'     or   //  Zoned        (10 0)
                  i_name   = 'QPRBHLDITV'   or   //  Decimal      (5 0)
                  i_name   = 'QPWDLVL'      or   //  Decimal      (5 0)
                  i_name   = 'QPWDMAXLEN'   or   //  Decimal      (5 0)
                  i_name   = 'QPWDMINLEN'   or   //  Decimal      (5 0)
                  i_name   = 'QPWRDWNLMT'   or   //  Decimal      (5 0)
                  i_name   = 'QSTGLOWLMT'   or   //  Decimal      (7 4)
                  i_name   = 'QSVRAUTITV'   or   //  Decimal      (6 0)
                  i_name   = 'QTOTJOB'      :    //  Decimal      (5 0)
                  'Invalid system value name specified: ' + i_name);

         dou '1';

            errCode = f_newApiErrCode(cTrue);
            QWCRSVAL(sysVal: %size(sysVal): 1: i_name: errCode);

            if (f_isApiError(errCode));
               msg = f_cvtApiErrCodeToMsg(errCode);
               leave;
            endif;

            pSysValTbl = %addr(sysVal) + sysVal.ofsSysValTbl(1);

            p_assert(sysValTbl.length = 4
                     : 'Size of system value ' + i_name +
                       ' does not match expected integer size of 4');

            select;
            when (sysValTbl.sysVal = 'QIGCFNTSIZ');   //  Decimal      (4 1)
               fraction = 1;
            when (sysValTbl.sysVal = 'QSTGLOWLMT');   //  Decimal      (7 4)
               fraction = 4;
            other;
               fraction = 0;
            endsl;

            pBinary4 = %addr(sysValTbl.data);
            value = binary4;
            for x = 1 to fraction;
               value = value / 10;
            endfor;
         enddo;

         // Set optional/omissible message parameter
         if (%parms() >= p_msg);
            if (%addr(o_msg) <> *NULL);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return value;

      /END-FREE
      *
     P f_rtvSysVal_num...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RG  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RG "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicProperties          "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RG  - SrvPgm: Basic Routines - BasicProperties              *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  06.05.2011                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs w/o DECEDIT(...)
      /DEFINE NO_DECEDIT
      /COPY QBASICS1,H_SPEC
     H DECEDIT('0.')
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
     FPROPERTIESIF   F  512        DISK    usropn
     F                                     extfile(g_properties.file)
     F                                     extmbr(g_properties.name)
     F                                     infds(g_propsOpnInf)
      *
     D g_properties    DS                  qualified
     D  file                         21A   inz
     D  name                         10A   inz
      *
     D g_propsOpnInf   DS                  qualified
     D  rcdLength            125    126I 0
     D  sourceFile           163    163A
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RG
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D hProperties_t   DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  pMap                               like(BasicMap_handle_t)
     D  increment                    10I 0
     D  heapID                       10I 0
     D  memMgr                             likeds(MemoryManager_manager_t)
      *
     D readLine_line_t...
     D                 S           1024A   varying     based(pDummy)
      *
      * -----------------------------------------
      *  Imported Prototypes
      * -----------------------------------------
      /COPY QBASICS1,CLIB                          C-Prototypes
      /COPY QBASICS1,PBASICS1RC                    BasicMap
      *
     D property_t      DS                  qualified               based(pDummy)
     D  key                         512A   varying
     D  value                       512A   varying
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Reads a line from a given file descriptor.
     D readLine...
     D                 PR            10I 0        extproc('readLine')
     D  i_fd                         10I 0 const
     D  io_line                                   like(readLine_line_t)
     D  i_isFirstLine                  N   const
      *
      *  Test the specified buffer, splitts the buffer and adds the property
      *  to the property list.
     D retrieveAndAddPropertyToMap...
     D                 PR
     D                                            extproc('+
     D                                            retrieveAndAddPropertyToMap')
     D  i_pMap                             const  like(BasicMap_handle_t    )
     D  i_buffer                   4096A   const  varying  options(*varsize)
      *
      *  Adds the specified key and value to the map.
     D addPropertyToMap...
     D                 PR            10I 0
     D                                            extproc('+
     D                                            addPropertyToMap')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_property                         const  likeds(property_t      )
      *
      *  Returns the value that is associated to a given key
      *  from the specified map.
     D getStringFromMap...
     D                 PR              N
     D                                            extproc('+
     D                                            getStringFromMap')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D  o_string                                  like(property_t.value  )
      *
      *  Checks, whether a given handle is a valid properties handle, or not.
     D checkPropertiesHandle...
     D                 PR
     D                                            extproc('+
     D                                            checkPropertiesHandle')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Sends an ESCAPE message to signal an error condition.
     D signalError...
     D                 PR
     D                                            extproc('signalError')
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Send message to the job log.
     D sendToJobLog...
     D                 PR
     D                                            extproc('sendToJobLog')
     D  i_text                      512A   const  varying
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D cHANDLE_TYPE_PROPERTIES...
     D                 C                   const(6689984643550298433)           =  *Props
     D cHANDLE_PROPERTIES_SIZE...
     D                 C                   const(%size(hProperties_t))
      *
     D cERROR_PROPERTIES_HANDLE_NULL...
     D                 C                   const('Properties handle is NULL')
     D cERROR_PROPERTIES_HANDLE_INVALID...
     D                 C                   const('Properties handle is invalid')
      *
     D BOOLEAN_FALSE...
     D                 C                   'false'
     D BOOLEAN_TRUE...
     D                 C                   'true'
     D BOOLEAN_0...
     D                 C                   '0'
     D BOOLEAN_1...
     D                 C                   '1'
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a new BasicProperties.
      *=========================================================================
      *  Parameters:
      *   i_heapID       - ID of the heap that is used to allocate memory.
      *
      *  Returns:
      *   pProperties    - Returns the basing pointer of the properties on
      *                    success, else NULL.
      *=========================================================================
     P BasicProperties_new...
     P                 B                   export
      *
     D BasicProperties_new...
     D                 PI                         like(BasicProperties_handle_t)
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D pProperties     S                   like(BasicProperties_handle_t) inz
      *
      *  Parameter positions
     D p_increment     C                   const(1)
     D p_heapID        C                   const(1)
      *
      *  Fields for optional parameters
     D increment       S                   like(i_increment ) inz
     D heapID          S                   like(i_heapID    ) inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get values of optional parameters
         // ... i_increment
         if (%parms() >= p_increment and %addr(i_increment) <> *NULL);
            increment = i_increment;
         else;
            increment = 512;
         endif;

         // ... i_heapID
         if (%parms() >= p_heapID and %addr(i_heapID) <> *NULL);
            heapID = i_heapID;
         else;
            heapID = 0;
         endif;

         // Set memory manager
         mm_memMgr = MemoryManager_getDefaultManager();

         // Allocate memory for properties handle
         pProperties = mm_allocate(%size(hProperties_t): heapID);

         // Initialize properties handle
         clear hProperties;
         hProperties.intType   = cHANDLE_TYPE_PROPERTIES;
         hProperties.intSize   = %size(hProperties);
         hProperties.pMap      = BasicMap_new(increment: heapID);
         hProperties.increment = increment;
         hProperties.heapID    = heapID;
         hProperties.memMgr    = mm_memMgr;

         return pProperties;

      /END-FREE
      *
     P BasicProperties_new...
     P                 E
      *
      *=========================================================================
      *  Clones a given BasicProperties.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned by
      *                    BasicProperties_new().
      *
      *  Returns:
      *   pProperties   - Returns the basing pointer of the properies on
      *                   success, else NULL.
      *=========================================================================
     P BasicProperties_clone...
     P                 B                   export
      *
     D BasicProperties_clone...
     D                 PI                         like(BasicProperties_handle_t)
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D pPropertiesRtn  S                   like(BasicProperties_handle_t) inz
     D hPropertiesRtn  DS                  likeds(hProperties_t)
     D                                     based(pPropertiesRtn)
      *
      *  Local fields
     D x               S             10I 0 inz
     D numE            S             10I 0 inz
     D key             S                   like(BasicMap_key_t ) inz
     D size            S             10I 0 inz
     D pData           S               *   inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         // Create a new and empty properties
         pPropertiesRtn = BasicProperties_new(hProperties.increment);

         // Copy properties entries of embedded map
         numE = BasicMap_getNumE(hProperties.pMap);
         for x = 1 to numE;
            key   = BasicMap_getKeyByIndex(hProperties.pMap: x);
            pData = BasicMap_getValueByIndex(hProperties.pMap: x);
            size  = BasicMap_getSizeByIndex(hProperties.pMap: x);
            BasicMap_put(hPropertiesRtn.pMap: key: pData: size);
         endfor;

         return pPropertiesRtn;

      /END-FREE
      *
     P BasicProperties_clone...
     P                 E
      *
      *=========================================================================
      *  Load properties from a given physical file member.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *   i_file         - File that contains the member that contains the
      *                    properties.
      *   i_lib          - (optional) Library that contains the file.
      *   i_mbr          - (optional) Member that contains the properties.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_loadFromMember...
     P                 B                   export
      *
     D BasicProperties_loadFromMember...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_file                       10A   const  varying
     D  i_lib                        10A   const  varying
     D                                            options(*nopass: *omit)
     D  i_mbr                        10A   const  varying
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_lib           C                   const(3)
     D p_mbr           C                   const(4)
      *
      *  Fields for optional parameters
     D lib             S                   like(i_lib ) inz
     D mbr             S                   like(i_mbr ) inz
      *
      *  Local fields
     D length          S             10I 0 inz
     D warnLength      S               N   inz(cTrue)
      *
     D inBufMbr        DS                  qualified
     D  data                        512A
      *
     D inBufSrcMbr     DS                  qualified
     D  srcSeq                        6S 2
     D  srcDat                        6S 0
     D  srcDta                      500A
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         // Get values of optional parameters
         // ... i_lib
         if (%parms() >= p_lib and %addr(i_lib) <> *NULL);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // ... i_mbr
         if (%parms() >= p_mbr and %addr(i_mbr) <> *NULL);
            mbr = i_mbr;
         else;
            mbr = '*FIRST';
         endif;

         // Check library
         if (not f_startsWith('*': lib));
            if not f_exist(lib: *omit: '*LIB');
               sendToJobLog('Library ' + %trim(lib) + ' not found');
               return rc;
            endif;
         endif;

         // Check file
         if (not f_exist(i_file: lib: '*FILE'));
               sendToJobLog('File ' + %trim(i_file) +
                            ' in library ' + %trim(lib) + ' not found');
            return rc;
         endif;

         // Check member
         if not f_exist(i_file: lib: '*FILE': mbr);
               sendToJobLog('Member ' + %trim(mbr) +
                            ' of file ' + %trim(i_file) +
                            ' in library ' + %trim(lib) + ' not found');
            return rc;
         endif;

         // Open member
         g_properties.file = %trim(lib) + '/' + %trim(i_file);
         g_properties.name = mbr;

         open(E) PROPERTIES;
         if (%error());
            sendToJobLog('Could not open member ' + %trim(mbr) +
                         ' of file ' + %trim(i_file) +
                         ' in library ' + %trim(lib));
            return rc;
         endif;

         p_rmvPgmMsg(cMsg_Rmv_All: *omit: cMsg_Same: cMsg_ToMyself);

         // Load properties from member
         setll 1 PROPERTIES;
         dow %found(PROPERTIES);
            if (g_propsOpnInf.sourceFile = 'Y');
               read PROPERTIES inBufSrcMbr;
            else;
               read PROPERTIES inBufMbr;
            endif;

            if %eof(PROPERTIES);
               leave;
            endif;

            if (g_propsOpnInf.sourceFile = 'Y');
               length = g_propsOpnInf.rcdLength - (%size(inBufSrcMbr.SrcSeq) +
                                                   %size(inBufSrcMbr.SrcDat));
               retrieveAndAddPropertyToMap(
                     hProperties.pMap: %subst(inBufSrcMbr.srcDta: 1: length));
            else;
               if (g_propsOpnInf.rcdLength > %len(inBufMbr.data));
                  length = %len(inBufMbr.data);
                  if (not warnLength);
                     sendToJobLog('Record length of properties file +
                                   exceeded maximum of ' +
                                   %char(%len(inBufMbr.data)) + ' byte.');
                     warnLength = cTrue;
                  endif;
               else;
                  length = g_propsOpnInf.rcdLength;
               endif;
               retrieveAndAddPropertyToMap(
                     hProperties.pMap: %subst(inBufMbr.data: 1: length));
            endif;
         enddo;

         // Close member
         close PROPERTIES;

         rc = 0;

         return rc;

      /END-FREE
      *
     P BasicProperties_loadFromMember...
     P                 E
      *
      *=========================================================================
      *  Load properties from a given stream file.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *   i_stmf         - Stream file that contains the properties.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_loadFromStmf...
     P                 B                   export
      *
     D BasicProperties_loadFromStmf...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_stmf                     5000A   const  varying options(*varsize)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Local fields
     D fd              S             10I 0 inz
     D st_stat         DS                  likeds(st_stat_t      ) inz
     D line            S                   like(readLine_line_t  ) inz
     D isFirstLine     S               N   inz(cTrue)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         // Check stream file
         if (stat(%trim(i_stmf): %addr(st_stat)) = -1);
            sendToJobLog(
                  'File or directory ' + %trim(i_stmf) + ' does not exist');
            return rc;
         endif;

         // Open stream file
         monitor;
            fd = open(%trim(i_stmf): O_RDONLY + O_SHARE_RDONLY + O_TEXTDATA);
         on-error;
            sendToJobLog('Could not open stream file: ' + %trim(i_stmf));
            return rc;
         endmon;

         // Load properties from steam file
         isFirstLine = cTrue;
         dow (readLine(fd: line: isFirstLine) <> -1);
            retrieveAndAddPropertyToMap(hProperties.pMap: line);
            isFirstLine = cFalse;
         enddo;

         // Close member
         close PROPERTIES;

         rc = 0;

         return rc;

      /END-FREE
      *
     P BasicProperties_loadFromStmf...
     P                 E
      *
      *=========================================================================
      *  Removes the entry that is associated to the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *   i_key          - Key of the entry that is removed from the list
      *                    of properties.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_remove...
     P                 B                   export
      *
     D BasicProperties_remove...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Local fields
     D x               S             10I 0 inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         rc = BasicMap_remove(hProperties.pMap: i_key);

         return rc;

      /END-FREE
      *
     P BasicProperties_remove...
     P                 E
      *
      *=========================================================================
      *  Returns true if the list of properties contains a entry matching
      *  the specified key value.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *   i_key          - Key the list of properties is searched for.
      *
      *  Returns:
      *   isFound       - Returns TRUE is the list of properties contains an
      *                   entry matching the specified key, else FALSE.
      *=========================================================================
     P BasicProperties_containsKey...
     P                 B                   export
      *
     D BasicProperties_containsKey...
     D                 PI              N
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
      *
      *  Return value
     D isFound         S               N   inz(cFalse)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         isFound = BasicMap_containsKey(hProperties.pMap: i_key);

         return isFound;

      /END-FREE
      *
     P BasicProperties_containsKey...
     P                 E
      *
      *=========================================================================
      *  Returns the string that is associated to the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key the list of properties is searched for.
      *
      *  Returns:
      *   string        - String value addressed by 'i_key'.
      *=========================================================================
     P BasicProperties_getString...
     P                 B                   export
      *
     D BasicProperties_getString...
     D                 PI          4096A          varying
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                  4096A   const  varying
     D                                            options(*nopass: *varsize)
      *
      *  Return value
     D string          S                   like(property_t.value ) inz
      *
      *  Parameter positions
     D p_default       C                   const(3)
      *
      *  Local fields
     D isFound         S               N   inz(cFalse)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         isFound = getStringFromMap(hProperties.pMap: i_key: string);
         if (not isFound and %parms() >= p_default);
            return i_default;
         endif;

         return string;

      /END-FREE
      *
     P BasicProperties_getString...
     P                 E
      *
      *=========================================================================
      *  Returns the integer value that is associated to the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key the list of properties is searched for.
      *
      *  Returns:
      *   integer       - Integer value addressed by 'i_key'.
      *=========================================================================
     P BasicProperties_getInteger...
     P                 B                   export
      *
     D BasicProperties_getInteger...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                    10I 0 const  options(*nopass)
      *
      *  Return value
     D integer         S             10I 0 inz
      *
      *  Parameter positions
     D p_default       C                   const(3)
      *
      *  Local fields
     D string          S                   like(property_t.value ) inz
     D isFound         S               N   inz(cFalse)
      *
      *  Local constants
     D INT_LEN         C                   %len(integer)
     D INT_DECPOS      C                   %decpos(integer)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         isFound = getStringFromMap(hProperties.pMap: i_key: string);
         if (not isFound and %parms() >= p_default);
            return i_default;
         endif;

         if (string = '');   // Existing key but no value assigned to it.
            return 0;
         endif;

         integer = %dec(string: INT_LEN: INT_DECPOS);

         return integer;

      /END-FREE
      *
     P BasicProperties_getInteger...
     P                 E
      *
      *=========================================================================
      *  Returns the boolean value that is associated to the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key the list of properties is searched for.
      *
      *  Returns:
      *   integer       - Boolean value addressed by 'i_key'.
      *=========================================================================
     P BasicProperties_getBoolean...
     P                 B                   export
      *
     D BasicProperties_getBoolean...
     D                 PI              N
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                      N   const  options(*nopass)
      *
      *  Return value
     D boolean         S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_default       C                   const(3)
      *
      *  Local fields
     D string          S                   like(property_t.value ) inz
     D isFound         S               N   inz(cFalse)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         isFound = getStringFromMap(hProperties.pMap: i_key: string);
         if (not isFound and %parms() >= p_default);
            return i_default;
         endif;

         if (string = '');   // Existing key but no value assigned to it.
            return cFalse;
         endif;

         string = f_lcase(string);

         select;
         when (string = BOOLEAN_FALSE or string = BOOLEAN_0);
            boolean = cFalse;
         when (string = BOOLEAN_TRUE or string = BOOLEAN_1);
            boolean = cTrue;
         other;
            sendToJobLog('Invalid boolean value <' + string + '> +
                          associated to key <' + i_key + '>');
         endsl;

         return boolean;

      /END-FREE
      *
     P BasicProperties_getBoolean...
     P                 E
      *
      *=========================================================================
      *  Returns the decimal value that is associated to the specified key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key the list of properties is searched for.
      *
      *  Returns:
      *   decimal       - Decimal value addressed by 'i_key'.
      *=========================================================================
     P BasicProperties_getDecimal...
     P                 B                   export
      *
     D BasicProperties_getDecimal...
     D                 PI                         like(BasicProperties_decVal_t)
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                          const  like(BasicProperties_decVal_t)
     D                                            options(*nopass)
      *
      *  Return value
     D decimal         S                   like(BasicProperties_decVal_t) inz
      *
      *  Parameter positions
     D p_default       C                   const(3)
      *
      *  Local fields
     D string          S                   like(property_t.value ) inz
     D isFound         S               N   inz(cFalse)
      *
      *  Local constants
     D DEC_LEN         C                   %len(BasicProperties_decVal_t)
     D DEC_DECPOS      C                   %decpos(BasicProperties_decVal_t)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         isFound = getStringFromMap(hProperties.pMap: i_key: string);
         if (not isFound and %parms() >= p_default);
            return i_default;
         endif;

         if (string = '');   // Existing key but no value assigned to it.
            return 0;
         endif;

         decimal = %dec(string: DEC_LEN: DEC_DECPOS);

         return decimal;

      /END-FREE
      *
     P BasicProperties_getDecimal...
     P                 E
      *
      *=========================================================================
      *  Associates the specified string value to a given key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key that is associated to the specified string value.
      *   i_string       - The string value that is associated to a given key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_putString...
     P                 B                   export
      *
     D BasicProperties_putString...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_string                   4096A   const  varying
     D                                            options(*varsize)
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D property        DS                  likeds(property_t) inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         property.key   = i_key;
         property.value = i_string;
         rc = addPropertyToMap(hProperties.pMap: property);

         return rc;

      /END-FREE
      *
     P BasicProperties_putString...
     P                 E
      *
      *=========================================================================
      *  Associates the specified integer value to a given key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key that is associated to the specified integer value.
      *   i_integer      - The integer value that is associated to a given key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_putInteger...
     P                 B                   export
      *
     D BasicProperties_putInteger...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_integer                    10I 0 const
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D property        DS                  likeds(property_t) inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         property.key   = i_key;
         property.value = %char(i_integer);
         rc = addPropertyToMap(hProperties.pMap: property);

         return rc;

      /END-FREE
      *
     P BasicProperties_putInteger...
     P                 E
      *
      *=========================================================================
      *  Associates the specified boolean value to a given key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key that is associated to the specified integer value.
      *   i_boolean      - The boolean value that is associated to a given key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_putBoolean...
     P                 B                   export
      *
     D BasicProperties_putBoolean...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_boolean                      N   const
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D property        DS                  likeds(property_t) inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         property.key   = i_key;

         if (i_boolean);
            property.value = BOOLEAN_TRUE;
         else;
            property.value = BOOLEAN_FALSE;
         endif;

         rc = addPropertyToMap(hProperties.pMap: property);

         return rc;

      /END-FREE
      *
     P BasicProperties_putBoolean...
     P                 E
      *
      *=========================================================================
      *  Associates the specified decimal value to a given key.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *   i_key          - Key that is associated to the specified decimal value.
      *   i_decimal      - The decimal value that is associated to a given key.
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_putDecimal...
     P                 B                   export
      *
     D BasicProperties_putDecimal...
     D                 PI                         like(BasicProperties_decVal_t)
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_decimal                          const  like(BasicProperties_decVal_t)
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D x               S             10I 0 inz
     D property        DS                  likeds(property_t) inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         property.key   = i_key;

         property.value = %editc(i_decimal: 'P');
         x = %checkr('0': property.value);   // trim trailing '0'
         if (x < %len(property.value));
            %subst(property.value: x+1) = '';
         endif;

         property.value = %trim(property.value);
         rc = addPropertyToMap(hProperties.pMap: property);

         return rc;

      /END-FREE
      *
     P BasicProperties_putDecimal...
     P                 E
      *
      *=========================================================================
      *  Returns the number of key-value mappings in this properties list.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *
      *  Returns:
      *   numE          - NUmber of entries on success, else -1;
      *=========================================================================
     P BasicProperties_getNumE...
     P                 B                   export
      *
     D BasicProperties_getNumE...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D numE            S             10I 0 inz(-1)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         numE = BasicMap_getNumE(hProperties.pMap);

         return numE;

      /END-FREE
      *
     P BasicProperties_getNumE...
     P                 E
      *
      *=========================================================================
      *  Returns the heap ID of a given BasicProperties.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *
      *  Returns:
      *   numE          - NUmber of entries on success, else -1;
      *=========================================================================
     P BasicProperties_getHeapID...
     P                 B                   export
      *
     D BasicProperties_getHeapID...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D heapID          S             10I 0 inz(-1)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         heapID = BasicMap_getHeapID(hProperties.pMap);

         return heapID;

      /END-FREE
      *
     P BasicProperties_getHeapID...
     P                 E
      *
      *=========================================================================
      *  Removes all entries from a given properties list.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned   ew().
      *                    by BasicProperties_new().
      *
      *  Returns:
      *   rc            - Returns 0 on success, else -1.
      *=========================================================================
     P BasicProperties_clear...
     P                 B                   export
      *
     D BasicProperties_clear...
     D                 PI            10I 0
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         rc = BasicMap_clear(hProperties.pMap);

         return rc;

      /END-FREE
      *
     P BasicProperties_clear...
     P                 E
      *
      *=========================================================================
      *  Deletes a given BasicProperties.
      *=========================================================================
      *  Parameters:
      *   io_pProperties - Basing pointer of the properties as returned by
      *                    BasicProperties_new().
      *
      *  Returns:
      *   rc              Returns 0 success, else -1.
      *=========================================================================
     P BasicProperties_delete...
     P                 B                   export
      *
     D BasicProperties_delete...
     D                 PI            10I 0
     D  io_pProperties...
     D                                            like(BasicProperties_handle_t)
      *
      *  Return value
     D rc              S             10I 0 inz(-1)
      *
      *  Helper fields
     D x               S             10I 0 inz
      *
      *  Memory Manager
      /COPY QBASICS1,MEMMGR
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(io_pProperties)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(io_pProperties);

         dou 1=1;

            // Set memory manager
            mm_memMgr = hProperties.memMgr;

            // Delete underlaying BasicMap.
            BasicMap_delete(hProperties.pMap);

            // Clear properties handle
            clear hProperties;
            hProperties.intType       = 0;
            hProperties.intSize       = 0;
            hProperties.pMap          = BasicMap_null();
            hProperties.increment     = 0;
            hProperties.heapID        = 0;
            clear hProperties.memMgr;

            // Free memory of properties handle
            mm_free(io_pProperties);

            io_pProperties = BasicProperties_null();

         enddo;

         return rc;

      /END-FREE
      *
     P BasicProperties_delete...
     P                 E
      *
      *=========================================================================
      *  Returns a BasicProperties NULL handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pProperties    - NULL handle of a BasicProperties.
      *=========================================================================
     P BasicProperties_null...
     P                 B                   export
      *
     D BasicProperties_null...
     D                 PI                         like(BasicProperties_handle_t)
      *
      *  Return value
     D pProperties     S                   like(BasicProperties_handle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pProperties = *NULL;

         return pProperties;

      /END-FREE
      *
     P BasicProperties_null...
     P                 E
      *
      *=========================================================================
      *  Checks a given BasicProperties handle for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *
      *  Returns:
      *   isNull         - Returns TRUE if the handle is null, else FALSE.
      *=========================================================================
     P BasicProperties_isNull...
     P                 B                   export
      *
     D BasicProperties_isNull...
     D                 PI              N
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D isNull          S               N   inz(cTrue)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pProperties = BasicProperties_null());
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return isNull;

      /END-FREE
      *
     P BasicProperties_isNull...
     P                 E
      *
      *=========================================================================
      *  Returns the list of key values from a given properties list.
      *=========================================================================
      *  Parameters:
      *   i_pProperties  - Basing pointer of the properties as returned
      *                    by BasicProperties_new().
      *
      *  Returns:
      *   pKeySet       - Handle of the key set.
      *=========================================================================
      *  Note:            Use BasicKeySet_delete() to delete the key set.
      *=========================================================================
     P BasicProperties_newKeySet...
     P                 B                   export
      *
     D BasicProperties_newKeySet...
     D                 PI                         like(BasicKeySet_handle_t)
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Return value
     D pKeySet         S                   like(BasicKeySet_handle_t) inz
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         checkPropertiesHandle(i_pProperties);

         pKeySet = BasicMap_newKeySet(hProperties.pMap);

         return pKeySet;

      /END-FREE
      *
     P BasicProperties_newKeySet...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Checks, whether a given handle is a valid properties handle, or not.
      *  Returns TRUE for a valid properties handle, else FALSE.
      *=========================================================================
     P checkPropertiesHandle...
     P                 B
      *
     D checkPropertiesHandle...
     D                 PI
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Properties handle
     D hProperties     DS                  likeds(hProperties_t)
     D                                     based(i_pProperties )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (BasicProperties_isNull(i_pProperties));
            signalError(cERROR_PROPERTIES_HANDLE_NULL: f_caller());
         endif;

         if (hProperties.intType <> cHANDLE_TYPE_PROPERTIES);
            signalError(cERROR_PROPERTIES_HANDLE_INVALID: f_caller());
         endif;

         if (hProperties.intSize <> cHANDLE_PROPERTIES_SIZE);
            signalError(cERROR_PROPERTIES_HANDLE_INVALID: f_caller());
         endif;

         return;

      /END-FREE
      *
     P checkPropertiesHandle...
     P                 E
      *
      *=========================================================================
      *  *** Private ***
      *  Reads a line from a given file descriptor.
      *=========================================================================
     P readLine...
     P                 B
      *
     D readLine...
     D                 PI            10I 0
     D  i_fd                         10I 0 const
     D  io_line                                   like(readLine_line_t)
     D  i_isFirstLine                  N   const
      *
      *  Helper fields
     D rd              DS                  qualified static
     D  buffer                     4096A   inz
     D  pos                          10I 0 inz
     D  len                          10I 0 inz
     D  pChar                          *   inz
     D  lineFeed                      1A   inz(x'00')
      *
     D char            S              1A   based(rd.pChar)
     D isEndOfLine     S               N   inz(cFalse)
      *
     D line            DS                  qualified based(pLine)
     D  len                           5I 0
     D  data                       1024A
      *
     D MAX_LENGTH      C                   1024
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_isFirstLine);
            reset rd;
         endif;

         pLine = %addr(io_line);
         line.len = 0;

         dou (isEndOfLine);

            if (rd.pos >= rd.len);
               rd.pos = 0;
               rd.len = read(i_fd: %addr(rd.buffer): %size(rd.buffer));
               if (rd.len < 1);
                  return -1;
               endif;
               rd.pChar = %addr(rd.buffer);
            endif;

            if (rd.lineFeed = x'00' and (char = x'25' or char = x'0D'));
               rd.lineFeed = char;
            endif;

            if (char <> x'25' and char <> x'0D' and line.len < MAX_LENGTH);
               line.len = line.len + 1;
               %subst(line.data: line.len: 1) = char;
            endif;

            if (char = rd.lineFeed);
               isEndOfLine = cTrue;
            endif;

            rd.pChar = rd.pChar + 1;
            rd.pos   = rd.pos + 1;
         enddo;

         return line.len;

      /END-FREE
      *
     P readLine...
     P                 E
      *
      *=========================================================================
      *  *** Private ***
      *  Test the specified buffer, splitts the buffer and adds the property
      *  to the property list.
      *=========================================================================
     P retrieveAndAddPropertyToMap...
     P                 B
      *
     D retrieveAndAddPropertyToMap...
     D                 PI
     D  i_pMap                             const  like(BasicMap_handle_t    )
     D  i_buffer                   4096A   const  varying  options(*varsize)
      *
      *  Helper fields
     D x               S             10I 0                    inz
     D char            S              1A                      inz
     D buffer          S                   like(i_buffer    ) inz
     D property        DS                  likeds(property_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         buffer = %trim(i_buffer);

         if buffer = '';
            return;
         endif;

         char   = %subst(buffer: 1: 1);

         if (char <> '#') and (char <> ';') and (char <> '!');
            x = %scan('=': buffer);
            if (x > 1) and (x < %len(buffer));
               property.key   = %trim(%subst(buffer: 1: x-1));
               property.value = %trim(%subst(buffer: x+1));
               addPropertyToMap(i_pMap: property);
            endif;
         endif;

         return;

      /END-FREE
      *
     P retrieveAndAddPropertyToMap...
     P                 E
      *
      *=========================================================================
      *  *** Private ***
      *  Adds the specified key and value to the map.
      *=========================================================================
     P addPropertyToMap...
     P                 B
      *
     D addPropertyToMap...
     D                 PI            10I 0
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_property                         const  likeds(property_t      )
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D  key            S                   like(i_property.key ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         key = f_lcase(i_property.key);
         rc = BasicMap_putString(i_pMap: key: i_property.value);

         return rc;

      /END-FREE
      *
     P addPropertyToMap...
     P                 E
      *
      *=========================================================================
      *  *** Private ***
      *  Returns the value that is associated to a given key
      *  from the specified map.
      *=========================================================================
     P getStringFromMap...
     P                 B
      *
     D getStringFromMap...
     D                 PI              N
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D  o_string                                  like(property_t.value  )
      *
      *  Helper fields
     D  key            S                   like(property_t.key ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         key = f_lcase(i_key);
         if (not BasicMap_containsKey(i_pMap: key));
            return cFalse;
         endif;

         o_string = BasicMap_getString(i_pMap: key);

         return cTrue;

      /END-FREE
      *
     P getStringFromMap...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends an ESCAPE message to signal an error condition.
      *=========================================================================
     P signalError...
     P                 B
      *
     D signalError...
     D                 PI
     D  i_text                      128A   const  varying
     D  i_proc                      256A   const  varying
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg('CPF9898'
                        : 'BasicProperties: ERROR - ' + i_text
                        : cMsg_Escape: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: i_proc);

         return;

      /END-FREE
      *
     P signalError...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Sends a DIAGNOSTIC message to the job log.
      *=========================================================================
     P sendToJobLog...
     P                 B
      *
     D sendToJobLog...
     D                 PI
     D  i_text                      512A   const  varying
      *
      *  Helper fields
     D proc            S            256A   varying inz
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         proc = f_caller();

         msg = f_newMsg('CPF9897'
                        : 'BasicProperties: WARNING - ' + i_text + '.'
                        : cMsg_Diag: 'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Same: proc);

         return;

      /END-FREE
      *
     P sendToJobLog...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1RH  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1RH "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - MemoryBufferRdrWtr       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1RH  - SrvPgm: Basic Routines - MemoryBufferRdrWtr           *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  16.07.2011                                              *
      *  E-mail  :  thomas.raddatz@tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN BNDDIR('QSNAPI')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RH
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D reader_t        DS                  qualified               based(pDummy)
     D  fd                           10I 0
     D  offset                       10I 0
     D  size                         10I 0
     D  pData                          *
      *
     D writer_t        DS                  qualified               based(pDummy)
     D  fd                           10I 0
     D  offset                       10I 0
     D  size                         10I 0
     D  pData                          *
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,CLIB                          C Runtime Library
      *
      /COPY QBASICS1,PBASICS1R2                    API Error Handling
      /COPY QBASICS1,PBASICS1R8                    Handle/Memory
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D HANDLE_TYPE_WRITER...
     D                 C                   '*MEMORY_WRITER'
     D HANDLE_TYPE_READER...
     D                 C                   '*MEMORY_READER'
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a memory buffer writer.
      *=========================================================================
      *  Parameters:
      *   i_pBuffer     - Buffer data is written to.
      *   i_maxSize     - Maximum size of the buffer.
      *
      *  Returns:
      *   fd            - Buffer descriptor on success, else -1.
      *=========================================================================
     P MemoryWriter_new...
     P                 B                   export
      *
     D MemoryWriter_new...
     D                 PI                         like(memWtr_handle_t)
     D  i_pBuffer                      *   value
     D  i_maxSize                          value  like(size_t         )
      *
      *  Return value
     D fd              S             10I 0 inz(RC_ERROR)
      *
      *  Local fields
      *
      *  Handle
     D hWriter         DS                  likeds(writer_t ) based(pHWriter)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         fd = HANDLE_new(HANDLE_TYPE_WRITER: %size(hWriter));

         pHWriter = HANDLE_getPointer(fd);

         clear hWriter;
         hWriter.fd     = fd;
         hWriter.offset = 0;
         hWriter.size   = i_maxSize;
         hWriter.pData  = i_pBuffer;

         return fd;

      /END-FREE
      *
     P MemoryWriter_new...
     P                 E
      *
      *=========================================================================
      *  Write to a given memory buffer descriptor.
      *=========================================================================
      *  Parameters:
      *   i_fd          - Descriptor as created by MemoryWriter_new().
      *   i_pBuffer     - Buffer that is written to the descriptor.
      *   i_buflen      - Length of the buffer.
      *
      *  Returns:
      *   fd            - Number of bytes written to the descriptor on
      *                   success, else -1.
      *=========================================================================
     P MemoryWriter_write...
     P                 B                   export
      *
     D MemoryWriter_write...
     D                 PI                         like(ssize_t        )
     D  i_fd                               value  like(memWtr_handle_t)
     D  i_pBuffer                      *   value
     D  i_buflen                           value  like(size_t         )
      *
      *  Return value
     D rc              S                   like(ssize_t ) inz(RC_ERROR)
      *
      *  Local fields
     D size            S                   like(rc      ) inz
     D pDest           S               *   inz
      *
      *  Handle
     D hWriter         DS                  likeds(writer_t ) based(pHWriter)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not HANDLE_isTypeOf(i_fd: HANDLE_TYPE_WRITER));
            f_setErrno(EBADF_C);
            return RC_ERROR;
         endif;

         pHWriter = HANDLE_getPointer(i_fd);

         if (hWriter.offset + i_buflen > hWriter.size);
            f_setErrno(ENOBUFS_C);
            return RC_ERROR;
         endif;

         size = i_buflen;
         pDest = memcpy(hWriter.pData + hWriter.offset: i_pBuffer: size);
         if (pDest <> hWriter.pData + hWriter.offset);
            f_setErrno(ENOBUFS_C);
            return RC_ERROR;
         endif;

         hWriter.offset = hWriter.offset + size;

         rc = size;

         return rc;

      /END-FREE
      *
     P MemoryWriter_write...
     P                 E
      *
      *=========================================================================
      *  Deletes a given memory buffer writer.
      *=========================================================================
      *  Parameters:
      *   io_fd         - Descriptor as created by MemoryWriter_new().
      *
      *  Returns:
      *   void
      *=========================================================================
     P MemoryWriter_delete...
     P                 B                   export
      *
     D MemoryWriter_delete...
     D                 PI
     D  io_fd                                     like(memWtr_handle_t)
      *
      *  Local fields
      *
      *  Handle
     D hWriter         DS                  likeds(writer_t ) based(pHWriter)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not HANDLE_isTypeOf(io_fd: HANDLE_TYPE_WRITER));
            f_setErrno(EBADF_C);
            return;
         endif;

         pHWriter = HANDLE_getPointer(io_fd);

         clear hWriter;

         HANDLE_delete(io_fd);

         return;

      /END-FREE
      *
     P MemoryWriter_delete...
     P                 E
      *
      *=========================================================================
      *  Returns the 'write' procedure of a MemoryWriter.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pWriteProc    - Procedure pointer of the 'write' procedure
      *                   of a MemoryWriter.
      *=========================================================================
     P MemoryWriter_writeProc...
     P                 B                   export
      *
     D MemoryWriter_writeProc...
     D                 PI              *          procptr
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return %paddr('BASICS1RH_MemoryWriter_write');

      /END-FREE
      *
     P MemoryWriter_writeProc...
     P                 E
      *
      *=========================================================================
      *  Creates a memory buffer reader.
      *=========================================================================
      *  Parameters:
      *   i_pBuffer     - Buffer data is read from.
      *   i_size        - Size of the buffer.
      *
      *  Returns:
      *   fd            - Buffer descriptor on success, else -1.
      *=========================================================================
     P MemoryReader_new...
     P                 B                   export
      *
     D MemoryReader_new...
     D                 PI                         like(memRdr_handle_t)
     D  i_pBuffer                      *   value
     D  i_size                             value  like(size_t         )
      *
      *  Return value
     D fd              S             10I 0 inz(RC_ERROR)
      *
      *  Local fields
      *
      *  Handle
     D hReader         DS                  likeds(reader_t ) based(pHReader)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         fd = HANDLE_new(HANDLE_TYPE_READER: %size(hReader));

         pHReader = HANDLE_getPointer(fd);

         clear hReader;
         hReader.fd     = fd;
         hReader.offset = 0;
         hReader.size   = i_size;
         hReader.pData  = i_pBuffer;

         return fd;

      /END-FREE
      *
     P MemoryReader_new...
     P                 E
      *
      *=========================================================================
      *  Reads from a given memory buffer descriptor.
      *=========================================================================
      *  Parameters:
      *   i_fd          - Descriptor as created by MemoryReader_new().
      *   i_pBuffer     - Buffer used to store the data taht was read
      *                   from the descriptor.
      *   i_nByte       - Length of the buffer.
      *
      *  Returns:
      *   fd            - Number of bytes read from the descriptor on
      *                   success, else -1.
      *=========================================================================
     P MemoryReader_read...
     P                 B                   export
      *
     D MemoryReader_read...
     D                 PI                         like(ssize_t        )
     D  i_fd                               value  like(memRdr_handle_t)
     D  i_pBuffer                      *   value
     D  i_nByte                            value  like(size_t         )
      *
      *  Return value
     D rc              S                   like(ssize_t ) inz(RC_ERROR)
      *
      *  Local fields
     D size            S                   like(rc      ) inz
     D pDest           S               *   inz
      *
      *  Handle
     D hReader         DS                  likeds(reader_t ) based(pHReader)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not HANDLE_isTypeOf(i_fd: HANDLE_TYPE_READER));
            f_setErrno(EBADF_C);
            return RC_ERROR;
         endif;

         pHReader = HANDLE_getPointer(i_fd);

         if (hReader.offset + i_nByte > hReader.size);
            size = hReader.size - hReader.offset;
         else;
            size = i_nByte;
         endif;

         pDest = memcpy(i_pBuffer: hReader.pData + hReader.offset: size);
         if (pDest <> i_pBuffer);
            return RC_ERROR;
         endif;

         hReader.offset = hReader.offset + size;

         rc = size;

         return rc;

      /END-FREE
      *
     P MemoryReader_read...
     P                 E
      *
      *=========================================================================
      *  Deletes a given memory buffer reader.
      *=========================================================================
      *  Parameters:
      *   io_fd         - Descriptor as created by MemoryReader_new().
      *
      *  Returns:
      *   void
      *=========================================================================
     P MemoryReader_delete...
     P                 B                   export
      *
     D MemoryReader_delete...
     D                 PI
     D  io_fd                                     like(memRdr_handle_t)
      *
      *  Local fields
      *
      *  Handle
     D hReader         DS                  likeds(reader_t ) based(pHReader)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not HANDLE_isTypeOf(io_fd: HANDLE_TYPE_READER));
            f_setErrno(EBADF_C);
            return;
         endif;

         pHReader = HANDLE_getPointer(io_fd);

         clear hReader;

         HANDLE_delete(io_fd);

         return;

      /END-FREE
      *
     P MemoryReader_delete...
     P                 E
      *
      *=========================================================================
      *  Returns the 'read' procedure of a MemoryReader.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   pWriteProc    - Procedure pointer of the 'read' procedure
      *                   of a MemoryReader.
      *=========================================================================
     P MemoryReader_readProc...
     P                 B                   export
      *
     D MemoryReader_readProc...
     D                 PI              *          procptr
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return %paddr('BASICS1RH_MemoryReader_read');

      /END-FREE
      *
     P MemoryReader_readProc...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R0  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R0 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Declarations        cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICR0)
      /DEFINE BASICR0
      *
      * -----------------------------------------
      *  Constants
      * -----------------------------------------
      /IF NOT DEFINED(cTrue)
      /DEFINE cTrue
     D cTrue           C                   const(*on )
      /ENDIF
      *
      /IF NOT DEFINED(cFalse)
      /DEFINE cFalse
     D cFalse          C                   const(*off)
      /ENDIF
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Prototypes
      * -----------------------------------------
      /COPY QBASICS1,CLIB
      /COPY QBASICS1,CEELIB
      *
      *  Retrieve Message (QMHRTVM) API
     D QMHRTVM         PR                         extpgm('QMHRTVM')
     D  o_msgInf                  32767A          options(*varsize )
     D  i_length                     10I 0 const
     D  i_format                      8A   const
     D  i_msgID                       7A   const
     D  i_qMsgF                      20A   const
     D  i_rplData                 32767A   const  options(*varsize )
     D  i_rpldataLen                 10I 0 const
     D  i_rplVars                    10A   const
     D  i_rtnCtrlChrs                10A   const
     D  io_ErrCode                32767A          options(*varsize )
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D  i_msgID                       7A   const
     D  i_qMsgF                      20A   const
     D  i_msgData                 32767A   const  options(*varsize )
     D  i_length                     10I 0 const
     D  i_msgType                    10A   const
     D  i_callStkE                32767A   const  options(*varsize )
     D  i_callStkC                   10I 0 const
     D  o_msgKey                      4A
     D  io_ErrCode                32767A          options(*varsize )
     D  i_lenStkE                    10I 0 const  options(*nopass  )            | optGrp 1
     D  i_callStkEQ                  20A   const  options(*nopass  )            |
     D  i_wait                       10I 0 const  options(*nopass  )            |
     D  i_callStkEDT                 10A   const  options(*nopass  )            | optGrp 2
     D  i_ccsid                      10I 0 const  options(*nopass  )            |
      *
      *  Receive Program Message (QMHRCVPM) API
     D QMHRCVPM        PR                         extpgm('QMHRCVPM')
     D  o_rcvVar                  32767A          options(*varsize )
     D  i_length                     10I 0 const
     D  i_format                      8A   const
     D  i_callStkE                   10A   const
     D  i_callStkC                   10I 0 const
     D  i_msgType                    10A   const
     D  i_msgKey                      4A   const
     D  i_wait                       10I 0 const
     D  i_action                     10A   const
     D  io_ErrCode                32767A          options(*varsize )
     D  i_lenStkE                    10I 0 const  options(*nopass  )            | optGrp 1
     D  i_callStkEQ                  20A   const  options(*nopass  )            |
     D  i_callStkEDT                 10A   const  options(*nopass  )            | optGrp 2
     D  i_ccsid                      10I 0 const  options(*nopass  )            |
      *
      *  Remove Program Messages (QMHRMVPM) API
     D QMHRMVPM        PR                         extpgm('QMHRMVPM')
     D  i_callStkE                   10A   const
     D  i_callStkC                   10I 0 const
     D  i_msgKey                      4A   const
     D  i_msgToRemove                10A   const
     D  io_ErrCode                32767A          options(*varsize )
     D  i_lenStkE                    10I 0 const  options(*nopass  )            | optGrp 1
     D  i_callStkEQ                  20A   const  options(*nopass  )            |
     D  i_rmvUnhExcp                 10A   const  options(*nopass  )            |
      *
      *  Process Commands (QCAPCMD) API
     D QCAPCMD...
     D                 PR                         extpgm('QCAPCMD')
     D  i_cmd...
     D                            32702A   const  options(*varsize)
     D  i_cmdLength...
     D                               10I 0 const
     D  i_optCtrlBlk...
     D                            32767A   const  options(*varsize)
     D  i_optCtrlBlkLength...
     D                               10I 0 const
     D  i_optCtrlBlkFormat...
     D                                8A   const
     D  o_chgCmd...
     D                            32702A          options(*varsize)
     D  i_chgCmdLength...
     D                               10I 0 const
     D  o_chgCmdLengthAvl...
     D                               10I 0
     D  io_errorCode...
     D                            32767A          options(*varsize)
      *
      *  Retrieve Object Description (QUSROBJD) API
     D QUSROBJD        PR                         extpgm('QUSROBJD')
     D  i_rcvVar                  32767A          options(*varsize)
     D  i_length                     10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_objType                    10A   const
     D  io_ErrCode                32767A          options(*nopass: *varsize)    | optGrp
      *
      *  Retrieve Member Description (QUSRMBRD) API
     D QUSRMBRD        PR                         extpgm('QUSRMBRD')
     D  i_rcvVar                  32767A          options(*varsize)
     D  i_length                     10I 0 const
     D  i_format                      8A   const
     D  i_qFile                      20A   const
     D  i_mbr                        10A   const
     D  i_prcOverride                 1A   const
     D  io_ErrCode                32767A          options(*nopass: *varsize)    | optGrp 1
      *
      *  Convert Case (QLGCNVCS, QlgConvertCase) API
     D QlgConvertCase  PR                         extproc('QlgConvertCase')
     D  i_reqCtrlBlk              32767A   const  options(*varsize)
     D  i_inData                  32767A   const  options(*varsize)
     D  o_outData                 32767A          options(*varsize)
     D  i_length                     10I 0 const
     D  io_ErrCode                32767A          options(*nopass: *varsize)
      *
     D cCVTCASE_TYPE_ccsid...
     D                 C                   const(1)
      *
     D cCVTCASE_TYPE_table...
     D                 C                   const(2)
      *
     D cCVTCASE_TYPE_userDef...
     D                 C                   const(3)
      *
     D cCVTCASE_toUpper...
     D                 C                   const(0)
      *
     D cCVTCASE_toLower...
     D                 C                   const(1)
      *
     D cCVTCASE_CCSID_Job...
     D                 C                   const(0)
      *
     D reqCtrlBlk_t    DS                  qualified           based(pDummy)
     D  type                         10I 0
     D  CCSID                        10I 0
     D  case                         10I 0
     D  reserved                     10A
      *
      *  Convert Edit Code (QECCVTEC) API
     D QECCVTEC...
     D                 PR                  extpgm('QECCVTEC')
     D  o_editMask                  256A
     D  o_editMaskLen                10I 0
     D  o_rcvVarLen                  10I 0
     D  o_zeroFilChar                 1A
     D  i_editCode                    2A   const
     D  i_floatInd                    1A   const
     D  i_precision                  10I 0 const
     D  i_decPos                     10I 0 const
     D  io_ErrCode                32767A          options(*varsize)
      *
      *  Convert Edit Word (QECCVTEW) API
     D QECCVTEW...
     D                 PR                  extpgm('QECCVTEW')
     D  o_editMask                  256A
     D  o_editMaskLen                10I 0
     D  o_rcvVarLen                  10I 0
     D  i_editWord                32767A   const options(*varsize)
     D  i_editWordLen                10I 0 const
     D  io_ErrCode                32767A         options(*varsize)
      *
      *  Edit (QECEDT) API
     D QECEDT...
     D                 PR                  extpgm('QECEDT')
     D  o_rcvVar                  32767A         options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_srcVar                  32767A   const options(*varsize)
     D  i_srcVarClass                10A   const
     D  i_srcVarPrec                 10I 0 const
     D  i_editMask                32767A   const options(*varsize)
     D  i_editMaskLen                10I 0 const
     D  i_zeroFilChar                 1A   const
     D  io_ErrCode                32767A         options(*varsize)
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R1 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Messages                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R1  - SrvPgm: Basic Routines - Messages                     *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  26.01.2005  Th.Raddatz    Removed Parameter i_rtnCtrlChr from      *
      *                            f_rtvMsgText().                          *
      *                                                                     *
      *  09.02.2005  Th.Raddatz    Added f_rtvMsgTextRaw() and              *
      *                            f_rtvMsgHelpTextRaw().                   *
      *                                                                     *
      *  22.03.2007  Th.Raddatz    Added f_cvtRcvMsgToMsg().                *
      *                                                                     *
      *  12.12.2007  Th.Raddatz    Fixed problem f_cvtRcvMsgToMsg().        *
      *                            returned msg ID was blanks when          *
      *                            i_rcvm0200 was empty. Now msg ID is      *
      *                            set to cMSG_ID_NONE.                     *
      *                                                                     *
      *  17.12.2008  Th.Raddatz    Added f_rcvPgmMsgObj().                  *
      *                                                                     *
      *  17.12.2008  Th.Raddatz    Changed f_cvtRcvMsgToMsg() to get the    *
      *                            message type from the rcvm0200 format    *
      *                            if the message type has not been passed. *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R1
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Get application message file name
     D lf_getAppMsgFileName...
     D                 PR            10A
      *
      *  Get application message file library name
     D lf_getAppMsgFileLibrary...
     D                 PR            10A
      *
      *  Set application message file name
     D lp_setAppMsgFileName...
     D                 PR
     D  i_file                       10A   const
      *
      *  Set application message file library name
     D lp_setAppMsgFileLibrary...
     D                 PR
     D  i_lib                        10A   const
      *
      *  Retrieve message description
     D lf_rtvMsgD...
     D                 PR              *
     D  i_format                      8A   const
     D  i_msgID                       7A   const
     D  i_rplData                  4096A   const  varying
     D  i_qMsgF                            const  likeds(qObj_t    )
     D  o_msg                                     likeds(msg_t     )
     D  i_rplVars                    10A   const  options(*nopass)
     D  i_rtnCtrlChr                 10A   const  options(*nopass)
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
     D g_qAppMsgFile   DS                  likeds(qObj_t    ) inz
      *
      *=========================================================================
      *  Sets the application message file.
      *=========================================================================
      *  Parameters:
      *   i_file        - The name of the message file.
      *                   Default:        QCPFMSG
      *   i_lib         - The name of the message file library.
      *                   Default:        *LIBL
      *
      *  Returns:
      *   void
      *=========================================================================
     P p_setAppMsgFile...
     P                 B                   export
      *
     D p_setAppMsgFile...
     D                 PI
     D  i_file                       10A   const  options(*nopass)
     D  i_lib                        10A   const  options(*nopass)
      *
      *  Parameter positions
     D p_file          C                   const(1)
     D p_lib           C                   const(2)
      *
      *  Optional parameter fields
     D file            S                   like(i_file    ) inz
     D lib             S                   like(i_lib     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... file
         if   %parms >= p_file;
            CEETSTA(isPresent: p_file: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            file = i_file;
         else;
            file = 'QCPFMSG';
         endif;

         // ... library
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Set the message file ...
         lp_setAppMsgFileName(file);
         lp_setAppMsgFileLibrary(lib);

         return;

      /END-FREE
      *
     P p_setAppMsgFile...
     P                 E
      *
      *=========================================================================
      *  Creates a new message.
      *=========================================================================
      *  Parameters:
      *   i_ID          - The message ID.
      *                   Default:        cMSG_ID_NONE (if omitted)
      *                                   cMSG_ID_NULL (if not passed)
      *                   cMsg_ID_OK    - An OK message which actually is
      *                                   a blank message structure.
      *                   cMsg_ID_NONE  - A message with no message ID,
      *                                   just message text.
      *                   cMsg_ID_NULL  - A NULL message.
      *   i_data        - The message data of the replacement variables.
      *                   Default:        *BLANKS
      *   i_type        - The message type.
      *                   Default:        cMsg_Info
      *                   Please refer to PBASICS1R1 for a list of valid
      *                   message types.
      *   i_file        - The message file that contains the message ID.
      *                   Default:        The application message file.
      *   i_lib         - The message file library.
      *                   Default:        The application message file
      *                                   library.
      *
      *  Returns:
      *   void
      *=========================================================================
     P f_newMsg...
     P                 B                   export
      *
     D f_newMsg...
     D                 PI                         likeds(msg_t     )
     D  i_ID                               const  like(msg_t.id    )
     D                                            options(*omit: *nopass)
     D  i_data                      512A   const  varying
     D                                            options(*omit: *nopass)
     D  i_type                             const  like(msg_t.type  )
     D                                            options(*omit: *nopass)
     D  i_file                             const  like(msg_t.file  )
     D                                            options(*omit: *nopass)
     D  i_lib                              const  like(msg_t.lib   )
     D                                            options(*omit: *nopass)
      *
      *  Return value
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Parameter positions
     D p_ID            C                   const(1)
     D p_data          C                   const(2)
     D p_type          C                   const(3)
     D p_file          C                   const(4)
     D p_lib           C                   const(5)
      *
      *  Optional parameter fields
     D ID              S                   like(i_ID      ) inz
     D data            S                   like(i_data    ) inz
     D type            S                   like(i_type    ) inz
     D file            S                   like(i_file    ) inz
     D lib             S                   like(i_lib     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * ---------------------------------------------------------
      /FREE

         // Process optional parameter values ...
         // ... ID
         if  %parms >= p_ID;
            CEETSTA(isPresent: p_ID: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            ID = i_ID;
         else;
            if  %parms >= p_ID;
               ID = cMSG_ID_NONE;
            else;
               ID = cMSG_ID_NULL;
            endif;
         endif;

         // ... Data
         if  %parms >= p_data;
            CEETSTA(isPresent: p_data: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            data = i_data;
         else;
            data = '';
         endif;

         // ... Type
         if  %parms >= p_type;
            CEETSTA(isPresent: p_type: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            type = i_type;
         else;
            if   (ID <> cMsg_ID_OK  ) and
                 (ID <> cMsg_ID_NULL);
               type = cMsg_Info;
            else;
               type = '';
            endif;
         endif;

         // ... File
         if  %parms >= p_file;
            CEETSTA(isPresent: p_file: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            file = i_file;
         else;
            file = lf_getAppMsgFileName();
         endif;

         // ... Library
         if  %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            lib = i_lib;
         else;
            lib = lf_getAppMsgFileLibrary();
         endif;

         // Check dependencies ...
         if   (ID = cMSG_ID_NONE) and (data = '');
            p_assert(cFalse:
                     'Message data must not be *BLANKS in case that -
                      message ID is specified as cMsg_ID_NONE.'           );
         endif;

         // Produce message ...
         clear   msg;

         msg.ID   = ID;
         if   msg.ID <> cMSG_ID_NULL;
            msg.data = data;
            msg.type = type;
            msg.file = file;
            msg.lib  = lib;
         endif;

         return   msg;

      /END-FREE
      *
     P f_newMsg...
     P                 E
      *
      *=========================================================================
      *  Sends a program message.
      *=========================================================================
      *  Parameters:
      *   i_msg         - The message to send.
      *   i_toStkC      - The stack entry to send the message to.
      *                   Default:        cMsg_Same
      *                   cMsg_Ext      - The external message queue.
      *                   cMsg_Prv      - The procedure that is before
      *                                   the procdure that is specified
      *                                   at i_toProc.
      *                   cMsg_Same     - The procedure that is specified
      *                                   at i_toProc.
      *   i_toProc      - The procedure to send the message to.
      *                   Default:        cMsg_ToMyself
      *                   cMsg_ToMyself - The procedure that calls
      *                                   f_sndPgmMsg().
      *                   cMsg_ToPgmBdy - The program boundary.
      *                   cMsg_ToCtlBdy - The control boundary.
      *                   cMsg_ToPgm    - The program specified
      *                                   at i_toPgm.
      *   i_toMod       - The module that contains the procedure.
      *                   Default:        *NONE
      *   i_toPgm       - The program that contains the module.
      *                   Default:        *NONE
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msgKey        - The message key of the message sent.
      *=========================================================================
     P f_sndPgmMsg...
     P                 B                   export
      *
     D f_sndPgmMsg...
     D                 PI             4A
     D  i_msg                              const  likeds(msg_t   )
     D  i_toStkC                     10I 0 const  options(*nopass: *omit)
     D  i_toProc                    256A   const  options(*nopass: *omit)
     D  i_toMod                      10A   const  options(*nopass: *omit)
     D  i_toPgm                      10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D msgKey          S              4A   inz
      *
      *  Parameter positions
     D p_toStkC        C                   const(2)
     D p_toProc        C                   const(3)
     D p_toMod         C                   const(4)
     D p_toPgm         C                   const(5)
     D p_msg           C                   const(6)
      *
      *  Optional parameter fields
     D toStkC          S                   like(i_toStkC  ) inz
     D toProc          S                   like(i_toProc  ) inz
     D toMod           S                   like(i_toMod   ) inz
     D toPgm           S                   like(i_toPgm   ) inz
     D msg             DS                  likeds(o_msg   ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QMHSNDPM
     D qMsgF           DS                  likeds(qObj_t    ) inz
     D callStkE        S                   like(i_toProc)     inz
     D callStkCtr      S             10I 0                    inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... stack counter
         if  %parms >= p_toStkC;
            CEETSTA(isPresent: p_toStkC: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            toStkC = i_toStkC;
         else;
            toStkC = cMsg_Same;
         endif;

         // ... to procedure
         if  %parms >= p_toProc;
            CEETSTA(isPresent: p_toProc: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            toProc = i_toProc;
         else;
            toProc = cMsg_toMySelf;
         endif;

         // ... to module
         if  %parms >= p_toMod;
            CEETSTA(isPresent: p_toMod: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            toMod  = i_toMod;
         else;
            toMod  = '*NONE';
         endif;

         // ... to program
         if  %parms >= p_toPgm;
            CEETSTA(isPresent: p_toPgm: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            toPgm  = i_toPgm;
         else;
            toPgm  = '*NONE';
         endif;

         // Check dependencies ...
         p_assert(i_msg.ID <> cMSG_ID_OK     and
                  i_msg.ID <> cMSG_ID_NULL         :
                  'Message ID must not be ''' + i_msg.ID + '''.'   );

         // Set values to call QMHSNDPM API:
         // Call stack counter ...
         select;
         // ... *EXT
         when   toStkC = cMsg_Ext;
            callStkCtr = 0;
            toProc     = '*EXT';
         // ... *PERVIOUS
         when   toStkC = cMsg_Prv;
            callStkCtr = 1;
         // ... *SAME
         when   toStkC = cMsg_Same;
            callStkCtr = 0;
         // ... others
         other;
            callStkCtr = toStkC;
         endsl;

         // To procedure ...
         select;
         // ... *
         when   toProc = cMsg_ToMyself;
            callStkE   = '*';
            // ... add 1 to skip f_sndPgmMsg() stack entry
            callStkCtr = callStkCtr + 1;
            // ... *PGMBDY
         when   toProc = cMsg_ToPgmBdy;
            callStkE   = '*PGMBDY';
            // ... *CTLBDY
         when   toProc = cMsg_ToCtlBdy;
            callStkE   = '*CTLBDY';
            // ... *PGMNAME
         when   toProc = cMsg_ToPgm;
            callStkE   = '*PGMNAME';
            // ... *EXT
         when   toProc = '*EXT';
            callStkE   = '*EXT';
            // ... named procedure
         other;
            callStkE   = toProc;
         endsl;

         // To module ...
         callStkEQ.module  = toMod;

         // To program ...
         callStkEQ.program = toPgm;

         // Set message file name and library ...
         qMsgF.name = i_msg.file;
         qMsgF.lib  = i_msg.lib;

         // Initialize message key ...
         msgKey  = '';

         // Initialize error code ...
         errCode = f_newApiErrCode(cFalse);

         // Finally send the message ...
         QMHSNDPM(i_msg.ID: qMsgF: i_msg.data: %len(%trimR(i_msg.data)):
                  i_msg.type: callStkE: callStkCtr: msgKey: errCode:
                  %len(%trimR(callStkE)): callStkEQ: -1);

         // Check API error code
         if  f_isApiError(errCode);
            msgKey = '';
            msg    = f_cvtApiErrCodeToMsg(errCode);
         else;
            msg    = f_newMsg(cMsg_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   msgKey;

      /END-FREE
      *
     P f_sndPgmMsg...
     P                 E
      *
      *=========================================================================
      *  Receives a program message.
      *=========================================================================
      *  Parameters:
      *   i_msgType     - The type of the message to receive.
      *                   Please refer to PBASICS1R1 for a list of valid
      *                   message types.
      *   i_msgKey      - The key of the message to receive.
      *                   Default:        *BLANKS
      *   i_action      - The action to take after the message
      *                   is received.
      *                   Default:        cMsg_Act_Same
      *                   cMsg_Act_Old  - Keep message, mark as old.
      *                   cMsg_Act_Rmv  - Remove message.
      *                   cMsg_Act_Same - Keep message.
      *   i_wait        - The time to wait for the message.
      *                   Default:        0
      *                   0             - Do not wait.
      *                   -1            - Wait forever.
      *                   n             - Wait n seconds.
      *   i_fromStkC    - The stack entry to send the message to.
      *                   Default:        cMsg_Same
      *                   cMsg_Ext      - The external message queue.
      *                   cMsg_Prv      - The procedure that is before
      *                                   the procdure that is specified
      *                                   at i_toProc.
      *                   cMsg_Same     - The procedure that is specified
      *                                   at i_toProc.
      *   i_fromProc    - The procedure to send the message to.
      *                   Default:        cMsg_ToMyself
      *                   cMsg_ToMyself - The procedure that calls
      *                                   f_rcvPgmMsg().
      *   i_fromMod     - The module that contains the procedure.
      *                   Default:        *NONE
      *   i_fromPgm     - The program that contains the module.
      *                   Default:        *NONE
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   rcvm0200_t    - Format RCVM0200 of the received message.
      *=========================================================================
     P f_rcvPgmMsg...
     P                 B                   export
      *
     D f_rcvPgmMsg...
     D                 PI                         likeds(rcvm0200_t)
     D  i_msgType                    10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_action                     10A   const  options(*nopass: *omit)
     D  i_wait                       10I 0 const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Parameter positions
     D p_msgKey        C                   const(2)
     D p_action        C                   const(3)
     D p_wait          C                   const(4)
     D p_fromStkC      C                   const(5)
     D p_fromProc      C                   const(6)
     D p_fromMod       C                   const(7)
     D p_fromPgm       C                   const(8)
     D p_msg           C                   const(9)
      *
      *  Optional parameter fields
     D msgKey          S                   like(i_msgKey  ) inz
     D action          S                   like(i_action  ) inz
     D wait            S                   like(i_wait    ) inz
     D fromStkC        S                   like(i_fromStkC) inz
     D fromProc        S                   like(i_fromProc) inz
     D fromMod         S                   like(i_fromMod ) inz
     D fromPgm         S                   like(i_fromPgm ) inz
     D msg             DS                  likeds(o_msg   ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QMHSNDPM
     D rcvm0200        DS                  likeds(rcvm0200_t) inz
     D callStkE        S                   like(i_fromProc  ) inz
     D callStkCtr      S             10I 0                    inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... message key
         if  %parms >= p_msgKey;
            CEETSTA(isPresent: p_msgKey: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            msgKey = i_msgKey;
         else;
            msgKey = '';
         endif;

         // ... action
         if  %parms >= p_action;
            CEETSTA(isPresent: p_action: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            action = i_action;
         else;
            action = cMsg_Act_Same;
         endif;

         // ... wait
         if  %parms >= p_wait;
            CEETSTA(isPresent: p_wait: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            wait = i_wait;
         else;
            wait = 0;            //  Do not wait for the message.
         endif;

         // ... stack counter
         if  %parms >= p_fromStkC;
            CEETSTA(isPresent: p_fromStkC: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromStkC = i_fromStkC;
         else;
            fromStkC = cMsg_Same;
         endif;

         // ... from procedure
         if  %parms >= p_fromProc;
            CEETSTA(isPresent: p_fromProc: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromProc = i_fromProc;
         else;
            fromProc = cMsg_toMySelf;
         endif;

         // ... from module
         if  %parms >= p_fromMod;
            CEETSTA(isPresent: p_fromMod: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromMod  = i_fromMod;
         else;
            fromMod  = '*NONE';
         endif;

         // ... from program
         if  %parms >= p_fromPgm;
            CEETSTA(isPresent: p_fromPgm: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromPgm  = i_fromPgm;
         else;
            fromPgm  = '*NONE';
         endif;

         // Set values to call QMHSNDPM API:
         // Call stack counter ...
         select;
         // ... *EXT
         when   fromStkC = cMsg_Ext;
            callStkCtr = 0;
            fromProc   = '*EXT';
         // ... *PERVIOUS
         when   fromStkC = cMsg_Prv;
            callStkCtr = 1;
         // ... *SAME
         when   fromStkC = cMsg_Same;
            callStkCtr = 0;
         // ... sonst
         other;
            callStkCtr = fromStkC;
         endsl;

         // From procedure ...
         select;
         // ... *
         when   fromProc = cMsg_ToMyself;
            callStkE   = '*';
            // ... add 1 to skip f_rcvPgmMsg() stack entry
            callStkCtr = callStkCtr + 1;
         // ... *EXT
         when   fromProc = '*EXT';
            callStkE   = '*EXT';
         // ... named procedure
         other;
            callStkE   = fromProc;
         endsl;

         // From module ...
         callStkEQ.module  = fromMod;

         // From program ...
         callStkEQ.program = fromPgm;

         // Initialize error code ...
         errCode = f_newApiErrCode(cFalse);

         // Finally receive the message ...
         QMHRCVPM(rcvm0200: %size(rcvm0200): 'RCVM0200': callStkE: callStkCtr:
                  i_msgType: msgKey: wait: action: errCode:
                  %len(%trimR(callStkE)): callStkEQ);

         // Check API error code
         if  f_isApiError(errCode);
            clear   rcvm0200;
            msg = f_cvtApiErrCodeToMsg(errCode);
         else;
            p_assert(%size(rcvm0200) >= rcvm0200.bytAvl :                                   //RADDAT
                     'RCVM0200 too small to hold result');
            msg = f_newMsg(cMsg_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   rcvm0200;

      /END-FREE
      *
     P f_rcvPgmMsg...
     P                 E
      *
      *=========================================================================
      *  Receives a program message and returns a message structure.
      *=========================================================================
      *  Parameters:
      *   i_msgType     - The type of the message to receive.
      *                   Please refer to PBASICS1R1 for a list of valid
      *                   message types.
      *   i_msgKey      - The key of the message to receive.
      *                   Default:        *BLANKS
      *   i_action      - The action to take after the message
      *                   is received.
      *                   Default:        cMsg_Act_Same
      *                   cMsg_Act_Old  - Keep message, mark as old.
      *                   cMsg_Act_Rmv  - Remove message.
      *                   cMsg_Act_Same - Keep message.
      *   i_wait        - The time to wait for the message.
      *                   Default:        0
      *                   0             - Do not wait.
      *                   -1            - Wait forever.
      *                   n             - Wait n seconds.
      *   i_fromStkC    - The stack entry to send the message to.
      *                   Default:        cMsg_Same
      *                   cMsg_Ext      - The external message queue.
      *                   cMsg_Prv      - The procedure that is before
      *                                   the procdure that is specified
      *                                   at i_toProc.
      *                   cMsg_Same     - The procedure that is specified
      *                                   at i_toProc.
      *   i_fromProc    - The procedure to send the message to.
      *                   Default:        cMsg_ToMyself
      *                   cMsg_ToMyself - The procedure that calls
      *                                   f_rcvPgmMsg().
      *   i_fromMod     - The module that contains the procedure.
      *                   Default:        *NONE
      *   i_fromPgm     - The program that contains the module.
      *                   Default:        *NONE
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msg           - Received message.
      *=========================================================================
     P f_rcvPgmMsgObj...
     P                 B                   export
      *
     D f_rcvPgmMsgObj...
     D                 PI                         likeds(msg_t )
     D  i_msgType                    10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_action                     10A   const  options(*nopass: *omit)
     D  i_wait                       10I 0 const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D rtnMsg          DS                  likeds(msg_t ) inz
      *
      *  Parameter positions
     D p_msgKey        C                   const(2)
     D p_action        C                   const(3)
     D p_wait          C                   const(4)
     D p_fromStkC      C                   const(5)
     D p_fromProc      C                   const(6)
     D p_fromMod       C                   const(7)
     D p_fromPgm       C                   const(8)
     D p_msg           C                   const(9)
      *
      *  Optional parameter fields
     D fromStkC        S                   like(i_fromStkC) inz
     D msg             DS                  likeds(o_msg   ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *
      *  Helper fields
     D callStkCtr      S             10I 0 inz
     D rcvm0200        DS                  likeds(rcvm0200_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... stack counter
         if (%parms() >= p_fromStkC);
            CEETSTA(isPresent: p_fromStkC: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            fromStkC = i_fromStkC;
         else;
            fromStkC = cMsg_Same;
         endif;

         // Adjust stack counter
         select;
         when (fromStkC = cMsg_Ext);
            callStkCtr = fromStkC;
         // ... *PERVIOUS
         when (fromStkC = cMsg_Prv);
            callStkCtr = 1 + 1;  // let f_rcvPgmMsg() skip f_rcvPgmMsgObj()
         // ... *SAME
         when (fromStkC = cMsg_Same);
            callStkCtr = 0 + 1;  // let f_rcvPgmMsg() skip f_rcvPgmMsgObj()
         // ... everything else
         other;
            callStkCtr = fromStkC + 1;  // let f_rcvPgmMsg() skip f_rcvPgmMsgObj()
         endsl;

         // Receive the message
         select;
         when (%parms() < p_msgKey);    //   1 parameter passed
            rcvm0200 = f_rcvPgmMsg(i_msgType: *omit: *omit: *omit: callStkCtr
                                   : *omit: *omit: *omit: msg);

         when (%parms() = p_msgKey);    //   2 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey: *omit: *omit: callStkCtr
                                   : *omit: *omit: *omit: msg);

         when (%parms() = p_action);    //   3 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action: *omit: callStkCtr
                                   : *omit: *omit: *omit: msg);

         when (%parms() = p_wait);      //   4 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action
                                   : i_wait: callStkCtr
                                   : *omit: *omit: *omit: msg);

         when (%parms() = p_fromStkC);  //   5 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action
                                   : i_wait
                                   : callStkCtr
                                   : *omit: *omit: *omit: msg);

         when (%parms() = p_fromProc);  //   6 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action
                                   : i_wait
                                   : callStkCtr
                                   : i_fromProc
                                   : *omit: *omit: msg);

         when (%parms() = p_fromMod);   //   7 parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action
                                   : i_wait
                                   : callStkCtr
                                   : i_fromProc
                                   : i_fromMod
                                   : *omit: msg);

         other;                         //   8 or more parameters passed
            rcvm0200 = f_rcvPgmMsg(i_msgType
                                   : i_msgKey
                                   : i_action
                                   : i_wait
                                   : callStkCtr
                                   : i_fromProc
                                   : i_fromMod
                                   : i_fromPgm
                                   : msg);
         endsl;

         if (msg.ID = cMSG_ID_OK);
            rtnMsg = f_cvtRcvMsgToMsg(rcvm0200);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return rtnMsg;

      /END-FREE
      *
     P f_rcvPgmMsgObj...
     P                 E
      *
      *=========================================================================
      *  Removes a program message.
      *=========================================================================
      *  Parameters:
      *   i_msgToRemove - The type of the message to receive.
      *                   cMsg_Rmv_All  - Remove all messages.
      *                   cMsg_Rmv_ByKey- Remove message that is specified
      *                                   by i_msgKey.
      *                   cMsg_Rmv_New  - Remove new messages.
      *                   cMsg_Rmv_Old  - Remove old messages.
      *                   cMsg_Rmv_Scope- Remove the scope message in the
      *                                   message key parameter.
      *   i_msgKey      - The key of the message to remove.
      *                   Default:        *BLANKS
      *   i_toStkC      - The stack entry to send the message to.
      *                   Default:        cMsg_Same
      *                   cMsg_AllInact - All inactive call stack entries.
      *                                   i_msgToRemove must be cMsg_Rmv_All.
      *                   cMsg_Ext      - The external message queue.
      *                   cMsg_Prv      - The procedure that is before
      *                                   the procdure that is specified
      *                                   at i_toProc.
      *                   cMsg_Same     - The procedure that is specified
      *                                   at i_toProc.
      *   i_toProc      - The procedure to send the message to.
      *                   Default:        cMsg_toMySelf
      *                   cMsg_ToMyself - The procedure that calls
      *                                   f_rcvPgmMsg().
      *   i_toMod       - The module that contains the procedure.
      *                   Default:        *NONE
      *   i_toPgm       - The program that contains the module.
      *                   Default:        *NONE
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   void
      *=========================================================================
     P p_rmvPgmMsg...
     P                 B                   export
      *
     D p_rmvPgmMsg...
     D                 PI
     D  i_msgToRemove                10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Parameter positions
     D p_msgKey        C                   const(2)
     D p_fromStkC      C                   const(3)
     D p_fromProc      C                   const(4)
     D p_fromMod       C                   const(5)
     D p_fromPgm       C                   const(6)
     D p_msg           C                   const(7)
      *
      *  Optional parameter fields
     D msgKey          S                   like(i_msgKey  ) inz
     D fromStkC        S                   like(i_fromStkC) inz
     D fromProc        S                   like(i_fromProc) inz
     D fromMod         S                   like(i_fromMod ) inz
     D fromPgm         S                   like(i_fromPgm ) inz
     D msg             DS                  likeds(o_msg   ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QMHSNDPM
     D callStkE        S                   like(i_fromProc  ) inz
     D callStkCtr      S             10I 0                    inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... message key
         if  %parms >= p_msgKey;
            CEETSTA(isPresent: p_msgKey: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            msgKey = i_msgKey;
         else;
            msgKey = '';
         endif;

         // ... stack counter
         if  %parms >= p_fromStkC;
            CEETSTA(isPresent: p_fromStkC: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromStkC = i_fromStkC;
         else;
            fromStkC = cMsg_Same;
         endif;

         // ... from procedure
         if  %parms >= p_fromProc;
            CEETSTA(isPresent: p_fromProc: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromProc = i_fromProc;
         else;
            fromProc = cMsg_toMySelf;
         endif;

         // ... from module
         if  %parms >= p_fromMod;
            CEETSTA(isPresent: p_fromMod: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromMod  = i_fromMod;
         else;
            fromMod  = '*NONE';
         endif;

         // ... from program
         if  %parms >= p_fromPgm;
            CEETSTA(isPresent: p_fromPgm: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            fromPgm  = i_fromPgm;
         else;
            fromPgm  = '*NONE';
         endif;

         // Set values to call QMHRMVPM API:
         // Call stack counter ...
         select;
         // ... *ALLINACT
         when   fromStkC = cMsg_AllInact;
            callStkCtr = 0;
            fromProc   = '*ALLINACT';
         // ... *EXT
         when   fromStkC = cMsg_Ext;
            callStkCtr = 0;
            fromProc   = '*EXT';
         // ... *PERVIOUS
         when   fromStkC = cMsg_Prv;
            callStkCtr = 1;
         // ... *SAME
         when   fromStkC = cMsg_Same;
            callStkCtr = 0;
         // ... sonst
         other;
            callStkCtr = fromStkC;
         endsl;

         // From procedure ...
         select;
         // ... *
         when   fromProc = cMsg_ToMyself;
            callStkE   = '*';
            // ... add 1 to skip f_rcvPgmMsg() stack entry
            callStkCtr = callStkCtr + 1;
         // ... *EXT
         when   fromProc = '*EXT';
            callStkE   = '*EXT';
         // ... *ALLINACT
         when   fromProc = '*ALLINACT';
            callStkE   = '*ALLINACT';
         // ... named procedure
         other;
            callStkE   = fromProc;
         endsl;

         // From module ...
         callStkEQ.module  = fromMod;

         // From program ...
         callStkEQ.program = fromPgm;

         // Initialize error code ...
         errCode = f_newApiErrCode(cFalse);

         // Finally remove the message ...
         QMHRMVPM(callStkE: callStkCtr: msgKey: i_msgToRemove: errCode:
                  %len(%trimR(callStkE)): callStkEQ: '*NO');

         // Check API error code
         if  f_isApiError(errCode);
            msg = f_cvtApiErrCodeToMsg(errCode);
         else;
            msg = f_newMsg(cMsg_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return;

      /END-FREE
      *
     P p_rmvPgmMsg...
     P                 E
      *
      *=========================================================================
      *  Retrieves the message text of a given message.
      *  Replaces substitution variables with message data.
      *=========================================================================
      *  Parameters:
      *   i_msg         - The message to retrieve the text from.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msgText       - The message text that was retrieved from
      *                   the given message.
      *=========================================================================
     P f_rtvMsgText...
     P                 B                   export
      *
     D f_rtvMsgText...
     D                 PI          4096A          varying
     D  i_msg                              const  likeds(msg_t    )
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D msgText         S           4096A   varying inz
      *
      *  Parameter positions
     D p_msg           C                   const(2)
      *
      *  Optional parameter fields
     D msg             DS                  likeds(o_msg       ) inz
      *
      *  Local fields
     D rtvm0100        DS                  likeds(rtvm0100_t  ) based(pRtvm0100)
     D qMsgF           DS                  likeds(qObj_t      ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *-------------------------------------------------------------------*
      *
      /FREE

         // Retrieve message information
         qMsgF.name = i_msg.file;
         qMsgF.lib  = i_msg.lib;
         pRtvm0100  = lf_rtvMsgD('RTVM0100':
                                 i_msg.ID: %trimR(i_msg.data): qMsgF: msg:
                                 '*YES': '*NO');

         // Retrieve message text from message information
         if   pRtvm0100 <> *NULL;
            if   rtvm0100.lenMsgRet > 0;
               msgText = %subst(rtvm0100: 25: rtvm0100.lenMsgRet);
               dealloc(N) pRtvm0100;
            else;
               msgText = '';
            endif;
         else;
            msgText = '';
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   msgText;

      /END-FREE
      *
     P f_rtvMsgText...
     P                 E
      *
      *=========================================================================
      *  Retrieves the message help text of a given message.
      *  Replaces substitution variables with message data.
      *=========================================================================
      *  Parameters:
      *   i_msg         - The message to retrieve the help text from.
      *   i_rtnCtrlChr  - Specifies whether the control characters are
      *                   returned or not.
      *                   cMsg_RtnCtrlChar_Yes - Return control characters
      *                   cMsg_RtnCtrlChar_No  - Do not return control characters
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msgText       - The message help text that was retrieved from
      *                   the given message.
      *=========================================================================
     P f_rtvMsgHelpText...
     P                 B                   export
      *
     D f_rtvMsgHelpText...
     D                 PI          4096A          varying
     D  i_msg                              const  likeds(msg_t    )
     D  i_rtnCtrlChr                 10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D msgHelpText     S           4096A   varying inz
      *
      *  Parameter positions
     D p_rtnCtrlChr    C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D rtnCtrlChr      S                   like(i_rtnCtrlChr  ) inz
     D msg             DS                  likeds(o_msg       ) inz
      *
      *  Local fields
     D qMsgF           DS                  likeds(qObj_t      ) inz
     D rtvm0100        DS                  likeds(rtvm0100_t  ) based(pRtvm0100)
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *-------------------------------------------------------------------*
      *
      /FREE

         // Process optional parameter values ...
         // ... rtnCtrlChr
         if   %parms >= p_rtnCtrlChr;
            CEETSTA(isPresent: p_rtnCtrlChr: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            rtnCtrlChr = i_rtnCtrlChr;
         else;
            rtnCtrlChr = '*NO';
         endif;

         // Retrieve message information
         qMsgF.name = i_msg.file;
         qMsgF.lib  = i_msg.lib;
         pRtvm0100  = lf_rtvMsgD('RTVM0100':
                                 i_msg.ID: %trimR(i_msg.data): qMsgF: msg:
                                 '*YES': rtnCtrlChr);

         // Retrieve message help text from message information
         if   pRtvm0100 <> *NULL;
            if   rtvm0100.lenHlpRet > 0;
               msgHelpText = %subst(rtvm0100: 25 + rtvm0100.lenMsgRet:
                                    rtvm0100.lenHlpRet);
               dealloc(N) pRtvm0100;
            else;
               msgHelpText = '';
            endif;
         else;
            msgHelpText = '';
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   msgHelpText;

      /END-FREE
      *
     P f_rtvMsgHelpText...
     P                 E
      *
      *=========================================================================
      *  Retrieves the message text of a given message.
      *  Does not replaces substitution variables with message data.
      *=========================================================================
      *  Parameters:
      *   i_msg         - The message to retrieve the text from.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msgText       - The message text that was retrieved from
      *                   the given message.
      *=========================================================================
     P f_rtvMsgTextRaw...
     P                 B                   export
      *
     D f_rtvMsgTextRaw...
     D                 PI          4096A          varying
     D  i_msg                              const  likeds(msg_t    )
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D msgText         S           4096A   varying inz
      *
      *  Parameter positions
     D p_msg           C                   const(2)
      *
      *  Optional parameter fields
     D msg             DS                  likeds(o_msg       ) inz
      *
      *  Local fields
     D rtvm0100        DS                  likeds(rtvm0100_t  ) based(pRtvm0100)
     D qMsgF           DS                  likeds(qObj_t      ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *-------------------------------------------------------------------*
      *
      /FREE

         // Retrieve message information
         qMsgF.name = i_msg.file;
         qMsgF.lib  = i_msg.lib;
         pRtvm0100  = lf_rtvMsgD('RTVM0100':
                                 i_msg.ID: %trimR(i_msg.data): qMsgF: msg:
                                 '*NO': '*NO');

         // Retrieve message text from message information
         if   pRtvm0100 <> *NULL;
            if   rtvm0100.lenMsgRet > 0;
               msgText = %subst(rtvm0100: 25: rtvm0100.lenMsgRet);
               dealloc(N) pRtvm0100;
            else;
               msgText = '';
            endif;
         else;
            msgText = '';
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   msgText;

      /END-FREE
      *
     P f_rtvMsgTextRaw...
     P                 E
      *
      *=========================================================================
      *  Retrieves the message help text of a given message.
      *  Does not replaces substitution variables with message data.
      *=========================================================================
      *  Parameters:
      *   i_msg         - The message to retrieve the help text from.
      *   i_rtnCtrlChr  - Specifies whether the control characters are
      *                   returned or not.
      *                   cMsg_RtnCtrlChar_Yes - Return control characters
      *                   cMsg_RtnCtrlChar_No  - Do not return control characters
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   msgText       - The message help text that was retrieved from
      *                   the given message.
      *=========================================================================
     P f_rtvMsgHelpTextRaw...
     P                 B                   export
      *
     D f_rtvMsgHelpTextRaw...
     D                 PI          4096A          varying
     D  i_msg                              const  likeds(msg_t    )
     D  i_rtnCtrlChr                 10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D msgHelpText     S           4096A   varying inz
      *
      *  Parameter positions
     D p_rtnCtrlChr    C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D rtnCtrlChr      S                   like(i_rtnCtrlChr  ) inz
     D msg             DS                  likeds(o_msg       ) inz
      *
      *  Local fields
     D qMsgF           DS                  likeds(qObj_t      ) inz
     D rtvm0100        DS                  likeds(rtvm0100_t  ) based(pRtvm0100)
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *-------------------------------------------------------------------*
      *
      /FREE

         // Process optional parameter values ...
         // ... rtnCtrlChr
         if   %parms >= p_rtnCtrlChr;
            CEETSTA(isPresent: p_rtnCtrlChr: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            rtnCtrlChr = i_rtnCtrlChr;
         else;
            rtnCtrlChr = '*NO';
         endif;

         // Retrieve message information
         qMsgF.name = i_msg.file;
         qMsgF.lib  = i_msg.lib;
         pRtvm0100  = lf_rtvMsgD('RTVM0100':
                                 i_msg.ID: %trimR(i_msg.data): qMsgF: msg:
                                 '*NO': rtnCtrlChr);

         // Retrieve message help text from message information
         if   pRtvm0100 <> *NULL;
            if   rtvm0100.lenHlpRet > 0;
               msgHelpText = %subst(rtvm0100: 25 + rtvm0100.lenMsgRet:
                                    rtvm0100.lenHlpRet);
               dealloc(N) pRtvm0100;
            else;
               msgHelpText = '';
            endif;
         else;
            msgHelpText = '';
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   msgHelpText;

      /END-FREE
      *
     P f_rtvMsgHelpTextRaw...
     P                 E
      *
      *=========================================================================
      *  Converts a received message of format RCVM0200 to a message.
      *=========================================================================
      *  Parameters:
      *   i_rcvm0200    - Format RCVM0200 of the received message.
      *   i_type        - The message type.
      *                   Default:        cMsg_Info
      *
      *  Returns:
      *   msg           - Message as message structure
      *=========================================================================
     P f_cvtRcvMsgToMsg...
     P                 B                   export
      *
     D f_cvtRcvMsgToMsg...
     D                 PI                         likeds(msg_t     )
     D  i_rcvm0200                         const  likeds(rcvm0200_t)
     D  i_type                             const  like(msg_t.type  )
     D                                            options(*omit: *nopass)
      *
      *  Return value
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Parameter positions
     D p_type          C                   const(2)
      *
      *  Optional parameter fields
     D type            S                   like(i_type      ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *
      *  Helper fields
     D msgID           S                   like(msg_t.ID    ) inz
     D msgData         S                   like(msg_t.data  ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... Type
         if  %parms >= p_type;
            CEETSTA(isPresent: p_type: *omit);
         else;
            isPresent = 0;
         endif;

         if  isPresent = 1;
            type = i_type;
         else;
            select;
            when (i_rcvm0200.msgType = '01');   // Completion
               type = cMsg_Comp;
            when (i_rcvm0200.msgType = '02');   // Diagnostic
               type = cMsg_Diag;
            when (i_rcvm0200.msgType = '04');   // Informational
               type = cMsg_Info;
            when (i_rcvm0200.msgType = '05');   // Inquery
               type = cMsg_Inq;
            when (i_rcvm0200.msgType = '06');   // Sender's copy
               type = cMsg_Copy;
            when (i_rcvm0200.msgType = '08');   // Request
               type = cMsg_Rqs;
            when (i_rcvm0200.msgType = '10');   // Request with prompting
               type = cMsg_Rqs;
            when (i_rcvm0200.msgType = '14');   // Notify
               type = cMsg_Notify;
            when (i_rcvm0200.msgType = '15');   // Escape
               type = cMsg_Escape;
            when (i_rcvm0200.msgType = '16');   // Notify, exception not handled when API is c
               type = cMsg_Notify;
            when (i_rcvm0200.msgType = '17');   // Escape, exception not handled when API is c
               type = cMsg_Escape;
            when (i_rcvm0200.msgType = '21');   // Reply, not validity checked
               type = cMsg_Rpy;
            when (i_rcvm0200.msgType = '22');   // Reply, validity checked
               type = cMsg_Rpy;
            when (i_rcvm0200.msgType = '23');   // Reply, message default used
               type = cMsg_Rpy;
            when (i_rcvm0200.msgType = '24');   // Reply, system default used
               type = cMsg_Rpy;
            when (i_rcvm0200.msgType = '25');   // Reply, from system reply list
               type = cMsg_Rpy;
            when (i_rcvm0200.msgType = '26');   // Reply, from exit program
               type = cMsg_Rpy;
            other;
               type = cMsg_Info;
            endsl;
         endif;

         if i_rcvm0200.lnRplDtR = 0;
            msgData = '';
         else;
            msgData = %subst(i_rcvm0200.value: 1: i_rcvm0200.lnRplDtR);
         endif;

         if i_rcvm0200.msgID = '';
            msgID = cMSG_ID_NULL;
         else;
            msgID = i_rcvm0200.msgID;
         endif;

         msg = f_newMsg(msgID: msgData: type
                        : i_rcvm0200.msgF: i_rcvm0200.msgLU);

         return   msg;

      /END-FREE
      *
     P f_cvtRcvMsgToMsg...
     P                 E
      *
      *=========================================================================
      *  Returns the sender information of a receives program message.
      *=========================================================================
      *  Parameters:
      *   i_rcvm0200    - Format RCVM0200 of the received message.
      *
      *  Returns:
      *   sndInf        - Sender information of the received message.
      *=========================================================================
     P f_getSndInfOfRcvMsg...
     P                 B                   export
      *
     D f_getSndInfOfRcvMsg...
     D                 PI                         likeds(sndInf_t  )
     D  i_rcvm0200                         const  likeds(rcvm0200_t)
     D  o_longSndPgm                256A          options(*nopass: *omit)
     D  o_longSndPrc                256A          options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D sndInf          DS                  likeds(sndInf_t  ) inz
      *
      *  Parameter positions
     D p_longSndPgm    C                   const(2)
     D p_longSndPrc    C                   const(3)
     D p_msg           C                   const(4)
      *
      *  Optional parameter fields
     D longSndPgm      S                   like(o_longSndPgm) inz
     D longSndPrc      S                   like(o_longSndPrc) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields
     D memSize         S             10I 0 inz
     D rcvm0300        DS                  likeds(rcvm0300_t) based(pRcvm0300 )
     D tmpSndInf       DS                  likeds(sndInf_t  )
     D                                     based(pTmpSndInf)
     D tmpLongSndPgm   S                   like(o_longSndPgm)
     D                                     based(pTmpLongSndPgm)
     D tmpLongSndPrc   S                   like(o_longSndPrc)
     D                                     based(pTmpLongSndPrc)
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         memSize   = %size(rcvm0300) + 1024;
         pRcvm0300 = %alloc(memSize);
         errCode   = f_newApiErrCode(cFalse);

         dou (rcvm0300.bytRet >= rcvm0300.bytAvl or f_isApiError(errCode));
            QMHRCVPM(rcvm0300: memSize: 'RCVM0300': '*': 0:
                     cMsg_Any: i_rcvm0200.msgKey: 0: cMsg_Act_Same: errCode);
            if (rcvm0300.bytRet < rcvm0300.bytAvl);
               memSize   = rcvm0300.bytAvl;
               pRcvm0300 = %realloc(pRcvm0300: memSize);
            endif;
         enddo;

         // Check API error code
         if  f_isApiError(errCode);
            msg = f_cvtApiErrCodeToMsg(errCode);
            clear sndInf;
            clear longSndPgm;
            clear longSndPrc;
         else;
            msg = f_newMsg(cMsg_ID_OK);
            pTmpSndInf = %addr(rcvm0300) +
                         %size(rcvm0300) +
                         rcvm0300.lenRplDataR +
                         rcvm0300.lenMsgR +
                         rcvm0300.lenMsgHlpR;
            pTmpLongSndPgm = pTmpSndInf + tmpSndInf.ofsSndPgmLName;
            pTmpLongSndPrc = pTmpSndInf + tmpSndInf.ofsSndPrcLName;
            sndInf     = tmpSndInf;
            longSndPgm = %subst(tmpLongSndPgm: 1: tmpSndInf.lenSndPgmLName);
            longSndPrc = %subst(tmpLongSndPrc: 1: tmpSndInf.lenSndPrcLName);
         endif;

         dealloc(N) pRcvm0300;

         // Set optional output parameters
         if (%parms() >= p_longSndPgm and %addr(o_longSndPgm) <> *NULL);
            o_longSndPgm = longSndPgm;
         endif;

         if (%parms() >= p_longSndPrc and %addr(o_longSndPrc) <> *NULL);
            o_longSndPrc = longSndPrc;
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            if (%addr(o_msg) <> *NULL);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return sndInf;

      /END-FREE
      *
     P f_getSndInfOfRcvMsg...
     P                 E
      *
      *=========================================================================
    R *  *** Private ***
      *  Get application message file name
      *=========================================================================
     P lf_getAppMsgFileName...
     P                 B
      *
     D lf_getAppMsgFileName...
     D                 PI            10A
      *
      *  Return value
     D appMsgFileName  S             10A   inz
      *-------------------------------------------------------------------*
      *
      /FREE

         if  g_qAppMsgFile.name = '';
            appMsgFileName = 'QCPFMSG';
            else;
            appMsgFileName = g_qAppMsgFile.name;
         endif;

         return   appMsgFileName;

      /END-FREE
      *
     P lf_getAppMsgFileName...
     P                 E
      *
      *=========================================================================
    R *  *** Private ***
      *  Get application message file library name
      *=========================================================================
     P lf_getAppMsgFileLibrary...
     P                 B
      *
     D lf_getAppMsgFileLibrary...
     D                 PI            10A
      *
      *  Return value
     D appMsgFileLib   S             10A   inz
      *-------------------------------------------------------------------*
      *
      /FREE

         if  g_qAppMsgFile.name = '';
            appMsgFileLib = '*LIBL';
            else;
            appMsgFileLib = g_qAppMsgFile.lib;
         endif;

         return   appMsgFileLib;

      /END-FREE
      *
     P lf_getAppMsgFileLibrary...
     P                 E
      *
      *=========================================================================
    R *  *** Private ***
      *  Set application message file name
      *=========================================================================
     P lp_setAppMsgFileName...
     P                 B
      *
     D lp_setAppMsgFileName...
     D                 PI
     D  i_file                       10A   const
      *-------------------------------------------------------------------*
      *
      /FREE

         g_qAppMsgFile.name = i_file;

         return;

      /END-FREE
      *
     P lp_setAppMsgFileName...
     P                 E
      *
      *=========================================================================
    R *  *** Private ***
      *  Set application message file library name
      *=========================================================================
     P lp_setAppMsgFileLibrary...
     P                 B
      *
     D lp_setAppMsgFileLibrary...
     D                 PI
     D  i_lib                        10A   const
      *-------------------------------------------------------------------*
      *
      /FREE

         g_qAppMsgFile.lib = i_lib;

         return;

      /END-FREE
      *
     P lp_setAppMsgFileLibrary...
     P                 E
      *
      *=========================================================================
    R *  *** Private ***
      *  Retrieve message description
      *=========================================================================
     P lf_rtvMsgD...
     P                 B
      *
     D lf_rtvMsgD...
     D                 PI              *
     D  i_format                      8A   const
     D  i_msgID                       7A   const
     D  i_rplData                  4096A   const  varying
     D  i_qMsgF                            const  likeds(qObj_t    )
     D  o_msg                                     likeds(msg_t     )
     D  i_rplVars                    10A   const  options(*nopass)
     D  i_rtnCtrlChr                 10A   const  options(*nopass)
      *
      *  Return value
     D pMsgInf         S               *   inz
      *
      *  Parameter positions
     D p_rplVars       C                   const(6)
     D p_rtnCtrlChr    C                   const(7)
      *
      *  Optional parameter fields
     D rplVars         S                   like(i_rplVars   ) inz
     D rtnCtrlChr      S                   like(i_rtnCtrlChr) inz
      *
      *  Local fields
     D msgInf          DS                  based(pMsgInf) qualified
     D  bytRet                       10I 0
     D  bytAvl                       10I 0
     D errCode         DS                  likeds(errCode_t ) inz
      *
     D memSize         S             10I 0 inz
      *-------------------------------------------------------------------*
      *
      /FREE

         // Process optional parameter values ...
         // ... rplvars
         if   %parms >= p_rplvars;
            rplvars = i_rplvars;
         else;
            rplvars = '*YES';
         endif;

         // ... rtnCtrlChr
         if   %parms >= p_rtnCtrlChr;
            rtnCtrlChr = i_rtnCtrlChr;
         else;
            rtnCtrlChr = '*NO';
         endif;

         // Allocate memory and set initial parameter values
         memSize = 8;
         pMsgInf = %alloc(memSize);
         errCode = f_newApiErrCode(cTrue);

         // Loop until complete message information is received ...
         dou   msgInf.bytRet >= msgInf.bytAvl;
            // ... call the API
            QMHRTVM(msgInf: memSize: i_format: i_msgID: i_qMsgF:
                    i_rplData: %len(i_rplData): rplVars: rtnCtrlChr: errCode);

            // ... check for errors
            if  f_isApiError(errCode);
               dealloc(N) pMsgInf;
               o_msg = f_cvtApiErrCodeToMsg(errCode);
               leave;
            else;
               // ... get more memory
               if   memSize < msgInf.bytAvl;
                  memSize = msgInf.bytAvl;
                  pMsgInf = %realloc(pMsgInf: memSize);
               else;
                  o_msg = f_newMsg(cMsg_ID_OK);
               endif;
            endif;

         enddo;

         return   pMsgInf;

      /END-FREE
      *
     P lf_rtvMsgD...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R2  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R2 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - API Error Handling       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R2  - SrvPgm: Basic Routines - API Error Handling           *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  08.02.2006  Th.Raddatz    Changed BASICS1R2 to be compatible to    *
      *                            V5R1M0.                                  *
      *                                                                     *
      *  08.01.2007  Th.Raddatz    Fixed problem in f_cvtErrnoToMsg().      *
      *                            Now errors without corresponding         *
      *                            message description in QC2MSGF are       *
      *                            returned as CPF9898 message.             *
      *                                                                     *
      *  12.12.2007  Th.Raddatz    Enhanced f_cvtApiErrCodeToMsg() to       *
      *                            receive the original error message from  *
      *                            the previous call stack entry, if        *
      *                            possible.                                *
      *                                                                     *
      *  16.07.2011  Th.Raddatz    Added procedure f_setErrno().            *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R2
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      *=========================================================================
      *  Creates a new API error code.
      *=========================================================================
      *  Parameters:
      *   i_monMsg      - Specifies whether API error conditions
      *                   are monitored or not.
      *                   Default:        cFalse
      *
      *  Returns:
      *   errCode       - The new API error code.
      *=========================================================================
     P f_newApiErrCode...
     P                 B                   export
      *
     D f_newApiErrCode...
     D                 PI                         likeds(errCode_t )
     D  i_monMsg                       N   const  options(*nopass)
      *
      *  Return value
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Parameter positions
     D p_monMsg        C                   const(1)
      *
      *  Optional parameter fields
     D monMsg          S                   like(i_monMsg    ) inz
      *-------------------------------------------------------------------*
      /FREE

         // Process optional parameter values ...
         // ... monitor messages
          if   %parms >= p_monMsg;
             monMsg = i_monMsg;
          else;
             monMsg = cFalse;
          endif;

         // Produce API error code ...
         clear   errCode;
         if   monMsg = cTrue;
            errCode.bytPrv = %size(errCode);
         else;
            errCode.bytPrv = 0;
         endif;

         return   errCode;

      /END-FREE
      *
     P f_newApiErrCode...
     P                 E
      *
      *=========================================================================
      *  Is API error?
      *=========================================================================
      *  Parameters:
      *   i_errCode     - The error code returned from the API call.
      *
      *  Returns:
      *   isError       - Returns cTrue in case of an API error.
      *=========================================================================
     P f_isApiError...
     P                 B                   export
      *
     D f_isApiError...
     D                 PI              N
     D  i_errCode                      N   const  likeds(errCode_t )
      *
      *  Return value
     D isError         S               N   inz
      *-------------------------------------------------------------------*
      /FREE

         if   i_errCode.bytAvl > 0;
            isError = cTrue;
         else;
            isError = cFalse;
         endif;

         return   isError;

      /END-FREE
      *
     P f_isApiError...
     P                 E
      *
      *=========================================================================
      *  Converts an API error code to a messsage.
      *=========================================================================
      *  Parameters:
      *   i_errCode     - The error code returned from the API call.
      *
      *  Returns:
      *   msg           - The error message.
      *=========================================================================
     P f_cvtApiErrCodeToMsg...
     P                 B                   export
      *
     D f_cvtApiErrCodeToMsg...
     D                 PI                         like(msg_t     )
     D  i_errCode                      N   const  likeds(errCode_t )
      *
      *  Return value
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Helper fields
     D tmpMsg          DS                  likeds(msg_t     ) inz
     D rcvm0200        DS                  likeds(rcvm0200_t) inz
      *-------------------------------------------------------------------*
      /FREE

         if   i_errCode.bytAvl = 0;
            msg = f_newMsg(cMSG_ID_OK);
         else;
            msg = f_newMsg(i_errCode.excID: i_errCode.excDta: cMsg_Escape:
                           'QCPFMSG' : '*LIBL');
            // Try to get the user error message from the previous
            // call stack entry
            rcvm0200 = f_rcvPgmMsg(cMsg_Any: *omit: cMsg_Act_Same: 0: cMsg_Prv);
            tmpMsg = f_cvtRcvMsgToMsg(rcvm0200: cMsg_Escape);
            if (i_errCode.excID = tmpMsg.ID);
               msg = tmpMsg;
            endif;
         endif;

         return   msg;

      /END-FREE
      *
     P f_cvtApiErrCodeToMsg...
     P                 E
      *
      *=========================================================================
      *  Returns the C runtime error number.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   errno         - The C runtime error number.
      *=========================================================================
     P f_errno...
     P                 B                   export
      *
     D f_errno...
     D                 PI            10I 0
      *
      *  Return value
     D errorNo         S             10I 0 inz
      *
      *  Local fields
     D runTimeError    S             10I 0 based(pRunTimeError)
      *-------------------------------------------------------------------*
      /FREE

         pRunTimeError = errno();

         errorNo = runTimeError;

         return   errorNo;

      /END-FREE
      *
     P f_errno...
     P                 E
      *
      *=========================================================================
      *  Sets the C runtime error number to ZERO (no error).
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   void
      *=========================================================================
     P f_clrErrno...
     P                 B                   export
      *
     D f_clrErrno...
     D                 PI
      *-------------------------------------------------------------------*
      /FREE

         f_setErrno(0);

         return;

      /END-FREE
      *
     P f_clrErrno...
     P                 E
      *
      *=========================================================================
      *  Sets the C runtime error number to a given error code.
      *=========================================================================
      *  Parameters:
      *   i_errno       - A C runtime error number.
      *
      *  Returns:
      *   void
      *=========================================================================
     P f_setErrno...
     P                 B                   export
      *
     D f_setErrno...
     D                 PI
     D  i_errno                      10I 0 const
      *
      *  Local fields
     D runTimeError    S             10I 0 based(pRunTimeError)
      *-------------------------------------------------------------------*
      /FREE

         pRunTimeError = errno();
         runTimeError = i_errno;

         return;

      /END-FREE
      *
     P f_setErrno...
     P                 E
      *
      *=========================================================================
      *  Returns the message text of a C runtime error number.
      *=========================================================================
      *  Parameters:
      *   i_errno       - The C runtime error number returned by
      *                   the f_errno()-function.
      *
      *  Returns:
      *   errText       - The message text of the error number.
      *=========================================================================
     P f_strerror...
     P                 B                   export
      *
     D f_strerror...
     D                 PI           128A          varying
     D  i_errno                      10I 0 const
      *
      *  Return value
     D errText         S            128A   inz  varying
      *
      *  Local fields
     D pErrText        S               *   inz
      *-------------------------------------------------------------------*
      /FREE

         pErrText = strerror(i_errno);
         if   pErrText = *NULL;
            errText = '';
         else;
            errText = %str(pErrText);
         endif;

         return   errText;

      /END-FREE
      *
     P f_strerror...
     P                 E
      *
      *=========================================================================
      *  Converts a C runtime error number to a message.
      *=========================================================================
      *  Parameters:
      *   i_errno       - The C runtime error number returned by
      *                   the f_errno()-function.
      *
      *  Returns:
      *   msg           - The error message.
      *=========================================================================
     P f_cvtErrnoToMsg...
     P                 B                   export
      *
     D f_cvtErrnoToMsg...
     D                 PI                         like(msg_t     )
     D  i_errno                      10I 0 const
      *
      *  Return value
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Local fields
      /if not defined(*V5R3M0)
     D msgID           DS                  qualified
     D  prefix                        3A
     D  nbr                           4S 0
      /endif
      *
     D qMsgF           DS                  likeds(qObj_t    ) inz
     D msgInf          DS                  qualified
     D  bytRet                       10I 0 inz
     D  bytAvl                       10I 0 inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------*
      /FREE

         if   i_errno = 0;
            msg = f_newMsg(cMSG_ID_OK);
         else;
      /if not defined(*V5R3M0)
            msgID.prefix = 'C2M';
            msgID.nbr    = i_errno;
            msg.ID = msgID;
      /else
            msg.ID.prefix = 'C2M';
            msg.ID.nbr    = i_errno;
      /endif
            qMsgF.name = 'QC2MSGF';
            qMsgF.lib  = '*LIBL';
            errCode = f_newApiErrCode(cTrue);
            QMHRTVM(msgInf: %size(msgInf): 'RTVM0100': msg.ID: qMsgF:
                    '': 0: '*NO': '*NO': errCode);
            if not f_isApiError(errCode);
               msg   = f_newMsg(msg.ID
                                : ''
                                : cMsg_Escape: 'QC2MSGF': '*LIBL');
            else;
               msg   = f_newMsg('CPF9898'
                                : %char(i_errno) + ': ' + f_strerror(i_errno)
                                : cMsg_Escape: 'QCPFMSG': '*LIBL');
            endif;
         endif;

         return   msg;

      /END-FREE
      *
     P f_cvtErrnoToMsg...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R3  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R3 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Strings                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R3  - SrvPgm: Basic Routines - Strings                      *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  26.01.2005  Th.Raddatz    Changed f_val to use self-written code   *
      *                            instead of MI function cvtefnd().        *
      *                            cvtefnd() crashes when it encounters an  *
      *                            invalid character.                       *
      *                                                                     *
      *  10.02.2005  Th.Raddatz    Added f_center() to center a string.     *
      *                                                                     *
      *  10.02.2005  Th.Raddatz    Added f_alignR() to right align a        *
      *                            given string.                            *
      *                                                                     *
      *  10.02.2005  Th.Raddatz    Changed f_space() to accept a 0 length.  *
      *                                                                     *
      *  15.02.2005  Th.Raddatz    Fixed problem in f_addQuotes() that      *
      *                            added to many leading and trailing       *
      *                            quotes.                                  *
      *                            Changed f_rmvQuotes() to removes quotes  *
      *                            only in case it is a quoted string.      *
      *                            String must have a leading *and* a       *
      *                            trailing quote.                          *
      *                                                                     *
      *  15.02.2005  Th.Raddatz    Added f_genStrCmp() and                  *
      *                            f_genStrCmpIgncase() to compare strings  *
      *                            using wildcard characters.               *
      *                                                                     *
      *  17.02.2005  Th.Raddatz    Added f_scanR() to a string for the      *
      *                            latest occurrence of a search argument.  *
      *                                                                     *
      *  24.02.2005  Th.Raddatz    Added f_cvtBufferToHexString() to        *
      *                            convert a buffer to a hex string.        *
      *                                                                     *
      *  25.02.2005  Th.Raddatz    Added f_cvtHexStringToBuffer() to        *
      *                            convert a hex string to a buffer.        *
      *                                                                     *
      *  28.02.2005  Th.Raddatz    Changed parameter i_string of            *
      *                            f_wordWrap() to VARYING. Enhanced        *
      *                            f_wordWrap() tp support end-of-paragraph *
      *                            marker.                                  *
      *                                                                     *
      *  17.06.2005  Th.Raddatz    Added f_startsWith().                    *
      *                                                                     *
      *  28.06.2006  Th.Raddatz    Fixed problem in f_wordwrap() that       *
      *                            EOL-character was not found when it was  *
      *                            the last character in the string.        *
      *                                                                     *
      *  20.11.2007  Th.Raddatz    Added f_endsWith().                      *
      *                                                                     *
      *  21.12.2007  Th.Raddatz    Added f_containsInvalidCharAt() and      *
      *                            f_containsStringAt().                    *
      *                                                                     *
      *  17.12.2008  Th.Raddatz    Added f_objName().                       *
      *                                                                     *
      *  15.01.2009  Th.Raddatz    Added f_rplUnPrtChars().                 *
      *                                                                     *
      *  15.01.2009  Th.Raddatz    Added f_rplUnPrtChars().                 *
      *                                                                     *
      *  23.01.2009  Th.Raddatz    Added f_formatDate() and f_parseDate().  *
      *                            Changed parameter i_quote of             *
      *                            f_addQuotes() from 'required' to         *
      *                            'optional'.                              *
      *                            Added f_formatMemSize().                 *
      *                                                                     *
      *  02.02.2009  Th.Raddatz    Fixed problem in f_wordwrap() that       *
      *                            caused a runtime error in case that the  *
      *                            last character of the input string is an *
      *                            EOP escape character.                    *
      *                                                                     *
      *  24.06.2009  Th.Raddatz    Fixed problem in f_genStrCmp() that      *
      *                            does not properly compare strings        *
      *                            that contain multiple dots.              *
      *                                                                     *
      *  03.04.2010  Th.Raddatz    Added f_cvtPtrToHexString().             *
      *                                                                     *
      *  22.01.2010  Th.Raddatz    Added f_startsWithIgnoreCase().          *
      *                                                                     *
      *  07.04.2015  Th.Raddatz    Replaced f_genStrCmp() with a more       *
      *                            reliable approach.                       *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R3
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,CEELIB
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Converts a RPG variable type to a variable class of the edit APIs.
     D lf_cvtRpgVarTypeToEdtAPIVarClass...
     D                 PR            10A
     D                                     extproc(
     D                                     'lf_cvtRpgVarTypeToEdtAPIVarClass')
     D  i_varType                     1A   const
      *
      *  Performs word wrapping on a given string without respect to
      *  end-of-paragraph markers.
     D lf_wordWrap...
     D                 PR          4096A          varying
     D                                     extproc('lf_wordWrap')
     D  i_string                   4096A   const  varying
     D  i_width                      10U 0 const
     D  io_startPos                  10U 0
      *
      *  Compare strings using wildcard characters. (Compare generic)
     D lf_genStrCmpInternal...
     D                 PR              N
     D                                     extproc('lf_genStrCmpInternal')
     D  i_string                   4096A   const   varying
     D  i_pattern                  4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
     D cOPEN_PARENTHESIS...
     D                 C                   const('(')
     D cCLOSE_PARENTHESIS...
     D                 C                   const(')')
     D cSINGLE_QUOTE...
     D                 C                   const('''')
      *
     D cEQUAL_TRUE     C                   const('1')
     D cEQUAL_FALSE    C                   const('0')
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Returns the left portion of a string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to return the left portion of.
      *   i_length      - The length of the left portion to return.
      *
      *  Returns:
      *   string        - The left portion if the string.
      *=========================================================================
      *
     P f_left...
     P                 B                   export
      *
     D f_left...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_length                     10I 0 const
      *
      *  Return value
     D leftString      S           4096A   varying  inz
      *
      *  Local fields
     D length          S                   like(i_length  )  inz
     D start           S                   like(i_length  )  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   i_length <= %len(i_string);
            length = i_length;
         else;
            length = %len(i_string);
         endif;

         start = 1;

         leftString = %subst(i_string: start: length);

         return   leftString;

      /END-FREE
      *
     P f_left...
     P                 E
      *
      *=========================================================================
      *  Returns the sub string that starts at a given position.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to return the left portion of.
      *   i_start       - Start position of the sub string.
      *   i_length      - The length of the sub string to return.
      *
      *  Returns:
      *   string        - The sub string.
      *=========================================================================
     P f_mid...
     P                 B                   export
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D                                             options(*varsize)
     D  i_start                      10I 0 const
     D  i_length                     10I 0 const   options(*nopass: *omit)
      *
      *  Definieren Funktionswert
     D rtnString       S           4096A   varying  inz
      *
      *  Parameterpositionen
     D p_length        c                   3
      *
      *  Definieren Arbeitsfelder
     D maxLength       s             10i 0 inz
     D length          s                   like(i_length) inz
     D msgText         s            256A   varying inz
     D msg             ds                  likeds(msg_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%parms() >= p_length and %addr(i_length) <> *NULL);
            length = i_length;
         else;
            length = *HIVAL;
         endif;

         if (i_start > %len(i_string) + 1 or i_start < 1);
            msgText = 'Start position is out of range: ' + %char(i_start);
            f_sndPgmMsg(f_newMsg(
                  'CPF9898': msgText: cMsg_Escape: 'QCPFMSG'): cMsg_Prv);
         endif;

         if (i_start + length - 1 > %len(i_string));
            length = %len(i_string) - i_start + 1;
         endif;

         if (length < 0);
            msgText = 'Length is out of range: ' + %char(i_length);
            f_sndPgmMsg(f_newMsg(
                  'CPF9898': msgText: cMsg_Escape: 'QCPFMSG'): cMsg_Prv);
         endif;

         if (length = 0);
            return '';
         endif;

         rtnString = %subst(i_string: i_start: length);

         return rtnString;

      /end-free
     P                 E
      *
      *=========================================================================
      *  Tests if the specified string starts with the specified prefix.
      *=========================================================================
      *  Parameters:
      *   i_prefix      - The prefix.
      *   i_string      - The string that is tested.
      *
      *  Returns:
      *   startsWith    - Returns TRUE if the string starts with the prefix,
      *                   else FALSE.
      *=========================================================================
      *
     P f_startsWith...
     P                 B                   export
      *
     D f_startsWith...
     D                 PI              N
     D  i_prefix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D startsWith      S               N   inz(cFalse)
      *
      *  Local fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_string) = 0  or
             %len(i_prefix) = 0  or
             %len(i_string) < %len(i_prefix));
            return cFalse;
         endif;

         if (%subst(i_string: 1: %len(i_prefix)) <> i_prefix);
            return cFalse;
         endif;

         return cTrue;

      /END-FREE
      *
     P f_startsWith...
     P                 E
      *
      *=========================================================================
      *  Tests if the specified string starts with the specified prefix,
      *  ignoring case considerations.
      *=========================================================================
      *  Parameters:
      *   i_prefix      - The prefix.
      *   i_string      - The string that is tested.
      *
      *  Returns:
      *   startsWith    - Returns TRUE if the string starts with the prefix,
      *                   else FALSE.
      *=========================================================================
      *
     P f_startsWithIgnoreCase...
     P                 B                   export
      *
     D f_startsWithIgnoreCase...
     D                 PI              N
     D  i_prefix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D startsWith      S               N   inz(cFalse)
      *
      *  Local fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_string) = 0  or
             %len(i_prefix) = 0  or
             %len(i_string) < %len(i_prefix));
            return cFalse;
         endif;

         if (f_lcase(%subst(i_string: 1: %len(i_prefix))) <> f_lcase(i_prefix));
            return cFalse;
         endif;

         return cTrue;

      /END-FREE
      *
     P f_startsWithIgnoreCase...
     P                 E
      *
      *=========================================================================
      *  Returns the right portion of a string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to return the right portion of.
      *   i_length      - The length of the right portion to return.
      *
      *  Returns:
      *   string        - The right portion if the string.
      *=========================================================================
      *
     P f_right...
     P                 B                   export
      *
     D f_right...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_length                     10I 0 const
      *
      *  Return value
     D rightString     S           4096A   varying   inz
      *
      *  Local fields
     D length          S                   like(i_length  )  inz
     D start           S                   like(i_length  )  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   i_length <= %len(i_string);
            length = i_length;
         else;
            length = %len(i_string);
         endif;

         start = %len(i_string) - length + 1;

         rightString = %subst(i_string: start: length);

         return   rightString;

      /END-FREE
      *
     P f_right...
     P                 E
      *
      *=========================================================================
      *  Tests if the specified string ends with the specified suffix.
      *=========================================================================
      *  Parameters:
      *   i_suffix      - The suffix.
      *   i_string      - The string that is tested.
      *
      *  Returns:
      *   endsWith      - Returns TRUE if the string ends with the suffix,
      *                   else FALSE.
      *=========================================================================
      *
     P f_endsWith...
     P                 B                   export
      *
     D f_endsWith...
     D                 PI              N
     D  i_suffix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D endsWith        S               N   inz(cFalse)
      *
      *  Local fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if %len(i_string) = 0  or
            %len(i_suffix) = 0  or
            %len(i_string) < %len(i_suffix);
            return endsWith;
         endif;

         if %subst(i_string
                   : %len(i_string) - %len(i_suffix) + 1) = i_suffix;
            endsWith = cTrue;
         endif;

         return   endsWith;

      /END-FREE
      *
     P f_endsWith...
     P                 E
      *
      *=========================================================================
      *  Produces an empty string.
      *=========================================================================
      *  Parameters:
      *   i_length      - The length of the string to produce.
      *   i_char        - The fill char of the string.
      *                   Default:        *BLANKS
      *
      *  Returns:
      *   string        - The new string initialized with i_char.
      *=========================================================================
      *
     P f_space...
     P                 B                   export
      *
     D f_space...
     D                 PI          4096A           varying
     D  i_length                     10I 0 const
     D  i_char                        1A   const   options(*nopass)
      *
      *  Return value
     D spaceString     S           4096A   varying   inz
      *
      *  Parameter positions
     D p_char          C                   const(2)
      *
      *  Local fields
     D tmpStr          S           4096A                     inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_length >= 0:
                  'i_length is out of range. It must be less than ' +
                  %editc(%size(tmpStr): 'N'));

         if i_length = 0;
            spaceString = '';
         else;
            if   %parms >= p_char;
               memset(%addr(tmpStr): f_ebcdic(i_char): i_length);
            else;
               memset(%addr(tmpStr): f_ebcdic(' ')   : i_length);
            endif;

            spaceString = %subst(tmpStr: 1: i_length);
         endif;

         return   spaceString;

      /END-FREE
      *
     P f_space...
     P                 E
      *
      *=========================================================================
      *  Converts a given string to lower case.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to convert to lower case.
      *
      *  Returns:
      *   string        - The string converted to lower case.
      *=========================================================================
      *
     P f_lcase...
     P                 B                   export
      *
     D f_lcase...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D string          S           4096A   varying   inz
      *
      *  Fields for QlgConvertCase API
     D stringBuf       S           4096A             inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
     D reqCtrlBlk      DS                  qualified
     D  type                         10I 0
     D  CCSID                        10I 0
     D  case                         10I 0
     D  reserved                     10A
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if   i_string <> '';
            reqCtrlBlk.type     = cCVTCASE_TYPE_ccsid;
            reqCtrlBlk.CCSID    = cCVTCASE_CCSID_Job;
            reqCtrlBlk.case     = cCVTCASE_toLower;
            reqCtrlBlk.reserved = *ALLx'00';
            errCode = f_newApiErrCode(cFalse);
            QlgConvertCase(reqCtrlBlk:
                           i_string: stringBuf: %len(i_string): errCode);
            string = %subst(stringBuf: 1: %len(i_string));
         else;
            string = i_string;
         endif;

         return   string;

      /END-FREE
      *
     P f_lcase...
     P                 E
      *
      *=========================================================================
      *  Converts a given string to upper case.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to convert to upper case.
      *
      *  Returns:
      *   string        - The string converted to upper case.
      *=========================================================================
      *
     P f_ucase...
     P                 B                   export
      *
     D f_ucase...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D string          S           4096A   varying   inz
      *
      *  Fields for QlgConvertCase API
     D stringBuf       S           4096A             inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
     D reqCtrlBlk      DS                  qualified
     D  type                         10I 0
     D  CCSID                        10I 0
     D  case                         10I 0
     D  reserved                     10A
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if   i_string <> '';
            reqCtrlBlk.type     = cCVTCASE_TYPE_ccsid;
            reqCtrlBlk.CCSID    = cCVTCASE_CCSID_Job;
            reqCtrlBlk.case     = cCVTCASE_toUpper;
            reqCtrlBlk.reserved = *ALLx'00';
            errCode = f_newApiErrCode(cFalse);
            QlgConvertCase(reqCtrlBlk:
                           i_string: stringBuf: %len(i_string): errCode);
            string = %subst(stringBuf: 1: %len(i_string));
         else;
            string = i_string;
         endif;

         return   string;

      /END-FREE
      *
     P f_ucase...
     P                 E
      *
      *=========================================================================
      *  Replaces all occurences of a search argument by
      *  a replacement string in a given string.
      *=========================================================================
      *  Parameters:
      *   i_searchArg   - The argument that is replaced by the replacement
      *                   string.
      *   i_rplString   - The replacement string that replaces the search
      *                   argument.
      *   i_string      - The string that contains the search argument.
      *   i_startPos    - The position where to start from.
      *
      *  Returns:
      *   string        - The string having the search argument replaced with
      *                   the replacement string.
      *=========================================================================
      *
     P f_replace...
     P                 B                   export
      *
     D f_replace...
     D                 PI          4096A          varying
     D  i_searchArg                4096A   const  varying
     D  i_rplString                4096A   const  varying
     D  i_string                   4096A   const  varying
     D  i_startPos                   10U 0 const  options(*nopass)
      *
      *  Return value
     D string          S           4096A   varying   inz
      *
      *  Parameter positions
     D p_startPos      C                   const(4)
      *
      *  Standardwerte fr nicht bergebene Parameter
     D startPos        S                   like(i_startPos) inz
      *
      *  Local fields
     D X               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   %parms >= p_startPos;
            startPos = i_startPos;
         else;
            startPos = 1;
         endif;

         string = i_string;

         x = %scan(i_searchArg: string: startPos);
         dow   x > 0;
            string = %replace(i_rplString: string: x: %len(i_searchArg));
            x = x + %len(i_rplString);
            if   x <= %len(string);
               x = %scan(i_searchArg: string: x);
            else;
               leave;
            endif;
         enddo;

         return   string;

      /END-FREE
      *
     P f_replace...
     P                 E
      *
      *=========================================================================
      *  Returns the EBCDIC value of a given character.
      *=========================================================================
      *  Parameters:
      *   i_char        - The fill char to return the EBCDIC value of.
      *
      *  Returns:
      *   ebcdic        - The EBCDIC value of i_char.
      *=========================================================================
      *
     P f_ebcdic...
     P                 B                   export
      *
     D f_ebcdic...
     D                 PI             3U 0
     D  i_char                        1A   const   options(*nopass)
      *
      *  Return value
     D ebcdic          DS                  qualified
     D  char                   1      1A
     D  integer                1      1U 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ebcdic.char = i_char;

         return   ebcdic.integer;

      /END-FREE
      *
     P f_ebcdic...
     P                 E
      *
      *=========================================================================
      *  Returns the numeric value of a string.
      *=========================================================================
      *  Parameters:
      *   i_string      - A string representing a numeric value.
      *   i_decPoint    - The decimal point symbol.
      *   i_comma       - The comma symbol.
      *   i_curSym      - The currency symbol.
      *
      *  Returns:
      *   value         - The numeric value of i_string.
      *=========================================================================
      *
     P f_val...
     P                 B                   export
      *
     D f_val...
     D                 PI             8F
     D  i_string                     64A   const  varying
     D  i_decPoint                    1A   const  options(*nopass)
     D  i_comma                       1A   const  options(*nopass)
     D  i_curSym                      1A   const  options(*nopass)
      *
      *  Return value
     D value           S              8F   inz
      *
      *  Parameter positions
     D p_decPoint      C                   const(2)
     D p_comma         C                   const(3)
     D p_curSym        C                   const(4)
      *
      *  Optional parameter fields
     D mask            DS                  qualified
     d  curSym                        1A   inz
     D  comma                         1A   inz
     D  decPoint                      1A   inz
      *
      *  Helper fields to determine the decimal point and comma
     D refVal          C                   const(1000,5)
     D refStr          S              7A   inz      static
     D dft_comma       S              1A   inz      static
     D dft_decPoint    S              1A   inz      static
     D dft_curSym      S              1A   inz      static
      *
      *  Helper fields:
      *  Result data structure
     D                 ds
     D result                        30s 9 inz(0)
     D resultAsString                30a   overlay(result)
      *
      *  The parts of the result
     D digits          s             30a   varying inz('')
     D fraction        s             30a   varying inz('')
     D isFraction      S               N   inz(cFalse)
      *
      *  Helper fields
     D is1NumDigit     S               N   inz(cFalse)
     D stringLen       S             10I 0 inz
     D x               S             10I 0 inz
     D c1              S              1A   inz
     D c2              S              2A   inz
     D sign            S              1A   inz
     D digit1Pos       S             10I 0 inz
     D fract1Pos       S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Determine comma and decimal point
         if   refStr = '';
            refStr = %editc(refVal: '1');
            dft_comma    = %subst(refStr: 2: 1) ;
            dft_decPoint = %subst(refStr: 6: 1) ;
            dft_curSym   = '$';
         endif;

         // Process optional parameter values ...
         // ... decimal point
         if  %parms >= p_decPoint;
            mask.decPoint = i_decPoint;
         else;
            mask.decPoint = dft_decPoint;
         endif;

         // ... comma
         if  %parms >= p_comma;
            mask.comma = i_comma;
         else;
            mask.comma = dft_comma;
         endif;

         // ... currency symbol
         if  %parms >= p_curSym;
            mask.curSym = i_curSym;
         else;
            mask.curSym = dft_curSym;
         endif;


         // Initialize
         is1NumDigit = cFalse;
         isFraction  = cFalse;
         digits      = '';
         fraction    = '';
         stringLen   = %len(%trimr(i_string));

         // Spin through input data
         for x = 1 to stringLen;

            // get character of current position
            c1 = %subst(i_string: x: 1);

            // get possible CR sign
            if   x < stringLen;
               c2 = %subst(i_string: x: 2);
               c2 = %xlate('cr':'CR': c2);
            else;
               c2 = '';
            endif;

            select;
            // Ignore BLANKS and currency symbol
            when   (c1 = '') or (c1 = mask.curSym);
               // if we did not yet got a numeric character
               if   not is1NumDigit;
                  // ... then ignore BLANKS and currency symbol
                  iter;
               else;
                  // ... else cancel processing
                  leave;
               endif;

            // Ignore decimal point
            when   (c1 = mask.decPoint);
               is1NumDigit = cTrue;
               iter;

            // Switch do decimal positions
            when   (c1 = mask.comma);
               // If we did not yet got decimal positions, ...
               if   not isFraction;
                  // ... then switch to decimal positions
                  isFraction  = cTrue;
                  is1NumDigit = cTrue;
                  iter;
               else;
                  // cancel processing
                  leave;
               endif;

            // Remember sign '+'/'-', leading or trailing
            when   (c1 = '+')  or (c1 = '-');
               // if we did not yet hit the sign
               if   sign = '';
                  // ... then remember the sign
                  sign        = c1;
                  is1NumDigit = cTrue;
                  iter;
               else;
                  // ... else cancel processing
                  leave;
               endif;

            // Remember sign 'CR', always trailing
            when   c2 = 'CR';
               // if we did not yet hit the sign and if
               // we already got a numeric digit
               if   (sign = '') and is1NumDigit;
                  // ... then remember the sign
                  sign      = '-';
                  x         = x + 1;
                  iter;
               else;
                  // ... else cancel processing
                  leave;
               endif;

            // Process digits
            when   (c1 >= '0') and (c1 <= '9');
               // If we did switched to decimal positions, ...
               if   isFraction;
                  // ... then add digit to decimal portion
                  fraction = fraction + c1;
               else;
                  // ... else add digit to integer portion
                  if   (digits = ' ') and (c1 = '0');
                     // ignore '0'
                  else;
                     digits = digits + c1;
                  endif;
               endif;

               is1NumDigit = cTrue;
               iter;

            // invalid characters
            other;
               // cancel processing
               leave;
            endsl;

         endfor;

         // Strip trailling *BLANKS and '0' of decimal portion
         %len(fraction) = %checkr('0 ': fraction);

         // Make sure that the fraction does not exceed the limit
         p_assert(%decpos(result) >= %len(fraction):
                  'Numeric value contains too many fraction digits');

         // Make sure that we did not get to many digits
         p_assert((%len(result) - %decpos(result)) >= %len(digits):
                  'Number of significant digits allowed exceeded');

         // Put the result together
         fract1Pos = %len(result) - %decpos(result) + 1;
         digit1Pos = fract1Pos - %len(digits);

         %subst(resultAsString: digit1Pos: %len(digits  )) = digits;
         %subst(resultAsString: fract1Pos: %len(fraction)) = fraction;

         // Finally set the sign accordingly
         if   sign = '-';
            value = result * -1;
         else;
            value = result;
         endif;

         return   value;

      /END-FREE
      *
     P f_val...
     P                 E
      *
      *=========================================================================
      *  Performs word wrapping on a given string.
      *  Returns the next line of i_string with each call to f_wordWrap().
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to be word wrapped.
      *   i_width       - Line length.
      *   io_startPos   - The position to start from.
      *                   (Should not be changed between calls.)
      *   i_option      - Options to set.
      *                   Default:        cWORDWRAP_PARAGRAPH_NONE +
      *                                   cWORDWRAP_PARAGRAPH_TRIMR
      *                   cWORDWRAP_PARAGRAPH_NONE   Do not respect
      *                                              end-of-paragraph markers.
      *                   cWORDWRAP_PARAGRAPH_MSGD   Respect end-of-paragraph
      *                                              markers of message descriptions:
      *                                              &N, &B and &P.
      *                   cWORDWRAP_PARAGRAPH_TEXT   Respect standard text
      *                                              end-of-paragraph markers: \n
      *                   cWORDWRAP_PARAGRAPH_TRIMR  Remove trailing blanks from
      *                                              result string.
      *
      *  Returns:
      *   text          - The next line of i_string.
      *=========================================================================
      *
     P f_wordWrap...
     P                 B                   export
      *
     D f_wordWrap...
     D                 PI          4096A          varying
     D  i_string                   4096A   const  varying
     D  i_width                      10U 0 const
     D  io_startPos                  10U 0
     D  i_options                    10U 0 const  options(*nopass)
      *
      *  Return value
     D text            S           4096A   inz    varying
      *
      *  Parameter positions
     D p_options       C                   const(4)
      *
      *  Optional parameter fields
     D options         S                   like(i_options) inz
      *
      *  Local fields
     D theEOP          DS                  qualified
     D  isFound                        N   inz(cFalse)
     D  position                     10I 0
     D  string                        2A   varying
     D x               S             10I 0                     inz
     D tmpEOP          S              2A   varying             inz
     D numEOP          S             10I 0                     inz
     D EOP             S                   like(tmpEOP) dim(3) inz
     D ESC             S              1A
     D startPos        S                   like(io_startPos  ) inz
     D string          S                   like(i_string     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_width >= 1:
                  'i_width is out of range. It must be greater than 0');

         p_assert(io_startPos >= 1 and io_startPos <= %len(i_string):
                  'io_startPos is out of range. It must be greater than 0 -
                   and less than the length of i_string');

         // Process optional parameter values ...
         // ... options
         if %parms >= p_options;
            options = i_options;
         else;
            options = cWORDWRAP_PARAGRAPH_NONE +
                      cWORDWRAP_PARAGRAPH_TRIMR;
         endif;

         // TRIM trailing blanks
         string = %trimR(i_string);

         // Determine how to treat end-of-paragraph markers:
         select;
         // ... do not respect end-of-paragraph marker
         when f_isBitOn(cWORDWRAP_PARAGRAPH_NONE: options);
            clear EOP;
            clear ESC;
            numEOP = 0;
         // ... respect end-of-paragraph marker of message descriptions: &N, &P, &B
         when f_isBitOn(cWORDWRAP_PARAGRAPH_MSGD: options);
            clear EOP;
            EOP(1) = '&N';
            EOP(2) = '&P';
            EOP(3) = '&B';
            ESC    = '&';
            numEOP = 3;
         // ... respect end-of-paragraph marker of text: \n
         when f_isBitOn(cWORDWRAP_PARAGRAPH_TEXT: options);
            clear EOP;
            EOP(1) = '\N';
            ESC    = '\';
            numEOP = 1;
         endsl;

         // ---------------------------------------------------
         //  Perform word-wrap with no respect to
         //  end-of-paragraph markers.
         // ---------------------------------------------------
         if numEOP = 0;
            text = lf_wordWrap(string: i_width: io_startPos);
         else;
         // ---------------------------------------------------
         //  Perform word-wrap with respect to
         //  end-of-paragraph markers.
         // ---------------------------------------------------

            // Find next end-of-paragraph marker
            reset theEOP;
            theEOP.isFound = cFalse;
            theEOP.position = %scan(ESC: string: io_startPos);
            dow not theEOP.isFound and theEOP.position > 0;
               // If there is an escape character, ...
               if %subst(string: theEOP.position: 1) = ESC;
                  // ... then check it against the list of EOP marker
                  for x = 1 to numEOP;
                     // If there is enough space for a EOP after the escape character
                     // and if it is a known EOP, ...
                     if theEOP.position <= %len(string) - %len(EOP(x)) + 1;
                        tmpEOP = %subst(string: theEOP.position: %len(EOP(x)));
                        if f_ucase(tmpEOP) = f_ucase(EOP(x));
                           // ... then set flag "EOP found"
                           theEOP.string  = EOP(x);
                           theEOP.isFound = cTrue;
                           leave;
                        endif;
                     endif;
                  endfor;
               endif;

               if (not theEOP.isFound);
                  if (theEOP.position < %len(string));
                     theEOP.position = %scan(ESC: string: theEOP.position + 1);
                  else;
                     theEOP.position = 0;
                  endif;
               endif;
            enddo;

            // If no end-of-paragraph marker is found, ...
            if not theEOP.isFound;
               // ... then perform standard word wrap with no respect to EOP
               text = lf_wordWrap(string: i_width: io_startPos);
            else;
               // ... else perform word wrap for text portion
               //     before end-of-paragraph marker
               if (theEOP.position - io_startPos) > 0;
                  string   = %subst(string: io_startPos:
                                    theEOP.position - io_startPos);
                  startPos = 1;
                  text = lf_wordWrap(string: i_width: startPos);
               else;
                  text = '';
               endif;

               // If all we got is a EOP, ...
               if (%len(text)    = %len(theEOP.string)   ) and
                  (f_ucase(text) = f_ucase(theEOP.string));
                  // ... then delete it
                  text = '';
               endif;
               // Set new start position. Skip EOP if EOP
               // caused new line.
               io_startPos = io_startPos + %len(text);
               if theEOP.position = io_startPos;
                  io_startPos = io_startPos + %len(theEOP.string);
               endif;
               // Set start position to 0 if new start position
               // exceeds maximum length of text.
               if io_startPos > %len(i_string);
                  io_startPos = 0;
               endif;
            endif;

         endif;

         // If the user requested to remove BLANKS, ...
         if f_isBitOn(cWORDWRAP_PARAGRAPH_TRIMR: options);
            // ... then remove BLANKS.
            text = %trimR(text);
         endif;

         return   text;

      /END-FREE
      *
     P f_wordWrap...
     P                 E
      *
      *=========================================================================
      *  Performs word wrapping on a given string without respect to
      *  end-of-paragraph markers.
      *=========================================================================
      *
     P lf_wordWrap...
     P                 B
      *
     D lf_wordWrap...
     D                 PI          4096A          varying
     D  i_string                   4096A   const  varying
     D  i_width                      10U 0 const
     D  io_startPos                  10U 0
      *
      *  Return value
     D text            S           4096A   inz    varying
      *
      *  Local fields
     D sPos            S             10I 0 inz
     D ePos            S             10I 0 inz
     D ePosConst       S             10I 0 inz
     D length          S             10I 0 inz
     D char            S              1A   inz
     D x               S             10I 0 inz
      *
      *  Valid separater characters
     D cDELIMITER      C                   const(' -/\.:')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialise helper fields
         text   = '';
         sPos   = io_startPos;
         ePos   = 0;
         length = 0;

         // Set range
         ePos      = sPos + i_width;
         ePosConst = ePos;

         // If the end position is out of range ...
         if   ePos > %len(i_string);
         // ... then
         //     assume the last character to be the delimiter
            ePos = %len(i_string);
         else;
         // ... else
         //     look backwards for a deliniter.
            dow   ePos >= sPos;
               char = %subst(i_string: ePos: 1);
               // At position width + 1 ...
               if   ePos = ePosConst;
               // ... only BLANKS are allowed
                  x = %check(' ': char);
               else;
               // ... else every delimiter is allowed
                  x = %check(cDELIMITER: char);
               endif;
               // If there is a delimiter, ...
               if   x = 0;
               // ... then stop searching
                  leave;
               endif;

               ePos = ePos - 1;
            enddo;
         endif;

         // If there is no delimiter, ...
         if   ePos < sPos;
         // ... then assume the last character to be the delimiter.
            ePos = sPos + i_width - 1;
         endif;

         // Retrieve text (incl. delimiter) ...
         length = ePos - sPos + 1;
         text = %subst(i_string: sPos: length);

         // ... and set new start position.
         sPos = sPos + length;
         if sPos <= %len(i_string);
            io_startPos = %check(' ': i_string: sPos);
         else;
            io_startPos = 0;
         endif;

         return   text;

      /END-FREE
      *
     P lf_wordWrap...
     P                 E
      *
      *=========================================================================
      *  Transforms a numeric from its internal format to a
      *  character form suitable for displaying.
      *=========================================================================
      *  Parameters:
      *   i_pBuffer     - Address of the internal form of the numeric value.
      *   i_digits      - Number of digits of the numeric value.
      *   i_decPos      - Number of decimal positions of the numeric value.
      *   i_varType     - Type of the numeric value.
      *   i_editCode    - Edit code used for translating the numeric value
      *                   to a character string.
      *
      *  Returns:
      *   fmtString     - Formatted string.
      *=========================================================================
      *
     P f_editCode...
     P                 B                   export
      *
     D f_editCode...
     D                 PI            64A          varying
     D  i_pBuffer                      *   const
     D  i_digits                     10I 0 const
     D  i_decPos                     10I 0 const
     D  i_varType                    10A   const
     D  i_editCode                    2A   const
      *
      *  Return value
     D fmtString       S             64A   varying  inz
      *
      *  Local fields
     D editCode        S                   like(i_editCode)   inz
     D isEditCode_X    S               N   inz(cFalse)
     D buffer          S             64A   based(i_pBuffer)
     D editMask        S            256A   inz
     D editMaskLen     S             10I 0 inz
     D rcvVar          S             64A   inz
     D rcvVarLen       S             10I 0 inz
     D zeroBalanceFillChar...
     D                 S              1A   inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------
      /FREE

         editCode = i_editCode;

         // Check whether edit code 'X' was specified or not.
         if %subst(editCode: 1: 1) = 'X';
            isEditCode_X = cTrue;
            %subst(editCode: 1: 1) = 'Z';
         else;
            isEditCode_X = cFalse;
         endif;

         // Produce edit mask for the given edit code
         errCode = f_newApiErrCode(cFalse);

         QECCVTEC(editMask               :
                  editMaskLen            :
                  rcvVarLen              :
                  zeroBalanceFillChar    :
                  %subst(editCode: 1: 1) :
                  %subst(editCode: 2: 1) :
                  i_digits               :
                  i_decPos               :
                  errCode                );

         // Translate the numeric value to a character string
         QECEDT(rcvVar                                      :
                rcvVarLen                                   :
                buffer                                      :
                lf_cvtRpgVarTypeToEdtAPIVarClass(i_varType) :
                i_digits                                    :
                editMask                                    :
                editMaskLen                                 :
                zeroBalanceFillChar                         :
                errCode                                     );

         // Set return value
         fmtString = %subst(rcvVar: 1: rcvVarLen);

         // Replace blanks with '0' if edit code 'X' was requested
         if isEditCode_X;
            fmtString = %xlate(' ': '0': fmtString);
         endif;

         return fmtString;

      /END-FREE
      *
     P f_editCode...
     P                 E
      *
      *=========================================================================
      *  Transforms a numeric from its internal format to a
      *  character form suitable for displaying.
      *=========================================================================
      *  Parameters:
      *   i_pBuffer     - Address of the internal form of the numeric value.
      *   i_digits      - Number of digits of the numeric value.
      *   i_varType     - Type of the numeric value.
      *   i_editWord    - Edit word used for translating the numeric value
      *                   to a character string.
      *
      *  Returns:
      *   fmtString     - Formatted string.
      *=========================================================================
      *
     P f_editWord...
     P                 B                   export
      *
     D f_editWord...
     D                 PI           512A          varying
     D  i_pBuffer                      *   const
     D  i_digits                     10I 0 const
     D  i_varType                    10A   const
     D  i_editWord                  256A   const  varying
      *
      *  Return value
     D fmtString       S            512A   varying  inz
      *
      *  Local fields
     D buffer          S             64A   based(i_pBuffer)
     D editMask        S            256A   inz
     D editMaskLen     S             10I 0 inz
     D rcvVar          S            512A   inz
     D rcvVarLen       S             10I 0 inz
     D zeroBalanceFillChar...
     D                 S              1A   inz
     D errCode         DS                  likeds(errCode_t ) inz
      *-------------------------------------------------------------------
      /FREE

         errCode = f_newApiErrCode(cFalse);

         // Produce edit mask for the given edit mask
         QECCVTEW(editMask         :
                  editMaskLen      :
                  rcvVarLen        :
                  i_editWord       :
                  %len(i_editWord) :
                  errCode          );

         // Translate the numeric value to a character string
         QECEDT(rcvVar                                      :
                rcvVarLen                                   :
                buffer                                      :
                lf_cvtRpgVarTypeToEdtAPIVarClass(i_varType) :
                i_digits                                    :
                editMask                                    :
                editMaskLen                                 :
                X'00'                                       :
                errCode                                     );

         // Set return value
         fmtString = %subst(rcvVar: 1: rcvVarLen);

         return fmtString;

      /END-FREE
      *
     P f_editWord...
     P                 E
      *
      *=========================================================================
      *  Gets the length of a the formatted string of a given edit code.
      *=========================================================================
      *  Parameters:
      *   i_digits      - Number of digits of the numeric value.
      *   i_decPos      - Number of decimal positions of the numeric value.
      *   i_editCode    - Edit code used for translating the numeric value
      *                   to a character string.
      *
      *  Returns:
      *   length        - Length of the formatted string.
      *=========================================================================
      *
     P f_getLengthEditCode...
     P                 B                   export
      *
     D f_getLengthEditCode...
     D                 PI             5U 0
     D  i_digits                     10I 0 const
     D  i_decPos                     10I 0 const
     D  i_editCode                    2A   const
      *
      *  Return value
     D length          S              5U 0 inz
      *
      *  Local fields
     D buffZoned       S            128A   inz(*ALLx'F0')
     D fmtString       S             64A   inz    varying
      *-------------------------------------------------------------------
      /FREE

         fmtString = f_editCode(%addr(buffZoned):
                                i_digits: i_decpos: 'S': i_editCode);

         length = %len(fmtString);

         return length;

      /END-FREE
      *
     P f_getLengthEditCode...
     P                 E
      *
      *=========================================================================
      *  Gets the length of a the formatted string of a given edit word.
      *=========================================================================
      *  Parameters:
      *   i_digits      - Number of digits of the numeric value.
      *   i_editWord    - Edit word used for translating the numeric value
      *                   to a character string.
      *
      *  Returns:
      *   length        - Length of the formatted string.
      *=========================================================================
      *
     P f_getLengthEditWord...
     P                 B                   export
      *
     D f_getLengthEditWord...
     D                 PI             5U 0
     D  i_digits                     10I 0 const
     D  i_editWord                  256A   const  varying
      *
      *  Return value
     D length          S              5U 0 inz
      *
      *  Local fields
     D buffZoned       S            128A   inz(*ALLx'F0')
     D fmtString       S            512A   inz    varying
      *-------------------------------------------------------------------
      /FREE

         fmtString = f_editWord(%addr(buffZoned): i_digits: 'S': i_editWord);

         length = %len(fmtString);

         return length;

      /END-FREE
      *
     P f_getLengthEditWord...
     P                 E
      *
      *=========================================================================
      *  Removes a keyword from a given string.
      *=========================================================================
      *  Parameters:
      *   i_keyword     - The keyword to remove from the string.
      *   i_string      - The given string.
      *
      *  Returns:
      *   string        - The string without the keyword.
      *
      *  Comment:
      *   i_string must start with the keyword with no leading spaces.
      *   Otherwise the keyword is not removed from i_string.
      *=========================================================================
      *
     P f_rmvKeyword...
     P                 B                   export
      *
     D f_rmvKeyword...
     D                 PI          4096A           varying
     D  i_keyword                   128A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Return value
     D string          S           4096A   varying  inz
      *
      *  Local fields
      *-------------------------------------------------------------------
      /FREE

         // If the keyword is there ...
         if f_left(i_string: %len(i_keyword)) = i_keyword;

            // If the string is longer than the keyword ...
            if %len(i_string) > %len(i_keyword) + %len(cOPEN_PARENTHESIS )
 B02                                            + %len(cCLOSE_PARENTHESIS);

               // ... strip the keyword from the string
               string = %subst(i_string: %len(i_keyword) + 1);

               // remove opening parenthesis
               if f_left(string: 1) = cOPEN_PARENTHESIS;
                  string = %subst(string: %len(cOPEN_PARENTHESIS) + 1);
               endif;

               // remove closing parenthesis
               if f_right(string: 1) = cCLOSE_PARENTHESIS;
                  string = f_left(string: %len(string) -
                                          %len(cCLOSE_PARENTHESIS));
               endif;
            else;

               // ... clear the string
               string = '';
            endif;

         else;
            // ... return the string unchanged
            string = i_string;
         endif;

         return string;

      /END-FREE
      *
     P f_rmvKeyword...
     P                 E
      *
      *=========================================================================
      *  Removes quotes from a given string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The given string.
      *   i_quote       - The quote to be removed from the string.
      *
      *  Returns:
      *   string        - The string without quotes.
      *=========================================================================
      *
     P f_rmvQuotes...
     P                 B                   export
      *
     D f_rmvQuotes...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_quote                       1A   const
      *
      *  Return value
     D string          S           4096A   varying  inz
      *
      *  Local fields
      *-------------------------------------------------------------------
      /FREE

         string = i_string;

         if %len(string) >= 2;

            // If it is a quoted string ...
            if (f_left(string:  1) = i_quote) and
               (f_right(string: 1) = i_quote);

               if %len(string) = 2;
                  string = '';
               else;
                  // ... remove leading quote
                  string = %subst(string: 2);

                  // ... remove trailing quote
                  string = f_left(string: %len(string) - 1);

                  // ... turn 2 immediately following quotes into a quote
                  string = f_replace(i_quote + i_quote: i_quote: string);
               endif;

            endif;

         endif;

         return string;

      /END-FREE
      *
     P f_rmvQuotes...
     P                 E
      *
      *=========================================================================
      *  Adds quotes to a given string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The given string.
      *   i_quote       - The quote to be added to the string.
      *
      *  Returns:
      *   string        - The string with quotes.
      *=========================================================================
      *
     P f_addQuotes...
     P                 B                   export
      *
     D f_addQuotes...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_quote                       1A   const   options(*nopass)
      *
      *  Return value
     D string          S           4096A   varying  inz
      *
      *  Parameter positions
     D p_quote         C                   const(2)
      *
      *  Optional parameter fields
     D quote           S                   like(i_quote) inz
      *
      *  Local fields
      *-------------------------------------------------------------------
      /FREE

         if (%parms() >= p_quote);
            quote = i_quote;
         else;
            quote = cSINGLE_QUOTE;
         endif;

         string = i_string;

         // double single quotes
         string = f_replace(quote: quote + quote: string);

         // add leading quote
         string = quote + string;

         // add trailing quote
         string = string + quote;

         return string;

      /END-FREE
      *
     P f_addQuotes...
     P                 E
      *
      *=========================================================================
    R *  *** PRIVATE ***
      *  Converts a RPG variable type to a variable class of the edit APIs.
      *=========================================================================
      *
     P lf_cvtRpgVarTypeToEdtAPIVarClass...
     P                 B
      *
     D lf_cvtRpgVarTypeToEdtAPIVarClass...
     D                 PI            10A
     D  i_varType                     1A   const
      *
      *  Return value
     D varClass        S             10A   inz
      *
      *  Local constants
     D cZONED          C                   const('*ZONED')
     D cPACKED         C                   const('*PACKED')
     D cBINARY         C                   const('*BINARY')
     D cINTEGER        C                   const('*BINARY')
      *-------------------------------------------------------------------
      /FREE

         // Convert RPG type ...
         select;
         // ... zoned
         when i_varType = 'S';
            varClass = cZONED;
         // ... packed
         when i_varType = 'P';
            varClass = cPACKED;
         // ... binary
         when i_varType = 'B';
            varClass = cBINARY;
         // ... integer
         when i_varType = 'I';
            varClass = cINTEGER;
         endsl;

         return varClass;

      /END-FREE
      *
     P lf_cvtRpgVarTypeToEdtAPIVarClass...
     P                 E
      *
      *=========================================================================
      *  Centers a string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to be centered.
      *   i_length      - The length of the target field.
      *
      *  Returns:
      *   string        - The centered string.
      *=========================================================================
      *
     P f_center...
     P                 B                   export
      *
     D f_center...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_length                     10U 0 const   options(*nopass)
      *
      *  Return value
     D centeredString  S           4096A   varying   inz
      *
      *  Parameter positions
     D p_length        C                   const(2)
      *
      *  Fields for not passed parameters
     D length          S                   like(i_length  ) inz
      *
      *  Local fields
     D spaces          S             10I 0 inz
     D string          S           4096A   varying   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   %parms >= p_length;
            length = i_length;
         else;
            length = %len(i_string);
         endif;

         string = %trim(i_string);
         spaces = %int((length - %len(string)) / 2);

         if spaces < 0;
            centeredString = f_left(string: length);
         else;
            %len(centeredString) = length;
            centeredString = %replace(string: centeredString:
                                      spaces + 1: %len(string));
         endif;

         return   centeredString;

      /END-FREE
      *
     P f_center...
     P                 E
      *
      *=========================================================================
      *  Right aligns a string.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to be right aligned.
      *   i_length      - The length of the target field.
      *
      *  Returns:
      *   string        - The right aligned string.
      *=========================================================================
      *
     P f_alignR...
     P                 B                   export
      *
     D f_alignR...
     D                 PI          4096A           varying
     D  i_string                   4096A   const   varying
     D  i_length                     10U 0 const   options(*nopass)
      *
      *  Return value
     D alignedString   S           4096A   varying   inz
      *
      *  Parameter positions
     D p_length        C                   const(2)
      *
      *  Fields for not passed parameters
     D length          S                   like(i_length  ) inz
      *
      *  Local fields
     D spaces          S             10I 0 inz
     D string          S           4096A   varying   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   %parms >= p_length;
            length = i_length;
         else;
            length = %len(i_string);
         endif;

         string = %trim(i_string);
         spaces = length - %len(%trim(i_string));

         if spaces < 0;
            alignedString = f_right(%trimR(i_string): length);
         else;
            %len(alignedString) = length;
            alignedString = %replace(string: alignedString:
                                     spaces + 1: %len(string));
         endif;

         return   alignedString;

      /END-FREE
      *
     P f_alignR...
     P                 E
      *
      *=========================================================================
      *  Compare strings using wildcard characters. (Compare generic)
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to be compared with i_mask.
      *   i_pattern     - Mask. Optionally containing wildcard characters.
      *   i_wildcard    - Wildcard characters:
      *                   Position 1-1: Ignore group of characters. Default: *
      *                   Position 2-2: Ignore single character.    Default: ?
      *
      *  Returns:
      *   isEqual       - Returns cTrue when the strings are equal.
      *=========================================================================
     P f_genStrCmp...
     P                 B                   export
     D                 PI              N
     D  i_string                   4096A   const   varying
     D  i_pattern                  4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%len(i_pattern) = 0);
            return cEQUAL_TRUE;
         endif;

         return lf_genStrCmpInternal(i_string: i_pattern: i_wildcard);

      /END-FREE
      *
     P f_genStrCmp...
     P                 E
      *
      *=========================================================================
      *  Compare strings using wildcard characters. (Compare generic)
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to be compared with i_mask.
      *   i_mask        - Mask. Optionally containing wildcard characters.
      *   i_wildcard    - Wildcard characters:
      *                   Position 1-1: Ignore group of characters. Default: *
      *                   Position 2-2: Ignore single character.    Default: ?
      *
      *  Returns:
      *   isEqual       - Returns cTrue when the strings are equal.
      *=========================================================================
     P f_genStrCmpIgnCase...
     P                 B                   export
     D                 PI              N
     D  i_string                   4096A   const   varying
     D  i_mask                     4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      *
      *  Return value
     D isEqual         S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_wildcard      C                   const(3)
      *
      *  Fields for optional parameters
      *
      *  Local fields
     D string          S                   like(i_string) inz
     D mask            S                   like(i_mask  ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Convert everything to lower case
         mask   = f_lcase(i_mask);
         string = f_lcase(i_string);

         // Call generic string compare procedure
         if   %parms >= p_wildcard;
            isEqual = f_genStrCmp(string: mask: i_wildcard);
         else;
            isEqual = f_genStrCmp(string: mask);
         endif;

         return isEqual;

      /END-FREE
     P                 E
      *
      *=========================================================================
      *  Compare strings using wildcard characters. (Compare generic)
      *=========================================================================
     P lf_genStrCmpInternal...
     P                 B
     D                 PI              N
     D  i_string                   4096A   const   varying
     D  i_pattern                  4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      *
      *  Parameter positions
     D p_wildcard      C                   const(3)
      *
      *  Fields for optional parameters
     D wildcard        DS                  qualified
     D  group                         1A   inz
     D  single                        1A   inz
      *
      *  Local fields
     D string          S                   like(i_string)
     D pattern         S                   like(i_pattern)
      *
     D genStrCmp       S              1A   inz
     D strPos          S             10U 0 inz
     D maskPos         S             10U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         // ... decimal point
         if (%parms() >= p_wildcard and %addr(i_wildcard) <> *NULL);
            wildcard = i_wildcard;
         else;
            wildcard.group  = '*';   // Ignore group of characters
            wildcard.single = '?';   // Ignore single character
         endif;

         string = i_string;
         pattern = i_pattern;

         if (%len(pattern) = %len(string) and pattern = string);
            return cEQUAL_TRUE;
         elseif (%len(string) = 0);
            if (%check(wildcard.group: pattern) = 0);
               return cEQUAL_TRUE;
            else;
               return cEQUAL_FALSE;
            endif;
         elseif (%len(pattern) = 0);
            if (%len(string) = 0);
               return cEQUAL_TRUE;
            else;
               return cEQUAL_FALSE;
            endif;
         elseif (pattern = wildcard.group);
            return cEQUAL_TRUE;
         elseif (f_startsWith(wildcard.single: pattern)); // ?
            return lf_genStrCmpInternal(f_mid(string: 2)
                                        : f_mid(pattern: 2)
                                        : wildcard);
         elseif (f_endsWith(wildcard.single: pattern));   // ?
            return lf_genStrCmpInternal(%subst(string: 1: %len(string) - 1)
                                        : %subst(pattern: 1: %len(pattern) - 1)
                                        : wildcard);
         elseif (f_startsWith(wildcard.group: pattern));  // *
            if (lf_genStrCmpInternal(string
                                     : f_mid(pattern: 2)
                                     : wildcard));
               return cEQUAL_TRUE;
            else;
               return lf_genStrCmpInternal(f_mid(string: 2)
                                           : pattern
                                           : wildcard);
            endif;
         elseif (f_endsWith(wildcard.group: pattern));    // *
            if (lf_genStrCmpInternal(string
                                     : %subst(pattern: 1: %len(pattern) - 1)
                                     : wildcard));
               return cEQUAL_TRUE;
            else;
               return lf_genStrCmpInternal(%subst(string: 1: %len(string) - 1)
                                  : pattern
                                  : wildcard);
            endif;
         elseif (%subst(pattern: 1: 1) = %subst(string: 1: 1));
               return lf_genStrCmpInternal(f_mid(string: 2)
                                           : f_mid(pattern: 2)
                                           : wildcard);
         endif;

         return cEQUAL_FALSE;

      /END-FREE
     P                 E
      *
      *=========================================================================
      *  Returns the last position of a search argument in the source string.
      *=========================================================================
      *  Parameters:
      *   i_searchArg   - The search argument that is searched in for.
      *   i_string      - The source string.
      *   i_start       - Start position.
      *
      *  Returns:
      *   position      - Returns the start position of the search argument in
      *                   source string on success, else 0.
      *=========================================================================
      *
     P f_scanR...
     P                 B                   export
      *
     D f_scanR...
     D                 PI             5I 0
     D  i_searchArg                4096A   const   varying
     D  i_string                   4096A   const   varying
     D  i_start                       5I 0 const   options(*nopass)
      *
      *  Return value
     D position        S              5I 0 inz
      *
      *  Parameter positions
     D p_start         C                   const(3)
      *
      *  Fields for optional parameters
     D start           S                   like(i_start ) inz
      *
      *  Local fields
     D x               S                   like(i_start ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   %parms >= p_start;
            start = i_start;
         else;
            start = %len(i_string);
         endif;

         if %len(i_searchArg) > start;
            position = 0;
         else;
            x = start - %len(i_searchArg) + 1;
            dou (position > 0) or (x = 0);
               if %subst(i_string: x: %len(i_searchArg)) = i_searchArg;
                  position = x;
               endif;
               x = x - 1;
            enddo;
         endif;

         return   position;

      /END-FREE
      *
     P f_scanR...
     P                 E
      *
      *=========================================================================
      *  Converts a given buffer to a character string of hex values.
      *=========================================================================
      *  Parameters:
      *   i_pBuffer     - Pointer to a buffer containing bytes.
      *   i_size        - Size of buffer.
      *
      *  Returns:
      *   string        - Returns the character string of hex values
      *                   of i_buffer.
      *
      *  Sample:
      *     When i_pBuffer points to a variable that contains 'Hello World',
      *     then string is set to 'C88593939640E696999384'.
      *=========================================================================
      *
     P f_cvtBufferToHexString...
     P                 B                   export
      *
     D f_cvtBufferToHexString...
     D                 PI          4096A           varying
     D  i_pBuffer                      *   const
     D  i_size                        5U 0 const
      *
      *  Return value (as varying field)
     D                 DS
     D string                      4096    varying
     D  str_length                    5U 0 overlay(string)
     D  str_data                   4096A   overlay(string: *next)
      *
      *  Reference field
     D string_t        S           4096A   varying based(pDummy)
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert((i_size * 2) <= %size(str_data):
                  'Length of i_buffer exceeded maximum length allowed.');

         p_assert(%size(string) = %size(string_t):
                  'Incorrect definition of structure ''string''.');

         cvthc(%addr(str_data): i_pBuffer: i_size * 2);
         str_length = i_size * 2;

         return   string;

      /END-FREE
      *
     P f_cvtBufferToHexString...
     P                 E
      *
      *=========================================================================
      *  Converts a given pointer to a character string of hex values.
      *=========================================================================
      *  Parameters:
      *   i_pointer     - Pointer that is converted to its string representation.
      *
      *  Returns:
      *   string        - Returns the character string of hex values
      *                   of i_pointer.
      *=========================================================================
      *
     P f_cvtPtrToHexString...
     P                 B                   export
      *
     D f_cvtPtrToHexString...
     D                 PI            32A           varying
     D  i_pointer                      *   value
      *
      *  Return value
     D string          S             32A   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string = f_cvtBufferToHexString(%addr(i_pointer): %size(i_pointer));

         return string;

      /END-FREE
      *
     P f_cvtPtrToHexString...
     P                 E
      *
      *=========================================================================
      *  Converts a given character string of hex values to a buffer.
      *=========================================================================
      *  Parameters:
      *   i_string      - Character string of hex values.
      *
      *  Returns:
      *   size          - Returns the size of the bytes sequence
      *                   represented by i_string.
      *
      *  Sample:
      *     When i_string contains 'C88593939640E696999384', then buffer
      *     is set to 'Hello World'.
      *=========================================================================
      *
     P f_cvtHexStringToBuffer...
     P                 B                   export
      *
     D f_cvtHexStringToBuffer...
     D                 PI             5U 0 opdesc
     D  i_string                   4096A   const   options(*varsize)
     D  i_pBuffer                      *   const
     D  i_size                        5U 0 const
      *
      *  Return value
     D size            S              5U 0 inz
      *
      *  Parameter positions
     D p_string        C                   const(1)
      *
      *  Local fields
     D string          S                   like(i_string    ) inz
     D strInf          DS                  likeds(strInf_t  ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         CEEGSI(p_string: strInf.datatype: strInf.curlen: strInf.maxlen: *omit);

         p_assert((strInf.curlen / 2) <= i_size:
                  'Length of i_buffer exceeded maximum length allowed.');

         string = %subst(i_string: 1: strInf.curlen);
         cvtch(i_pBuffer: %addr(string): strInf.curlen);
         size   = strInf.curlen / 2;

         if size < i_size;
            memset(i_pBuffer + size: x'00': i_size - size);
         endif;

         return   size;

      /END-FREE
      *
     P f_cvtHexStringToBuffer...
     P                 E
      *
      *=========================================================================
      *  Tests, if a given string contains an invalid character
      *  at a given position.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to test.
      *   i_pos         - The position that specifies the character
      *                   to be tested.
      *   i_chars       - List of valid characters.
      *
      *  Returns:
      *   isValid       - Returns cTrue, if the character at the specified
      *                   position is valid, else cFalse.
      *=========================================================================
     P f_containsInvalidCharAt...
     P                 B                   export
      *
     D f_containsInvalidCharAt...
     D                 PI              N
     D  i_string                   4096A   const  varying options(*varsize)
     D  i_pos                        10I 0 const
     D  i_chars                     256A   const  varying options(*varsize)
      *
      *  Return value
     D isInvalid       S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_pos <= %len(i_string):
                  'i_pos is out of range. It must be less than or equal to ' +
                  %editc(%len(i_string): 'N'));

         if %check(%subst(i_chars: 1: %len(i_chars))
                   : %subst(i_string: i_pos: 1)) <> 0;
            isInvalid = cTrue;
         else;
            isInvalid = cFalse;
         endif;

         return isInvalid;

      /END-FREE
      *
     P f_containsInvalidCharAt...
     P                 E
      *
      *=========================================================================
      *  Tests, if a given string contains a specific string
      *  at a given position.
      *=========================================================================
      *  Parameters:
      *   i_string      - The string to test.
      *   i_pos         - The position that specifies the start position
      *                   of the embedded sub string.
      *   i_subString   - The sub string.
      *
      *  Returns:
      *   isAvailable   - Returns cTrue, if the sub string is found at the
      *                   specified position, else cFalse.
      *=========================================================================
     P f_containsStringAt...
     P                 B                   export
      *
     D f_containsStringAt...
     D                 PI              N
     D  i_string                   4096A   const  varying options(*varsize)
     D  i_pos                        10I 0 const
     D  i_subString                4096A   const  varying options(*varsize)
      *
      *  Return value
     D isAvailable     S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pos + %len(i_subString)) <= %len(i_string);
            if %subst(i_string: i_pos: %len(i_subString)) =
                  %subst(i_subString: 1: %len(i_subString));
               isAvailable = cTrue;
            else;
               isAvailable = cFalse;
            endif;
         else;
            isAvailable = cFalse;
         endif;

         return isAvailable;

      /END-FREE
      *
     P f_containsStringAt...
     P                 E
      *
      *=========================================================================
      *  Returns the string representation of a qualified object name.
      *=========================================================================
      *  Parameters:
      *   i_qObj        - Qualified object name.
      *   i_lib         - Name of the library that contains the object
      *                   specified at i_qObj. If i_lib is used i_qObj
      *                   behaves like a 10 byte name field that contains
      *                   the name of the object only.
      *
      *  Returns:
      *   strObjName    - The string represenation of the qualified object name.
      *=========================================================================
     P f_objName...
     P                 B                   export
      *
     D f_objName...
     D                 PI            21A          varying
     D  i_qObj                             const  likeds(qObj_t   )
     D  i_lib                        10A   const  options(*nopass)
      *
      *  Return value
     D strObjName      S             21A   varying inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_lib);
            strObjName = %trimR(i_lib) + '/' + %trimR(i_qObj);
         else;
            strObjName = %trimR(i_qObj.lib) + '/' + %trimR(i_qObj.name);
         endif;

         return strObjName;

      /END-FREE
      *
     P f_objName...
     P                 E
      *
      *=========================================================================
      *  Replaces unprintable characters in a given string.
      *=========================================================================
      *  Parameters:
      *   i_string      - String that may contain unprintable characters.
      *   i_rplChar     - Substitution character that replaces the
      *                   unprintable characters.
      *
      *  Returns:
      *   string        - String without any unprintable characters.
      *=========================================================================
     P f_rplUnPrtChars...
     P                 B                   export
      *
     D f_rplUnPrtChars...
     D                 PI          4096A          varying
     D  i_string                   4096A   const  varying
     D  i_rplChar                     1A   const  varying options(*nopass)
      *
      *  Return value
     D string          S           4096A   varying inz
      *
      *  Parameter positions
     D p_rplChar       C                   const(2)
      *
      *  Optional parameter fields
     D rplChar         S                   like(i_rplChar ) inz
      *
      *  Helper fields
     D x               S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_rplChar);
            rplChar = i_rplChar;
         else;
            rplChar = ' ';
         endif;

         string = '';

         for x = 1 to %len(i_string);
            if (%subst(i_string: x: 1) < x'40' or
                %subst(i_string: x: 1) = x'FF');
               if (%len(rplChar) > 0);
                  string = string + rplChar;
               endif;
            else;
               string = string + %subst(i_string: x: 1);
            endif;
         endfor;

         return string;

      /END-FREE
      *
     P f_rplUnPrtChars...
     P                 E
      *
      *=========================================================================
      *  Formats a given date according to a given picture string.
      *=========================================================================
      *  Parameters:
      *   i_date        - Date to be formatted.
      *   i_pic_str     - Picture string representing the desired format.
      *
      *  Returns:
      *   string        - Formatted date string.
      *=========================================================================
     P f_formatDate...
     P                 B                   export
      *
     D f_formatDate...
     D                 PI           128A          varying
     D  i_date                         D   const
     D  i_pic_str                   128A   const  varying
      *
      *  Return value
     D string          S            128A   inz
      *
      *  Local constants
     D cDATE_ISO       C                   'YYYYMMDD'
      *
      *  Helper fields
     D tmpDate         S             10A   inz
     D tmpLilianDate   S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         tmpDate = %char(i_date: *ISO0);
         CEEDAYS(tmpDate: cDATE_ISO: tmpLilianDate: *omit);
         CEEDATE(tmpLilianDate: i_pic_str: string: *omit);

         return %trimR(string);

      /END-FREE
      *
     P f_formatDate...
     P                 E
      *
      *=========================================================================
      *  Parses a string representing a date.
      *=========================================================================
      *  Parameters:
      *   i_string      - String representing a date.
      *   i_pic_str     - Picture string describing the date string.
      *
      *  Returns:
      *   date          - Date.
      *=========================================================================
     P f_parseDate...
     P                 B                   export
      *
     D f_parseDate...
     D                 PI              D
     D  i_string                    128A   const  varying
     D  i_pic_str                   128A   const  varying options(*nopass)
      *
      *  Return value
     D date            S               D   inz
      *
      *  Local constants
     D cDATE_ISO       C                   'YYYYMMDD'
      *
      *  Helper fields
     D tmpDate         S             10A   inz
     D tmpLilianDate   S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         CEEDAYS(i_string: i_pic_str: tmpLilianDate: *omit);
         CEEDATE(tmpLilianDate: cDATE_ISO: tmpDate: *omit);
         date = %date(tmpDate: *ISO0);

         return date;

      /END-FREE
      *
     P f_parseDate...
     P                 E
      *
      *=========================================================================
      *  Converts a given memory size in bytes to string.
      *=========================================================================
      *  Parameters:
      *   i_memSize     - Memory size in bytes that is converted to string.
      *   io_unit       - Input:  Desired unit of the formatted memory size.
      *                   Output: Unit of the formatted memory size.
      *                   Default (input ): best fit = ''
      *                   cMEM_SIZE_BYTE
      *                   cMEM_SIZE_KILO_BYTE
      *                   cMEM_SIZE_MEGA_BYTE
      *                   cMEM_SIZE_GIGA_BYTE
      *                   cMEM_SIZE_TERA_BYTE
      *                   cMEM_SIZE_PETA_BYTE
      *                   cMEM_SIZE_EXA_BYTE
      *                   cMEM_SIZE_TETTA_BYTE
      *   i_decPos      - Number of decimal positions.
      *                   Default: 2
      *
      *  Returns:
      *   string        - Formatted memory size string.
      *=========================================================================
     P f_formatMemSize...
     P                 B                   export
      *
     D f_formatMemSize...
     D                 PI           128A          varying
     D  i_memSize                    20I 0 const
     D  io_unit                       2A          options(*nopass: *omit)
     D  i_decPos                      3I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D string          S            128A   varying inz
      *
      *  Parameter positions
     D p_unit          C                   2
     D p_decPos        C                   3
      *
      *  Optional parameter fields
     D unit            S                   like(io_unit ) inz
     D decPos          S                   like(i_decPos) inz
      *
      *  Helper fields
     D isPresent       S             10I 0 inz
     D x               S             10I 0 inz
     D i               S             10I 0 inz
     D p               S             10I 0 inz
      *
     D                 DS
     D memSize                 1     29S 7 inz
     D memSize6                1     28S 6
     D memSize5                1     27S 5
     D memSize4                1     26S 4
     D memSize3                1     25S 3
     D memSize2                1     24S 2
     D memSize1                1     23S 1
      *
      *  Static status fields
     D isInit          S               N   inz(cFalse)
     D isUnit          S               N   inz(cFalse)
     D units           S              2A   varying dim(8)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (not isInit);
            units(1) = cMEM_SIZE_BYTE;        //                                   1 Byte
            units(2) = cMEM_SIZE_KILO_BYTE;   //                               1.000 Byte
            units(3) = cMEM_SIZE_MEGA_BYTE;   //                           1.000.000 Byte
            units(4) = cMEM_SIZE_GIGA_BYTE;   //                       1.000.000.000 Byte
            units(5) = cMEM_SIZE_TERA_BYTE;   //                   1.000.000.000.000 Byte
            units(6) = cMEM_SIZE_PETA_BYTE;   //               1.000.000.000.000.000 Byte
            units(7) = cMEM_SIZE_EXA_BYTE;    //           1.000.000.000.000.000.000 Byte
            units(8) = cMEM_SIZE_ZETTA_BYTE;  //       1.000.000.000.000.000.000.000 Byte
            isInit = cTrue;
         endif;

         // Get values of optional parameters
         // ... unit
         if (%parms() >= p_unit);
            CEETSTA(isPresent: p_unit: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            unit = %trim(io_unit);
            isUnit = cTrue;
         else;
            unit = '';
            isUnit = cFalse;
         endif;

         // ... decPos
         if (%parms() >= p_decPos);
            CEETSTA(isPresent: p_decPos: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            decPos = i_decPos;
         else;
            decPos = 2;
         endif;

         p_assert(decPos >= 0 and decPos <= %decPos(memSize)
                  : 'Number of decimal positions out of range 1 to ' +
                     %char(decPos));

         // Determine index of desired unit
         x = %lookup(f_ucase(unit): units);

         // Divide memory size down to smallest possible value (unit)
         i = 1;
         memSize = i_memSize;
         dow (memSize >= 1024 and (x <> i or x = 0));
            i = i + 1;
            eval(H) memSize = memSize / 1024;
         enddo;

         // Divide memory size down to requested unit
         // (number of bytes is less than 1024)
         dow (i < x);
            i = i + 1;
            eval(H) memSize = memSize / 1024;
         enddo;

         select;
         when (decPos = 1);
            eval(H) memSize1 = memSize;
         when (decPos = 2);
            eval(H) memSize2 = memSize;
         when (decPos = 3);
            eval(H) memSize3 = memSize;
         when (decPos = 4);
            eval(H) memSize4 = memSize;
         when (decPos = 5);
            eval(H) memSize5 = memSize;
         when (decPos = 6);
            eval(H) memSize6 = memSize;
         endsl;

         string = %editc(memSize: 'N');
         string = f_left(string: %len(string) - %decPos(memSize) + decPos);

         if (isUnit);
            io_unit = units(i);
         endif;

         return string;

      /END-FREE
      *
     P f_formatMemSize...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R4  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R4 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Assert/This/Caller       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R4  - SrvPgm: Basic Routines - Assert/This/Caller           *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  12.07.2006  Th.Raddatz    Changed f_caller() and f_this() to       *
      *                            return the statement ID as the next      *
      *                            optional parameter.                      *
      *                                                                     *
      *  12.07.2006  Th.Raddatz    Changed p_assert(), f_this() and         *
      *                            f_caller() to use a static buffer of     *
      *                            2048 byte to receive the test message    *
      *                            for better performance.                  *
      *                                                                     *
      *  13.06.2008  Th.Raddatz    Added parameter 'offset' to f_caller().  *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      * =================================================================== *
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R4
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  RPG equivalent of the C Assert macro.
      *=========================================================================
      *  Parameters:
      *   i_condition   - The condition that must be TRUE.
      *   i_msgText     - The message text that is sent in case that
      *                   i_condition is FALSE.
      *                   Default:        *BLANKS
      *
      *  Returns:
      *   void
      *=========================================================================
     P p_assert...
     P                 B                   export
      *
     D p_assert...
     D                 PI
     D  i_condition                    N   const
     D  i_msgText                   128A   const  options(*nopass)
      *
      *  Make sure that the p_assert procedure is not included
      *  when the condition name COMPILE_NO_DEBUG is specified at
      *  the CRTRPGMOD command.
      /IF NOT DEFINED (COMPILE_NO_DEBUG)
      *
      *  Positions of optional parameters
     D p_msgText       C                   const(2)
      *
      *  Fields for optional parameters
     D msgText         S                   like(i_msgText ) inz
      *
      *  Local constants
     D cTEXT_MSG       C                   const('Who is before me?')
      *
      *  Helper fields QMHSNDPM/QMHRCVPM
     D qMsgF           DS                  likeds(qObj_t     )  inz
     D msgKey          S              4A   inz
     D errCode         DS                  likeds(errCode_t  )  inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
      *
      *  Helper fields QMHRCVPM
     D memSize         S             10I 0 inz
     D sndInf          DS                  likeds(sndInf_t  ) based(pSndInf  )
     D rcvm0300        DS                  likeds(rcvm0300_t) based(pRcvm0300)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   not i_condition;

            // Process optional parameters
            if   %parms >= p_msgText;
               msgText = i_msgText;
            else;
               msgText = '*N';
            endif;

            // Send a test message
            clear   qMsgF;
            qMsgF.name   = 'QCPFMSG';
            qMsgF.lib    = '*LIBL';
            errCode      = f_newApiErrCode(cTrue);
            callStkEQ.module  = '*NONE';
            callStkEQ.program = '*NONE';
            qmhsndpm('CPF9897': qMsgF: cTEXT_MSG: %size(cTEXT_MSG): '*INFO':
                     '*': 1: msgKey: errCode: 1: callStkEQ: 0);

            if   not f_isApiError(errCode);
               memSize   = 2048;
               pRcvm0300 = %alloc(memSize);
               errCode   = f_newApiErrCode(cTrue);
               callStkEQ.module  = '*NONE';
               callStkEQ.program = '*NONE';
               qmhrcvpm(rcvm0300: memSize: 'RCVM0300':
                        '*': 1: '*INFO': msgKey: 0: '*REMOVE': errCode:
                        1: callStkEQ);
            endif;

            // If everything worked as designed, ...
            if   not f_isApiError(errCode) and
                     rcvm0300.bytAvl <= memSize;
               // ... then retrieve sender information
               pSndInf = pRcvm0300 + %size(rcvm0300)
                                   + rcvm0300.lenRplDataR
                                   + rcvm0300.lenMsgR
                                   + rcvm0300.lenMsgHlpR;
            else;
               // ... else set sender information to "not available"
               pSndInf = %alloc(%size(sndInf));
               clear   sndInf;
               sndInf.rcvPgm     = '*N';
               sndInf.rcvModule  = '*N';
               sndInf.rcvProc    = '*N';
               sndInf.rcvPgmStmtNbr(1) = '*N';
            endif;

            // Create "assert" message
            msgText = %trimr(sndInf.rcvPgm    ) + '/'  +
                      %trimr(sndInf.rcvModule ) + '.'  +
                      %trimr(sndInf.rcvProc   ) + ' (' +
                      'Stmt: '                         +
                      %trimr(sndInf.rcvPgmStmtNbr(1)) + ') ' +
                      ': ' + %trim(msgText);

            // Free memory
            if   pRcvm0300 <> *NULL;
               dealloc(N)   pRcvm0300;
            else;
               if   pSndInf <> *NULL;
                  dealloc(N) pSndInf;
               endif;
            endif;

            // Send "assert" *ESCAPE message
            msgKey  = ' ';
            errCode = f_newApiErrCode(cTrue);
            callStkEQ.module  = '*NONE';
            callStkEQ.program = '*NONE';
            qmhsndpm('CPF9898': qMsgF: msgText: %size(msgText): '*ESCAPE':
                     '*': 1: msgKey: errCode: 1: callStkEQ: 0);

         endif;

      /END-FREE
      /ENDIF
      *
     C                   return
      *
     P p_assert...
     P                 E
      *
      *=========================================================================
      *  Returns the procedure, module and program name
      *  of the current procedure.
      *=========================================================================
      *  Parameters:
      *   o_module      - The module that contains the procedure.
      *   o_program     - The program that contains the module.
      *
      *  Returns:
      *   procedure     - The name of the procedure that called f_this.
      *=========================================================================
     P f_this...
     P                 B                   export
      *
     D f_this...
     D                 PI           256A          varying
     D  o_module                     10A          options(*nopass: *omit)
     D  o_program                    10A          options(*nopass: *omit)
     D  o_stmtID                     10A          options(*nopass: *omit)
      *
      *  Return value
     D procedure       S            256A   inz    varying
      *
      *  Positions of optional parameters
     D p_module        C                   const(1)
     D p_program       C                   const(2)
     D p_stmtID        C                   const(3)
      *
      *  Fields for optional parameters
     D module          S                   like(o_module  ) inz
     D program         S                   like(o_program ) inz
     D stmtID          S                   like(o_stmtID  ) inz
      *
      *  Local constants
     D cTEXT_MSG       C                   const('Who is before me?')
      *
      *  Helper fields QMHSNDPM/QMHRCVPM
     D qMsgF           DS                  likeds(qObj_t     )  inz
     D msgKey          S              4A   inz
     D errCode         DS                  likeds(errCode_t  )  inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
      *
      *  Helper fields QMHRCVPM
     D memSize         S             10I 0 inz
     D sndInf          DS                  likeds(sndInf_t  ) based(pSndInf  )
     D rcvm0300        DS                  likeds(rcvm0300_t) based(pRcvm0300)
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Send a test message
         clear   qMsgF;
         qMsgF.name   = 'QCPFMSG';
         qMsgF.lib    = '*LIBL';
         errCode      = f_newApiErrCode(cTrue);
         callStkEQ.module  = '*NONE';
         callStkEQ.program = '*NONE';
         qmhsndpm('CPF9897': qMsgF: cTEXT_MSG: %size(cTEXT_MSG): '*INFO':
                  '*': 1: msgKey: errCode: 1: callStkEQ: 0);

         if   not f_isApiError(errCode);
            memSize   = 2048;
            pRcvm0300 = %alloc(memSize);
            errCode   = f_newApiErrCode(cTrue);
            callStkEQ.module  = '*NONE';
            callStkEQ.program = '*NONE';
            qmhrcvpm(rcvm0300: memSize: 'RCVM0300':
                     '*': 1: '*INFO': msgKey: 0: '*REMOVE': errCode:
                     1: callStkEQ);
         endif;

         // If everything worked as designed, ...
         if   not f_isApiError(errCode) and
                  rcvm0300.bytAvl <= memSize;
            // ... then retrieve sender information
            pSndInf = pRcvm0300 + %size(rcvm0300)
                                + rcvm0300.lenRplDataR
                                + rcvm0300.lenMsgR
                                + rcvm0300.lenMsgHlpR;
            procedure = %trimR(sndInf.rcvProc);
            module    = sndInf.rcvModule;
            program   = sndInf.rcvPgm;
            stmtID    = sndInf.rcvPgmStmtNbr(1);
         else;
            procedure = '*N';
            module    = '*N';
            program   = '*N';
            stmtID    = '*N';
         endif;

         // Free memory
         if   pRcvm0300 <> *NULL;
            dealloc(N)   pRcvm0300;
         endif;

         // Process optional output parameters ...
         // .. o_module
         if   %parms >= p_module;
            CEETSTA(isPresent: p_module: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_module = module;
         endif;

         // .. o_program
         if   %parms >= p_program;
            CEETSTA(isPresent: p_program: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_program = program;
         endif;

         // .. o_stmtID
         if   %parms >= p_stmtID;
            CEETSTA(isPresent: p_stmtID: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_stmtID = stmtID;
         endif;

         return   procedure;

      /END-FREE
      *
     P f_this...
     P                 E
      *
      *=========================================================================
      *  Returns the procedure, module and program name
      *  that called the current procedure.
      *=========================================================================
      *  Parameters:
      *   o_module      - The module that contains the procedure.
      *   o_program     - The program that contains the module.
      *
      *  Returns:
      *   procedure     - The name of the caller of the procedure
      *                   that called f_caller.
      *=========================================================================
     P f_caller...
     P                 B                   export
      *
     D f_caller...
     D                 PI           256A          varying
     D  o_module                     10A          options(*nopass: *omit)
     D  o_program                    10A          options(*nopass: *omit)
     D  o_stmtID                     10A          options(*nopass: *omit)
     D  i_offset                      3I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D procedure       S            256A   inz    varying
      *
      *  Positions of optional parameters
     D p_module        C                   const(1)
     D p_program       C                   const(2)
     D p_stmtID        C                   const(3)
     D p_offset        C                   const(4)
      *
      *  Fields for optional parameters
     D module          S                   like(o_module  ) inz
     D program         S                   like(o_program ) inz
     D stmtID          S                   like(o_stmtID  ) inz
     D offset          S                   like(i_offset  ) inz(0)
      *
      *  Local constants
     D cTEXT_MSG       C                   const('Who is before me?')
      *
      *  Helper fields QMHSNDPM/QMHRCVPM
     D qMsgF           DS                  likeds(qObj_t     )  inz
     D msgKey          S              4A   inz
     D errCode         DS                  likeds(errCode_t  )  inz
     D callStkEQ       DS                  qualified
     D  module                 1     10A                      inz
     D  program               11     20A                      inz
      *
      *  Helper fields QMHRCVPM
     D memSize         S             10I 0 inz
     D sndInf          DS                  likeds(sndInf_t  ) based(pSndInf  )
     D rcvm0300        DS                  likeds(rcvm0300_t) based(pRcvm0300)
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get optional input parameters ...
         // .. i_offset
         if (%parms() >= p_offset and %addr(i_offset) <> *NULL);
            offset = i_offset;
         endif;

         // Send a test message
         clear   qMsgF;
         qMsgF.name   = 'QCPFMSG';
         qMsgF.lib    = '*LIBL';
         errCode      = f_newApiErrCode(cTrue);
         callStkEQ.module  = '*NONE';
         callStkEQ.program = '*NONE';
         qmhsndpm('CPF9897': qMsgF: cTEXT_MSG: %size(cTEXT_MSG): '*INFO':
                  '*': 2+offset: msgKey: errCode: 1: callStkEQ: 0);

         if   not f_isApiError(errCode);
            // Receive and remove test message
            memSize   = 2048;
            pRcvm0300 = %alloc(memSize);
            errCode   = f_newApiErrCode(cTrue);
            callStkEQ.module  = '*NONE';
            callStkEQ.program = '*NONE';
            qmhrcvpm(rcvm0300: memSize: 'RCVM0300':
                     '*': 2+offset: '*INFO': msgKey: 0: '*REMOVE': errCode:
                     1: callStkEQ);
         endif;

         // If everything worked as designed, ...
         if   not f_isApiError(errCode) and
                  rcvm0300.bytAvl <= memSize;
            // ... then retrieve sender information
            pSndInf = pRcvm0300 + %size(rcvm0300)
                                + rcvm0300.lenRplDataR
                                + rcvm0300.lenMsgR
                                + rcvm0300.lenMsgHlpR;
            procedure = %trimR(sndInf.rcvProc);
            module    = sndInf.rcvModule;
            program   = sndInf.rcvPgm;
            stmtID    = sndInf.rcvPgmStmtNbr(1);
         else;
            procedure = '*N';
            module    = '*N';
            program   = '*N';
            stmtID    = '*N';
         endif;

         // Free memory
         if   pRcvm0300 <> *NULL;
            dealloc(N)   pRcvm0300;
         endif;

         // Process optional output parameters ...
         // .. o_module
         if   %parms >= p_module;
            CEETSTA(isPresent: p_module: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_module = module;
         endif;

         // .. o_program
         if   %parms >= p_program;
            CEETSTA(isPresent: p_program: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_program = program;
         endif;

         // .. o_stmtID
         if   %parms >= p_stmtID;
            CEETSTA(isPresent: p_stmtID: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            o_stmtID = stmtID;
         endif;

         return   procedure;

      /END-FREE
      *
     P f_caller...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R5  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R5 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Objects                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R5  - SrvPgm: Basic Routines - Objects                      *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  17.12.2008  Th.Raddatz    Added f_getObjLib().                     *
      *                            Changed parameter i_text of procedure    *
      *                            f_crtUsrSpc() from 10A to 50A.           *
      *                                                                     *
      *  13.01.2009  Th.Raddatz    Added procedures:                        *
      *                            - f_chgUsrSpcSize()                      *
      *                            - f_getUsrSpcSize()                      *
      *                            - f_chgUsrSpcAutoExt()                   *
      *                            - f_getUsrSpcAutoExt()                   *
      *                            - f_chgUsrSpcInitValue()                 *
      *                            - f_getUsrSpcInitValue()                 *
      *                                                                     *
      *  26.04.2016  Th.Raddatz    Replaced %trimR(... : x'00') with        *
      *                            %str(%addr(...)) to get compatible with  *
      *                            V5R2.                                    *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R5
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,QUSRSPC                       User Space APIs
      /COPY QBASICS1,CEELIB                        CEE APIs
      /COPY QBASICS1,QP0LCVTPAT                    Qp0lCvtPathToQSYSObjName()--Resolve Path
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Retrieves the attributes of a given user space.
     D rtvUsrSpcAttr...
     D                 PR                         likeds(spca0100_t )
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Changes an attribute of a given user space.
     D chgUsrSpcAttr...
     D                 PR              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_attr                      128A   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Checks object existance.
      *=========================================================================
      *  Parameters:
      *   i_obj         - The object to check for existance.
      *   i_lib         - The library that contains the object.
      *                   Default:        *LIBL
      *   i_type        - The type of the object.
      *   i_mbr         - The member that is checked in case of that
      *                   the object is a file.
      *                   Default:        *NONE
      *
      *  Returns:
      *   doesExists    - Returns cTrue when the object exists.
      *=========================================================================
      *
     P f_exist...
     P                 B                   export
      *
     D f_exist...
     D                 PI              N
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
     D  i_mbr                        10A   const  options(*nopass)
      *
      *  Return value
     D doesExist       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_mbr           C                   const(4)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D mbr             S                   like(i_mbr       ) inz
      *
      *  Local fields
     D objd0100        DS                  likeds(objd0100_t) inz
     D mbrd0100        DS                  likeds(mbrd0100_t) inz
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);                                              //R
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // ... i_mbr
         if   %parms >= p_mbr;
            mbr = i_mbr;
         else;
            mbr = '*NONE';
         endif;

         // Retrieve the object description
         objd0100 = f_rtvObjD(i_obj: lib: i_type: 'OBJD0100': msg);

         // Retrieve member description if object is a file
         // and a member name was given
         if   (msg.ID = cMSG_ID_OK) and (mbr <> '*NONE');
            mbrd0100 = f_rtvMbrD(i_obj: lib: i_mbr: 'MBRD0100': msg);
         endif;

         // Set return value
         if   msg.ID = cMSG_ID_OK;
            doesExist = cTrue;
         else;
            doesExist = cFalse;
         endif;

         return   doesExist;

      /END-FREE
      *
     P f_exist...
     P                 E
      *
      *=========================================================================
      *  Retrieve object description.
      *=========================================================================
      *  Parameters:
      *   i_obj         - The object to retrieve information from.
      *   i_lib         - The library that contains the object.
      *                   Default:        *LIBL
      *   i_type        - The type of the object.
      *   i_format      - The format of the object description.
      *                   Default:        OBJD0100
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   object descr. - Returns the member description of the file member.
      *=========================================================================
      *
     P f_rtvObjD...
     P                 B                   export
      *
     D f_rtvObjD...
     D                 PI          1024A
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
     D  i_format                      8A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D objD            DS          1024    inz    qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 1      4I 0
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_format        C                   const(4)
     D p_msg           C                   const(5)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D format          S                   like(i_format    ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qObj            DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);                                              //R
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // ... i_format
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_format: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            format = i_format;
         else;
            format = 'OBJD0100';
         endif;

         // Call the retrieve object description API
         qObj.name = i_obj;
         qObj.lib  = i_lib;
         errCode   = f_newApiErrCode(cTrue);
         QUSROBJD(objD: %size(objD): format: qObj: i_type: errCode);

         // Set message value
         msg = f_cvtApiErrCodeToMsg(errCode);

         // Check length of receiver variable
         if   not f_isApiError(errCode);
            p_assert(objD.bytRet <= objD.bytAvl:
                     'Length of receiver variable objD is +
                      to small to hold result');
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   objD;

      /END-FREE
      *
     P f_rtvObjD...
     P                 E
      *
      *=========================================================================
      *  Retrieve member description.
      *=========================================================================
      *  Parameters:
      *   i_file        - The file that contains the member to retrieve
      *                   information from.
      *   i_lib         - The library that contains the file.
      *                   Default:        *LIBL
      *   i_mbr         - The name of the member to retrieve information from.
      *   i_format      - The format of the object description.
      *                   Default:        OBJD0100
      *
      *  Returns:
      *   object descr. - Returns the object description of the object.
      *=========================================================================
      *
     P f_rtvMbrD...
     P                 B                   export
      *
     D f_rtvMbrD...
     D                 PI          1024A
     D  i_file                       10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_mbr                        10A   const
     D  i_format                      8A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D mbrD            DS          1024    inz    qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 1      4I 0
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_format        C                   const(4)
     D p_msg           C                   const(5)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D format          S                   like(i_format    ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qFile           DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);                                              //R
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // ... i_format
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_format: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            format = i_format;
         else;
            format = 'OBJD0100';
         endif;

         // Call the retrieve object description API
         qFile.name = i_file;
         qFile.lib  = i_lib;
         errCode   = f_newApiErrCode(cTrue);
         QUSRMBRD(mbrD: %size(mbrD): format: qFile: i_mbr: '0': errCode);

         // Set message value
         msg = f_cvtApiErrCodeToMsg(errCode);

         // Check length of receiver variable
         if   not f_isApiError(errCode);
            p_assert(mbrD.bytRet <= mbrD.bytAvl:
                     'Length of receiver variable mbrD is +
                      to small to hold result');
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   mbrD;

      /END-FREE
      *
     P f_rtvMbrD...
     P                 E
      *
      *=========================================================================
      *  Produces a temporary object name.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   qTmpObj       - Returns a qualified temporary object name.
      *=========================================================================
      *
     P f_getTmpName...
     P                 B                   export
      *
     D f_getTmpName...
     D                 PI                         like(qObj_t     )
      *
      *  Return value
     D qTmpObj         DS                  likeds(qObj_t    ) inz
      *
      *  Local fields
     D pTmpNam         S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Produce temporary object name
         pTmpNam = tmpnam(*NULL);

         if   pTmpNam <> *NULL;
            qTmpObj.lib  = %str(strtok(pTmpNam: '/'));
            qTmpObj.name = %str(strtok(*NULL  : '/'));
         else;
            clear   qTmpObj;
         endif;

         return   qTmpObj;

      /END-FREE
      *
     P f_getTmpName...
     P                 E
      *
      *=========================================================================
      *  Produces a unique object name.  (experimental)
      *=========================================================================
      *  Parameters:
      *   i_type        - The type of the object.
      *   i_lib         - The library that will contain the object.
      *
      *  Returns:
      *   qUnqObj       - Returns a qualified unique object name.
      *=========================================================================
      *
     P f_getUniqueName...
     P                 B                   export
      *
     D f_getUniqueName...
     D                 PI                         like(qObj_t     )
     D  i_type                       10A   const
     D  i_lib                        10A   const
      *
      *  Return value
     D qUnqObj         DS                  likeds(qObj_t    ) inz
      *
      *  Helper fields
     D tmStmp          S               Z   inz
     D date            S               D   inz
     D time            S               T   inz
     D timeout         S               Z   inz
     D x               S             10I 0 inz
     D name            DS                  qualified
     D  longNbr                      14S 0
     D   julDate                      5S 0 overlay(longNbr: *next)
     D   time                         6S 0 overlay(longNbr: *next)
     D   mSec                         3S 0 overlay(longNbr: *next)
      *
     D                 DS
     D chars                               inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                          0123456789')
     D  char                          1A   dim(36) overlay(chars: *next)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         clear   qUnqObj;

         // Produce unique object name (max. 1 minute):
         timeout = %timestamp() + %minutes(1);

         dou   (qUnqObj.name <> '') or (%timestamp >= timeOut);

            // Produce unique object name from:
            // Julian date + Time + mSeconds
            tmStmp = %timestamp();
            time   = %time(tmStmp);
            date   = %date(tmStmp);

            name.julDate = %dec(f_val(
                                %char(date: *JUL0)): %size(name.julDate): 0);
            name.time    = %dec(f_val(
                                %char(time: *HMS0)): %size(name.time)   : 0);
            name.mSec    = %subdt(tmStmp: *MSECONDS) / 1000;

            // Set library name
            qUnqObj.lib = i_lib;

            // Encode object name to base 36
            %subst(qUnqObj.name: 1: 1) = 'Z';
            x = 2;
            dou   name.longNbr = 0;
               %subst(qUnqObj.name: x: 1) = char(%rem(name.longNbr: 36) + 1);
               name.longNbr = name.longNbr / 36;
               x = x + 1;
            enddo;

            // Check, if object exists
            if   f_exist(qUnqObj.name: qUnqObj.lib: i_type);
               // Create new name if object exists
               clear   qUnqObj;
            endif;

         enddo;

         p_assert(qUnqObj.name <> '':
                  'Unique object name of type ' + %trim(i_type) +
                  ' could not be produced'                      );

         return   qUnqObj;

      /END-FREE
      *
     P f_getUniqueName...
     P                 E
      *
      *=========================================================================
      *  Creates a user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *   i_text        - The text description of the user space.
      *                   Default:        *BLANKS
      *   i_size        - The initial size of the user space.
      *                   Default:        65536 (64 kB)
      *   i_extAtr      - The extended attribute of the user space.
      *                   Default:        *BLANKS
      *   i_pubAuth     - The public authority of the user space.
      *                   Default:        *USE
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isCreated     - Returns cTrue on success, else cFalse.
      *=========================================================================
      *
     P f_crtUsrSpc...
     P                 B                   export
      *
     D f_crtUsrSpc...
     D                 PI              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const
     D  i_text                       50A   const  options(*omit: *nopass)
     D  i_size                       10U 0 const  options(*omit: *nopass)
     D  i_extAtr                     10A   const  options(*omit: *nopass)
     D  i_pubAuth                    10A   const  options(*omit: *nopass)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isCreated       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_text          C                   const(3)
     D p_size          C                   const(4)
     D p_extAtr        C                   const(5)
     D p_pubAuth       C                   const(6)
     D p_msg           C                   const(7)
      *
      *  Optional parameter fields
     D text            S                   like(i_text      ) inz
     D size            S                   like(i_size      ) inz
     D extAtr          S                   like(i_extAtr    ) inz
     D pubAuth         S                   like(i_pubAuth   ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         isCreated = cFalse;

         // Process optional parameter values ...
         // ... i_text
         if   %parms >= p_text;
            CEETSTA(isPresent: p_text: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            text = i_text;
         else;
            text = '';
         endif;

         // ... i_size
         if   %parms >= p_size;
            CEETSTA(isPresent: p_size: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            size = i_size;
         else;
            size = 64 * 1024;
         endif;

         // ... i_extAtr
         if   %parms >= p_extAtr;
            CEETSTA(isPresent: p_extAtr: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            extAtr = i_extAtr;
         else;
            extAtr = '';
         endif;

         // ... i_pubAuth
         if   %parms >= p_pubAuth;
            CEETSTA(isPresent: p_pubAuth: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            pubAuth = i_pubAuth;
         else;
            pubAuth = '*USE';
         endif;

         // Create user space
         qUsrSpc.name = i_usrSpc;
         qUsrSpc.lib  = i_lib;
         errCode      = f_newApiErrCode(cTrue);
         QUSCRTUS(qUsrSpc: extAtr: size: x'00': pubAuth: text: '*NO': errCode);

         // Set return value
         if   f_isApiError(errCode);
            isCreated = cFalse;
            msg       = f_cvtApiErrCodeToMsg(errCode);
         else;
            isCreated = cTrue;
            msg       = f_newMsg(cMSG_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   isCreated;

      /END-FREE
      *
     P f_crtUsrSpc...
     P                 E
      *
      *=========================================================================
      *  Retrieves a pointer to the content of a user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   pUsrSpc       - Returns a pointer to the content of a user space
      *                   on success, else a NULL pointer.
      *=========================================================================
      *
     P f_rtvUsrSpcPtr...
     P                 B                   export
      *
     D f_rtvUsrSpcPtr...
     D                 PI              *
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D pUsrSpc         S               *   inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         pUsrSpc = *NULL;

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrive pointer to content of user space
         qUsrSpc.name = i_usrSpc;
         qUsrSpc.lib  = i_lib;
         errCode      = f_newApiErrCode(cTrue);
         QUSPTRUS(qUsrSpc: pUsrSpc: errCode);

         // Set return value
         if   f_isApiError(errCode);
            pUsrSpc = *NULL;
            msg     = f_cvtApiErrCodeToMsg(errCode);
         else;
            msg     = f_newMsg(cMSG_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   pUsrSpc;

      /END-FREE
      *
     P f_rtvUsrSpcPtr...
     P                 E
      *
      *=========================================================================
      *  Returns the current size of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   size          - Returns the size of a given user space on success,
      *                   else -1.
      *=========================================================================
      *
     P f_getUsrSpcSize...
     P                 B                   export
      *
     D f_getUsrSpcSize...
     D                 PI            10I 0
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields
     D spca0100        DS                  likeds(SPCA0100_t) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         size = -1;

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrieve user space attributes
         spca0100 = rtvUsrSpcAttr(i_usrSpc: lib: msg);

         // Set return value
         if (msg.ID <> cMSG_ID_OK);
            size = -1;
         else;
            size = spca0100.size;
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return size;

      /END-FREE
      *
     P f_getUsrSpcSize...
     P                 E
      *
      *=========================================================================
      *  Returns cTrue if the user space is extended automatically by the
      *  system when the end of the space is encountered.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isAutoExt     - Returns the automatic extendibility attribute
      *                   of the user space.
      *=========================================================================
      *
     P f_getUsrSpcAutoExt...
     P                 B                   export
      *
     D f_getUsrSpcAutoExt...
     D                 PI              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isAutoExt       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields
     D spca0100        DS                  likeds(SPCA0100_t) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         isAutoExt = cFalse;

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrieve user space attributes
         spca0100 = rtvUsrSpcAttr(i_usrSpc: lib: msg);

         // Set return value
         if (msg.ID <> cMSG_ID_OK);
            isAutoExt = cFalse;
         else;
            if (spca0100.autoExtend = '0');
               isAutoExt = cFalse;
            else;
               isAutoExt = cTrue;
            endif;
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return isAutoExt;

      /END-FREE
      *
     P f_getUsrSpcAutoExt...
     P                 E
      *
      *=========================================================================
      *  Returns the initial value of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   initValue     - Returns the initialvalue of a given user space.
      *=========================================================================
      *
     P f_getUsrSpcInitValue...
     P                 B                   export
      *
     D f_getUsrSpcInitValue...
     D                 PI             1A          varying
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D initValue       S              1A   inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields
     D spca0100        DS                  likeds(SPCA0100_t) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         initValue = '';

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrieve user space attributes
         spca0100 = rtvUsrSpcAttr(i_usrSpc: lib: msg);

         // Set return value
         if (msg.ID <> cMSG_ID_OK);
            initValue = '';
         else;
            initValue = spca0100.initValue;
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return initValue;

      /END-FREE
      *
     P f_getUsrSpcInitValue...
     P                 E
      *
      *=========================================================================
      *  Changes the size of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   i_size        - The new size of the user space.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   size          - Returns the new size of the user space.
      *=========================================================================
      *
     P f_chgUsrSpcSize...
     P                 B                   export
      *
     D f_chgUsrSpcSize...
     D                 PI            10I 0
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_size                       10I 0 const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D size            S             10I 0 inz(-1)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(4)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QUSCUSAT: size attribute
     D sizeAttr        DS                  likeds(QUSRSPC_attr_size_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         size = -1;

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Change the size attribute of the given user space
         sizeAttr.key     = QUSRSPC_ATTR_SIZE;
         sizeAttr.dataLen = %size(sizeAttr.size);
         sizeAttr.size    = i_size;

         chgUsrSpcAttr(i_usrSpc: lib: sizeAttr: msg);

         size = f_getUsrSpcSize(i_usrSpc: lib: *omit);

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return size;

      /END-FREE
      *
     P f_chgUsrSpcSize...
     P                 E
      *
      *=========================================================================
      *  Changes the automatic extendibility of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   i_isAutoExt   - cTrue, if the user space is automatically
      *                   extended by the system when the end of the space
      *                   is encountered.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isAutoExt     - New state of the automatic extendibility attribute
      *                   of the user space.
      *=========================================================================
      *
     P f_chgUsrSpcAutoExt...
     P                 B                   export
      *
     D f_chgUsrSpcAutoExt...
     D                 PI              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_isAutoExt                    N   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isAutoExt       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(4)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QUSCUSAT: automatic extendibility
     D autoExtAttr     DS                  likeds(QUSRSPC_auto_extend_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         isAutoExt = cFalse;

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Change the automatic extendibility of the given user space
         autoExtAttr.key     = QUSRSPC_ATTR_AUTO_EXTEND;
         autoExtAttr.dataLen = %size(autoExtAttr.autoExtend);
         if (i_isAutoExt);
            autoExtAttr.autoExtend = '1';
         else;
            autoExtAttr.autoExtend = '0';
         endif;

0        chgUsrSpcAttr(i_usrSpc: lib: autoExtAttr: msg);

         isAutoExt = f_getUsrSpcAutoExt(i_usrSpc: lib: *omit);

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return isAutoExt;

      /END-FREE
      *
     P f_chgUsrSpcAutoExt...
     P                 E
      *
      *=========================================================================
      *  Changes the initial value of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   i_initValue   - The initial value of the user space.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   initValue     - Returns the new size of the user space on success,
      *                   else -1.
      *=========================================================================
      *
     P f_chgUsrSpcInitValue...
     P                 B                   export
      *
     D f_chgUsrSpcInitValue...
     D                 PI             1A          varying
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_initValue                   1A   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D initValue       S              1A   varying inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(4)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      *
      *  Helper fields QUSCUSAT: initial value
     D initValueAttr   DS                  likeds(QUSRSPC_initial_value_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         initValue = '';

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Change the initial value of the given user space
         initValueAttr.key     = QUSRSPC_ATTR_INITIAL_VALUE;
         initValueAttr.dataLen = %size(initValueAttr.value);
         initValueAttr.value   = i_initValue;

         chgUsrSpcAttr(i_usrSpc: lib: initValueAttr: msg);

         initValue = f_getUsrSpcInitValue(i_usrSpc: lib: *omit);

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return initValue;

      /END-FREE
      *
     P f_chgUsrSpcInitValue...
     P                 E
      *
      *=========================================================================
      *  Deletes a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isDeleted     - Returns cTrue on success, else cFalse.
      *=========================================================================
      *
     P f_dltUsrSpc...
     P                 B                   export
      *
     D f_dltUsrSpc...
     D                 PI              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isDeleted       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         isDeleted = cFalse;

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Delete user space
         qUsrSpc.name = i_usrSpc;
         qUsrSpc.lib  = i_lib;
         errCode      = f_newApiErrCode(cTrue);
         QUSDLTUS(qUsrSpc: errCode);

         // Set return value
         if   f_isApiError(errCode);
            isDeleted = cFalse;
            msg       = f_cvtApiErrCodeToMsg(errCode);
         else;
            isDeleted = cTrue;
            msg       = f_newMsg(cMSG_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   isDeleted;

      /END-FREE
      *
     P f_dltUsrSpc...
     P                 E
      *
      *=========================================================================
      *  Activates a service program.
      *=========================================================================
      *  Parameters:
      *   i_srvPgm      - The name of the service program.
      *   i_lib         - The library that contains the service program.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   actSrvPgm     - Returns a structure that contains the
      *                   system pointer to the service program and
      *                   the activation mark.
      *=========================================================================
      *
     P f_activateSrvPgm...
     P                 B                   export
      *
     D f_activateSrvPgm...
     D                 PI                         likeds(actSrvPgm_t )
     D  i_srvPgm                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D actSrvPgm       DS                  likeds(actSrvPgm_t ) inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D actMark         S                   like(actInf_t.actMark ) inz
     D pSrvPgm         S               *   inz  procptr
     D actInf          DS                  likeds(actInf_t       ) inz
     D errCode         DS                  likeds(errCode_t      ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *
      *  Helper fields
     D rcvm0200        DS                  likeds(rcvm0200_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         clear actSrvPgm;
         msg = f_newMsg(cMSG_ID_OK);

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Check object exist

         // Get system pointer
         monitor;
            pSrvPgm = rslvsp(WLI_SRVPGM: i_srvPgm: lib: AUTH_OBJ_MGMT);
         on-error;
            rcvm0200 = f_rcvPgmMsg(cMsg_Any: '': cMsg_Act_Rmv);
            msg = f_newMsg('CPF9898': 'Object ' + %trim(lib) + '/'
                                                + %trim(i_srvPgm)
                                                + ' not found');
         endmon;

         // Actiate service program
         if pSrvPgm <> *NULL;
            errCode = f_newApiErrCode(cTrue);
            QleActBndPgm(pSrvPgm: actMark: actInf: %size(actInf): errCode);

            if f_isAPIError(errCode);
               msg = f_cvtApiErrCodeToMsg(errCode);
            endif;
         endif;

         if pSrvPgm <> *NULL;
            actSrvPgm.procptr = pSrvPgm;
            actSrvPgm.actMark = actMark;
            actSrvPgm.name    = i_srvPgm;
            actSrvPgm.lib     = lib;
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return actSrvPgm;

      /END-FREE
      *
     P f_activateSrvPgm...
     P                 E
      *
      *=========================================================================
      *  Gets a procedure pointer by name.
      *=========================================================================
      *  Parameters:
      *   i_srvPgm      - The name of the service program.
      *   i_lib         - The library that contains the service program.
      *                   Default:        *LIBL
      *   i_proc        - The name of the procedure.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   procptr       - Returns a pointer to the procedure on success
      *                   else *NULL.
      *=========================================================================
      *
     P f_getProcPtrByName...
     P                 B                   export
      *
     D f_getProcPtrByName...
     D                 PI                         likeds(actProc_t  )
     D  i_proc                      256A   const
     D  i_actSrvPgm                        const  likeds(actSrvPgm_t)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D actProc         DS                  likeds(actProc_t ) inz
      *
      *  Parameter positions
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D typeExpItem     S             10I 0 inz
     D pExpItem        S               *   inz  procptr
     D errCode         DS                  likeds(errCode_t      ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         clear actProc;
         msg = f_newMsg(cMSG_ID_OK);

         // Get procedure pointer by name
         errCode = f_newApiErrCode(cTrue);
         QleGetExp(i_actSrvPgm.actMark: *omit: %len(%trimR(i_proc))
                   : %trimR(i_proc): pExpItem: typeExpItem: errCode);
         if f_isAPIError(errCode);
            msg = f_cvtApiErrCodeToMsg(errCode);
         endif;

         if pExpItem <> *NULL;
            actproc.procptr = pExpItem;
            actproc.actMark = i_actSrvPgm.actMark;
            actproc.name    = i_proc;
            actproc.srvPgm  = i_actSrvPgm.name;
            actproc.lib     = i_actSrvPgm.lib;
         endif;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return actProc;

      /END-FREE
      *
     P f_getProcPtrByName...
     P                 E
      *
      *=========================================================================
      *  Returns the name of the library that contains a given object.
      *=========================================================================
      *  Parameters:
      *   i_obj         - The name of the object whose library is resolved.
      *   i_lib         - The special value of the library name that contains
      *                   the object.
      *                   Default:        *LIBL
      *   i_type        - The type of the object.
      *
      *  Returns:
      *   rtnLib        - Name of the library that contains the object.
      *=========================================================================
      *
     P f_getObjLib...
     P                 B                   export
      *
     D f_getObjLib...
     D                 PI            10A
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
      *
      *  Return value
     D rtnLib          S             10A   inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
      *
      *  Local fields
     D objd0100        DS                  likeds(objd0100_t) inz
     D msg             DS                  likeds(msg_t     ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         // ... i_lib
         if   %parms >= p_lib;
            CEETSTA(isPresent: p_lib: *omit);                                              //R
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrieve the object description
         objd0100 = f_rtvObjD(i_obj: lib: i_type: 'OBJD0100': msg);

         // Set return value
         if (msg.ID = cMSG_ID_OK);
            rtnLib = objd0100.rtnLib;
         else;
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToMyself);
         endif;

         return rtnLib;

      /END-FREE
      *
     P f_getObjLib...
     P                 E
      *
      *=========================================================================
      *  Converts a QSYS object name to a path.
      *=========================================================================
      *  Parameters:
      *   i_obj         - The name of the object.
      *   i_lib         - The name of the object library.
      *                   Default:        *LIBL
      *   i_mbr         - The name of the member, when the object is a file.
      *
      *  Returns:
      *   path          - IFS path name.
      *=========================================================================
      *  Examples:
      *   f_cvtQSYSObjNameToPath(qFile)
      *   f_cvtQSYSObjNameToPath(qObj: '*DTAARA');
      *   f_cvtQSYSObjNameToPath(library: '*LIB');
      *   f_cvtQSYSObjNameToPath(object: '*OUTQ');
      *   f_cvtQSYSObjNameToPath(object: library: '*MSGQ');
      *   f_cvtQSYSObjNameToPath(object: library: member: '*FILE');
      *=========================================================================
     P f_cvtQSYSObjNameToPath...
     P                 B                   export
     D                 PI          5000A   varying opdesc
     D  i_obj                        40A   const  options(*varsize)
     D  i_libOrType                  10A   const  options(*nopass: *omit)
     D  i_mbrOrType                  10A   const  options(*nopass: *omit)
     D  i_objType                    10A   const  options(*nopass: *omit)
      *
      *  Return value
     D path            S           5000A   varying inz
      *
      *  Parameter positions
     D p_obj           C                   const(1)
     D p_libOrType     C                   const(2)
     D p_mbrOrType     C                   const(3)
     D p_objType       C                   const(4)
      *
      *  Optional parameter fields
     D libOrType       S                   like(i_libOrType ) inz
     D mbrOrType       S                   like(i_mbrOrType ) inz
     D objType         S                   like(i_objType   ) inz
      *
      *  Local fields
     D objInf          DS                  likeds(strInf_t  ) inz
     D qQSYSObj        DS                  likeds(qQSYSObj_t) inz
     D qFile           DS                  likeds(qFile_t   ) inz
     D qObj            DS                  likeds(qFile_t   ) inz
      *
     D object          S             10A   inz
     D library         S             10A   inz
     D member          S             10A   inz
     D type            S             10A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Process optional parameter values ...
         if (%parms() >= p_libOrType and %addr(i_libOrType) <> *null);
            libOrType = i_libOrType;
         else;
            libOrType = '';
         endif;

         if (%parms() >= p_mbrOrType and %addr(i_mbrOrType) <> *null);
            mbrOrType = i_mbrOrType;
         else;
            mbrOrType = '';
         endif;

         if (%parms() >= p_objType and %addr(i_objType) <> *null);
            objType = i_objType;
         else;
            objType = '';
         endif;

         CEEGSI(p_obj: objInf.dataType: objInf.curlen: objInf.maxlen: *omit);

         select;
         when (objInf.curlen = 40);   // 1 parameter
            p_assert(%parms() = 1
                     : 'Expected number of parameters: 1');
            qQSYSObj = i_obj;
            object = qQSYSObj.name;
            library = qQSYSObj.lib;
            member = qQSYSObj.mbr;
            type = qQSYSObj.type;

         when (objInf.curlen = 30);   // 2 parameters
            p_assert(%parms() = 1 or %parms() = 2
                     : 'Expected number of parameters: 1 or 2');
            p_assert(%parms() = 1 or (%parms() = 2 and libOrType = '*FILE')
                     : 'Expected number of parameters: 1 or (2 and *FILE)');
            qFile = i_obj;
            object = qFile.name;
            library = qFile.lib;
            member = qFile.mbr;
            if (%parms() = 1);
               type = '*FILE';
            else;
               type = libOrType;
            endif;

         when (objInf.curlen = 20);   // 2 parameters
            p_assert(%parms() = 2
                     : 'Expected number of parameters: 2');
            qObj = i_obj;
            object = qObj.name;
            library = qObj.lib;
            member = '';
            type = libOrType;

         other;                       // 3 or 4 parameters, eg:
            p_assert(%parms() = 2 or %parms() = 3 or
                     (%parms() = 4 and objType = '*FILE')
                     : 'Expected number of parameters: 2, 3 or (4 and *FILE)');
            object = i_obj;
            select;
            when (%parms() = 2);
               library = '';
               member = '';
               type = libOrType;
            when (%parms() = 3);
               library = libOrType;
               member = '';
               type = mbrOrType;
            other;
               library = libOrType;
               member = mbrOrType;
               type = objType;
            endsl;
         endsl;

         if (type = '*LIB');
            library = object;
            object = '';
         else;
            if (library = '');
               library = '*LIBL';
            endif;
         endif;

         path = '/QSYS.LIB';

         if (library <> '' and library <> 'QSYS');
            path += '/';

            select;
            when (library = '*ALL');
               path += '%ALL%';
            when (library = '*ALLUSR');
               path += '%ALLUSR%';
            when (library = '*CURLIB');
               path += '%CURLIB%';
            when (library = '*LIBL');
               path += '%LIBL%';
            when (library = '*USRLIBL');
               path += '%USRLIBL%';
            other;
               path += %trim(library);
            endsl;

            path += '.LIB';
         endif;

         if (object <> '');
            path += '/';

            select;
            when (object = '*ALL');
               path += '%ALL%';
            other;
               path += %trim(object);
            endsl;

            path += '.' + %trimR(%subst(type: 2));
         endif;

         if (member <> '');
            path += '/';

            path += %trim(member);

            path += '.MBR';
         endif;

         return path;

      /END-FREE
     P                 E
      *
      *=========================================================================
      *  Resolve Integrated File System Path Name into
      *  QSYS Object Name
      *=========================================================================
      *  Parameters:
      *   i_path        - Path of the object.
      *
      *  Returns:
      *   qQSYSObj      - resolved QSYS object name.
      *=========================================================================
     P f_cvtPathToQSYSObjName...
     P                 B                   export
     D                 PI                  likeds(qQSYSObj_t)
     D  i_path                     5000A   const  varying options(*varsize)
      *
      *  Return value
     D qQSYSObj        DS                  likeds(qQSYSObj_t)
      *
      *  Local fields
     D pathName        ds                  likeds(Qlg_Path_Name_t) inz
     D qsys_info       ds                  likeds(qsys0100_t) inz
     D errCode         ds                  likeds(errCode_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pathName = *ALLx'00';
         pathName.CCSID = QLG_PATH_JOB_CCSID;
         pathName.Country_ID = QLG_PATH_JOB_COUNTRYID;
         pathName.Language_ID = QLG_PATH_JOB_LANGUAGEID;
         pathName.Reserved = *ALLx'00';
         pathName.Path_Type = QLG_CHAR_SINGLE;
         pathName.Path_Length = %len(%trimR(i_path));
         pathName.Path_Name_Delimiter = '/';
         pathName.Reserved2 = *ALLx'00';
         pathName.Path_Name = i_path;
         errCode = f_newApiErrCode(cFalse);

         Qp0lCvtPathToQSYSObjName(
            pathName: qsys_info: 'QSYS0100': %size(qsys_info): 0: errCode);

         if (%str(%addr(qsys_info.obj_type)) = '' and
             %str(%addr(qsys_info.lib_type)) = '*LIB');
            qQSYSObj.name = %str(%addr(qsys_info.lib_name));
            qQSYSObj.lib = '';
            qQSYSObj.mbr = '';
            qQSYSObj.type = %str(%addr(qsys_info.lib_type));
         else;
            qQSYSObj.name = %str(%addr(qsys_info.obj_name));
            qQSYSObj.lib = %str(%addr(qsys_info.lib_name));
            qQSYSObj.mbr = %str(%addr(qsys_info.mbr_name));
            qQSYSObj.type = %str(%addr(qsys_info.obj_type));
         endif;

         select;
         when (qQSYSObj.lib = '%ALL%');
            qQSYSObj.lib = '*ALL';
         when (qQSYSObj.lib = '%ALLUSR%');
            qQSYSObj.lib = '*ALLUSR';
         when (qQSYSObj.lib = '%CURLIB%');
            qQSYSObj.lib = '*CURLIB';
         when (qQSYSObj.lib = '%LIBL%');
            qQSYSObj.lib = '*LIBL';
         when (qQSYSObj.lib = '%USRLIBL%');
            qQSYSObj.lib = '*USRLIBL';
         endsl;

         select;
         when (qQSYSObj.name = '%ALL%');
            qQSYSObj.name = '*ALL';
         endsl;

         return qQSYSObj;

      /END-FREE
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Retrieves the attributes of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   attrs         - Returns the attributes of a given user space.
      *=========================================================================
      *
     P rtvUsrSpcAttr...
     P                 B
      *
     D rtvUsrSpcAttr...
     D                 PI                         likeds(spca0100_t )
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D spca0100        DS                  likeds(spca0100_t ) inz
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0                  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         clear spca0100;

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Retrive user space attributes
         qUsrSpc.name = i_usrSpc;
         qUsrSpc.lib  = i_lib;
         errCode      = f_newApiErrCode(cTrue);
         QUSRUSAT(spca0100: %size(spca0100): 'SPCA0100': qUsrSpc: errCode);

         // Set return value
         if (f_isApiError(errCode));
            clear spca0100;
            msg = f_cvtApiErrCodeToMsg(errCode);
         else;
            msg = f_newMsg(cMSG_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return spca0100;

      /END-FREE
      *
     P rtvUsrSpcAttr...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Changes an attribute of a given user space.
      *=========================================================================
      *  Parameters:
      *   i_usrSpc      - The name of the user space.
      *   i_lib         - The library that contains the user space.
      *                   Default:        *LIBL
      *   i_attr        - The attribute to change.
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isChanged     - Returns cTrue on success, else cFalse.
      *=========================================================================
      *
     P chgUsrSpcAttr...
     P                 B
      *
     D chgUsrSpcAttr...
     D                 PI              N
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_attr                      128A   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isChanged       S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_lib           C                   const(2)
     D p_msg           C                   const(4)
      *
      *  Optional parameter fields
     D lib             S                   like(i_lib       ) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Local fields
     D rtnLib          S             10A                      inz
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *
      *  Helper fields QUSCUSAT
     D userSpaceAttr   DS                  qualified
     D  numAttrs                     10I 0 inz
     D  attrToChg                   128A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize return value
         isChanged = cFalse;

         // Process optional parameter values ...
         // ... i_lib
         if (%parms() >= p_lib);
            CEETSTA(isPresent: p_lib: *omit);
         else;
            isPresent = 0;
         endif;

         if (isPresent = 1);
            lib = i_lib;
         else;
            lib = '*LIBL';
         endif;

         // Change the attribute of the given user space
         qUsrSpc.name = i_usrSpc;
         qUsrSpc.lib  = lib;
         userSpaceAttr.numAttrs  = 1;
         userSpaceAttr.attrToChg = i_attr;
         errCode = f_newApiErrCode(cTrue);
         QUSCUSAT(rtnLib: qUsrSpc: userSpaceAttr: errCode);

         // Set return value
         if (f_isApiError(errCode));
            isChanged = cFalse;
            msg       = f_cvtApiErrCodeToMsg(errCode);
         else;
            isChanged = cTrue;
            msg       = f_newMsg(cMSG_ID_OK);
         endif;

         // Process optional/omissible message parameter
         if (%parms() >= p_msg);
            CEETSTA(isPresent: p_msg: *omit);
            if (isPresent = 1);
               o_msg = msg;
            endif;
         else;
            if (msg.ID <> cMSG_ID_OK);
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return isChanged;

      /END-FREE
      *
     P chgUsrSpcAttr...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R6  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R6 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Commands/Environment     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R6  - SrvPgm: Basic Routines - Commands                     *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  10.10.2006  Th.Raddatz    Changed f_getEnvVarByIndex to respect    *
      *                            the length of the environment variable.  *
      *                                                                     *
      *  18.12.2007  Th.Raddatz    Changed f_execute() to receive an error  *
      *                            message directly rather that trying to   *
      *                            get it from the errorCode parameter.     *
      *                                                                     *
      *  05.02.2009  Th.Raddatz    Added p_wait() procedure.                *
      *                                                                     *
      *  24.03.2009  Th.Raddatz    Added prompter action support to         *
      *                            f_execute().                             *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R6
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      *  len(envVarBuf) = len(name(128)) + len(value(1024)) + len(null-byte(1))
     D envVarBuf_t     S           1153A   based(pDummy)
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      *  Initialize Environment for Variables
     D lf_initEnv...
     D                 PR            10I 0
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Executes a CL command.
      *=========================================================================
      *  Parameters:
      *   i_cmd         - The CL command to execute.
      *   i_typeCmdPrc  - The type of command processing.
      *                   Default:        cCMD_PRC_EXC_QCMDEXC
      *   o_msg         - The API error message.
      *
      *  Returns:
      *   isExecuted    - Returns cTrue when the command was executed
      *                   successfully.
      *=========================================================================
      *
     P f_execute...
     P                 B                   export
      *
     D f_execute...
     D                 PI              N   opdesc
     D  i_cmd                     16384A   const  options(*varsize)
     D  i_typeCmdPrc                 10I 0 const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D isExecuted      S               N   inz(cFalse)
      *
      *  Parameter positions
     D p_cmd           C                   const(1)
     D p_typeCmdPrc    C                   const(2)
     D p_msg           C                   const(3)
      *
      *  Optional parameter fields
     D typeCmdPrc      S                   like(i_typeCmdPrc) inz
     D msg             DS                  likeds(o_msg     ) inz
      *
      *  Helper fields CEEGSI
     D si_cmd          DS                  likeds(strInf_t  ) inz
      *
      *  Helper fields QCAPCMD
     D optCtrlBlk      DS                  qualified
     D  typeCmdPrc             1      4I 0 inz(0)                               QCMDEXC
     D  DBCS_data              5      5A   inz('0')                             ignore DBCS
     D  prmtAction             6      6A   inz('0')                             never prompt
     D  cmdStrSyntax           7      7A   inz('0')                             AS/400 Syntax
     D  msgRtvKey              8     11A   inz(*BLANKS)                         no msg key
     D  res_01                12     20A   inz(*ALLx'00')
      *
     D chgCmd          S            128A   inz
     D chgCmdBytAvl    S             10I 0 inz
      *
     D errCode         DS                  likeds(errCode_t ) inz
      *
      *  Helper fields CEETSTA
     D isPresent       S             10I 0 inz
      *
      *  Helper fields
     D rcvm0200        DS                  likeds(rcvm0200_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Retrieve string information of i_cmd
         CEEGSI(p_cmd: si_cmd.datatype: si_cmd.curlen: si_cmd.maxlen: *omit);

         // Process optional parameter values ...
         // ... i_typeCmdPrc
         if   %parms >= p_typeCmdPrc;
            CEETSTA(isPresent: p_typeCmdPrc: *omit);
         else;
            isPresent = 0;
         endif;

         if   isPresent = 1;
            typeCmdPrc = i_typeCmdPrc;
         else;
            typeCmdPrc = cCMD_PRC_EXC_QCMDEXC;
         endif;

         // Set options control block
         reset   optCtrlBlk;
         optCtrlBlk.typeCmdPrc = %bitand(typeCmdPrc: x'0000FFFF');

         // Set prompter action
         select;
         when (f_isBitOn(cCMD_PRC_PROMPT_HELP: typeCmdPrc));
            optCtrlBlk.prmtAction = '3';

         when (f_isBitOn(cCMD_PRC_PROMPT_ON_REQUEST: typeCmdPrc));
            optCtrlBlk.prmtAction = '2';

         when (f_isBitOn(cCMD_PRC_PROMPT_ALWAYS: typeCmdPrc));
            optCtrlBlk.prmtAction = '1';

         other;
            optCtrlBlk.prmtAction = '0';

         endsl;

         // Execute the command
         p_rmvPgmMsg(cMsg_Rmv_All);

         monitor;
            errCode = f_newApiErrCode(cFalse);
            QCAPCMD(%subst(i_cmd: 1: si_cmd.curlen) :
                    si_cmd.curlen                   :
                    optCtrlBlk                      :
                    %size(optCtrlBlk)               :
                    'CPOP0100'                      :
                    chgCmd                          :
                    0                               :
                    chgCmdBytAvl                    :
                    errCode                         );
            msg = f_newMsg(cMSG_ID_OK);
            isExecuted = cTrue;
         on-error;
            rcvm0200 = f_rcvPgmMsg(cMsg_Any);
            msg = f_cvtRcvMsgToMsg(rcvm0200: cMsg_Escape);
            isExecuted = cFalse;
         endmon;

         // Process optional/omissible message parameter
         if   %parms >= p_msg;
            CEETSTA(isPresent: p_msg: *omit);
            if   isPresent = 1;
               o_msg = msg;
            endif;
         else;
            if   msg.ID <> cMSG_ID_OK;
               f_sndPgmMsg(msg: cMsg_Prv);
            endif;
         endif;

         return   isExecuted;

      /END-FREE
      *
     P f_execute...
     P                 E
      *
      *=========================================================================
      *  Gets an environment variable.
      *=========================================================================
      *  Parameters:
      *   i_envVar      - Name of environment variable to read.
      *
      *  Returns:
      *   value         - Returns the value of the environment variable.
      *=========================================================================
      *
     P f_getEnvVar...
     P                 B                   export
      *
     D f_getEnvVar...
     D                 PI          1024A          varying
     D  i_pEnvVar                      *   const  options(*string)
      *
      *  Return value
     D value           S           1024A   varying   inz
      *
      *  Helper fields
     D pValue          S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pValue = getenv(i_pEnvVar);

         if   pValue <> *NULL;
            value = %str(pValue);
         else;
            value = '';
         endif;

         return   value;

      /END-FREE
      *
     P f_getEnvVar...
     P                 E
      *
      *=========================================================================
      *  Sets an environment variable.
      *=========================================================================
      *  Parameters:
      *   i_envVar      - Name of environment variable to read.
      *   i_value       - Value of the environment variable.
      *
      *  Returns:
      *   isSet         - Returns cTrue when the variable was set
      *                   successfully.
      *=========================================================================
      *
     P f_setEnvVar...
     P                 B                   export
      *
     D f_setEnvVar...
     D                 PI              N
     D  i_envVar                           const  like(envVar_t.name )
     D  i_value                            const  like(envVar_t.value)
      *
      *  Return value
     D isSet           S               N   inz(cFalse)
      *
      *  Helper fields
     D envVarBuf       S                   like(envVarBuf_t) inz
     D rc              S             10I 0                   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         envVarBuf = i_envVar + '=' + i_value + x'00';
         rc = putenv(%addr(envVarBuf));

         if   rc = 0;
            isSet = cTrue;
         else;
            isSet = cFalse;
         endif;

         return   isSet;

      /END-FREE
      *
     P f_setEnvVar...
     P                 E
      *
      *=========================================================================
      *  Deletes a given environment variable.
      *=========================================================================
      *  Parameters:
      *   i_envVar      - Name of given environment variable to delete.
      *
      *  Returns:
      *   value         - Returns the value of the environment variable.
      *=========================================================================
      *
     P f_delEnvVar...
     P                 B                   export
      *
     D f_delEnvVar...
     D                 PI              N
     D  i_pEnvVar                      *   const  options(*string)
      *
      *  Return value
     D isDeleted       S               N   inz(cFalse)
      *
      *  Helper fields
     D rc              S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         rc = Qp0zDltEnv(i_pEnvVar);

         if   rc = 0;
            isDeleted = cTrue;
         else;
            isDeleted = cFalse;
         endif;

         return   isDeleted;

      /END-FREE
      *
     P f_delEnvVar...
     P                 E
      *
      *=========================================================================
      *  Gets the number of environment variables.
      *=========================================================================
      *  Parameters:
      *
      *  Returns:
      *   numEnvVar     - Returns the number of environment variables
      *                   on success, else -1.
      *=========================================================================
      *
     P f_getNumEnvVar...
     P                 B                   export
      *
     D f_getNumEnvVar...
     D                 PI            10I 0
      *
      *  Return value
     D numEnvVar       S             10I 0 inz
      *
      *  Helper fields
     D ppEnvVar        S               *   based(pEnvVar)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if lf_initEnv() = 0;
            pEnvVar = ENVIRON;
            dow ppEnvVar <> *NULL;
               numEnvVar = numEnvVar + 1;
               pEnvVar   = pEnvVar + %size(pEnvVar);
            enddo;
         else;
            numEnvVar = -1;
         endif;

         return   numEnvVar;

      /END-FREE
      *
     P f_getNumEnvVar...
     P                 E
      *
      *=========================================================================
      *  Gets an environment variable by its index.
      *=========================================================================
      *  Parameters:
      *   i_index       - Index of the environment variable.
      *
      *  Returns:
      *   envVar        - Returns an envVar structure.
      *                   envVar.name is blanks if the environment variable
      *                   does not exist.
      *=========================================================================
      *
     P f_getEnvVarByIndex...
     P                 B                   export
      *
     D f_getEnvVarByIndex...
     D                 PI                         likeds(envVar_t )
     D  i_index                      10I 0 const
      *
      *  Return value
     D envVar          DS                  likeds(envVar_t ) inz
      *
      *  Helper fields
     D index           S                   like(i_index    ) inz
     D ppEnvVar        S               *   based(pEnvVar)
     D length          S             10I 0                   inz
      *
      *  len(envVarBuf) = len(name(128)) + len(value(1024)) + len(null-byte(1))
     D envVarBuf       S                   like(envVarBuf_t) inz
     D x               S             10I 0                   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if lf_initEnv() = 0;
            pEnvVar = ENVIRON;
            index = 0;
            dow ppEnvVar <> *NULL and index < i_index;
               index = index + 1;
               if index < i_index;
                  pEnvVar   = pEnvVar + %size(pEnvVar);
               endif;
            enddo;
            clear envVar;
            if index = i_index;
               length = strlen(ppEnvVar);
               envVarBuf = %str(ppEnvVar);
               x = %scan('=': envVarBuf);
               if x > 1;
                  envVar.name = %subst(envVarBuf: 1: x-1);
                  if x < %len(envVarBuf);
                     envVar.value = %subst(envVarBuf: x+1: length - x);
                  else;
                     envVar.value = '';
                  endif;
               endif;
            endif;
         endif;

         return   envVar;

      /END-FREE
      *
     P f_getEnvVarByIndex...
     P                 E
      *
      *=========================================================================
      *  Waits for the specified number of seconds.
      *=========================================================================
      *  Parameters:
      *   i_seconds     - Number of seconds to wait.
      *
      *  Returns:
      *   void
      *=========================================================================
      *
     P p_wait...
     P                 B                   export
      *
     D p_wait...
     D                 PI
     D  i_seconds                    10I 0 const
      *
      *  Helper fields
     D mi_time         S              8A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         mitime(mi_time: 0: 0: i_seconds: 0);

         waittime(mi_time: cWAIT_NORMAL + cWAIT_SIGNALS);

         return;

      /END-FREE
      *
     P p_wait...
     P                 E
      *
      *=========================================================================
    R *  *** PRIVATE ***
      *  Initialize Environment for Variables
      *=========================================================================
      *
     P lf_initEnv...
     P                 B
      *
     D lf_initEnv...
     D                 PI            10I 0
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D isInit          S               N   inz(cFalse) static
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if not isInit;
            rc = Qp0zInitEnv();
            if rc = 0;
               isInit = cTrue;
            endif;
         else;
            rc = 0;
         endif;

         return   rc;

      /END-FREE
      *
     P lf_initEnv...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R7  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R7 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Mathematics              "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R7  - SrvPgm: Basic Routines - Mathematics                  *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  08.10.2003                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *   4.02.2005  Th.Raddatz    Added f_genUUID() to generate a          *
      *                            Universal Unique Identifier (UUID).      *
      *   8.03.2005  Th.Raddatz    Added f_genMD5() to generate a           *
      *                            MD5 fingerprint (hash code).             *
      *   8.03.2005  Th.Raddatz    Added f_genSHA1() to generate a          *
      *                            SHA-1 fingerprint (hash code).           *
      *   8.03.2005  Th.Raddatz    Added f_genSHA1() to generate a          *
      *                            SHA-1 fingerprint (hash code).           *
      *  28.12.2005  Th.Raddatz    Added f_genCRC32() to generate a         *
      *                            CRC-32 check sum.                        *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/BASICS1R7) +                *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< OPTIMIZE(*FULL );                                    *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R7
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      /if not defined(*V5R3M0)                                                              //
      /COPY QBASICS1,MILIB
      /endif
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      /if defined(C_COMPILER)
     D c_crc32...
     D                 PR            10U 0        extproc('crc32')
     D  crc                          10U 0 value
     D  buf                            *   value
     D  len                          10U 0 value
      *
      /else
     D lp_crc32Table...
     D                 PR
     D  io_crc32Table                10U 0        dim(256)
      *
      /endif
      /if not defined(*V5R2M0)                                                              //
      *  Returns the bit-wise ANDing of the arguments.
     D lf_bitAND...
     D                 PR            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Returns the bit-wise ORing of the arguments.
     D lf_bitOR...
     D                 PR            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Returns the bit-wise exclusive ORing of the arguments.
     D lf_bitXOR...
     D                 PR            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Returns the bit-wise inverse of the bits of the argument.
     D lf_bitNOT...
     D                 PR            10U 0
     D  i_arg                        10U 0 value
      *
      /endif
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Tests for one or more bits.
      *=========================================================================
      *  Parameters:
      *   i_testBit     - The bits that are tested.
      *   i_value       - The numeric value that is tested for the bits.
      *
      *  Returns:
      *   isOn          - Returns cTrue when the bits specified at i_testBit
      *                   are set.
      *=========================================================================
      *
     P f_isBitOn...
     P                 B                   export
      *
     D f_isBitOn...
     D                 PI              N
     D  i_testBit                    10U 0 value
     D  i_value                      10U 0 value
      *
      *  Return value
     D isOn            S               N   inz(cTrue)
      *
      *  Helper fields
     D x               S              3I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_testBit > 0:
                  'i_testBit is out of range. It must be greater than 0');

         p_assert(i_value >= 0:
                  'i_value is out of range. It must be greater than/equal 0');

         isOn = cTrue;

         for   x = (%size(i_value) * 8) - 1 downTo 0 ;
            if   tstbts(%addr(i_testBit): x) <> 0;
               if   tstbts(%addr(i_value): x) = 0;
                  isOn = cFalse;
                  leave;
               endif;
            endif;
         endfor;

         return   isOn;

      /END-FREE
      *
     P f_isBitOn...
     P                 E
      *
      *=========================================================================
      *  Computes the logarithm base 10 of a given value.
      *=========================================================================
      *  Parameters:
      *   i_value       - The numeric value.
      *
      *  Returns:
      *   log           - The logarithm value of i_value.
      *=========================================================================
      *
     P f_log10...
     P                 B                   export
      *
     D f_log10...
     D                 PI             8F
     D  i_value                       8F   value
      *
      *  Return value
     D log             S              8F   inz
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         CEESDLG1(i_value: log);

         return   log;

      /END-FREE
      *
     P f_log10...
     P                 E
      *
      *=========================================================================
      *  Computes the length of a RPG integer field from its buffer length
      *=========================================================================
      *  Parameters:
      *   i_value       - The numeric value.
      *
      *  Returns:
      *   log           - The logarithm value of i_value.
      *=========================================================================
      *
     P f_clcLengthOfRPGIntFieldFromBufSize...
     P                 B                   export
      *
     D f_clcLengthOfRPGIntFieldFromBufSize...
     D                 PI             5U 0
     D  i_buffSize                    5U 0 value
      *
      *  Return value
     D tempResult      S              8F   inz
     D rpgLength       S              5U 0 inz
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         tempResult = f_log10(2 ** (8 * i_buffSize));

         // Always round up to the next unsigned integer
         rpgLength  = %unsh(((tempResult * 10) + 5) / 10);

         return   rpgLength;

      /END-FREE
      *
     P f_clcLengthOfRPGIntFieldFromBufSize...
     P                 E
      *
      *=========================================================================
      *  Generates a Universal Unique Identifier (UUID).
      *=========================================================================
      *  The UUID is unique as an identifier across all time and space and is
      *  consistent with the Open Systems Foundation (OSF) Distributed Computing
      *  Environments (DCE) version 1 UUID specification described in the DCE's
      *  "Architecture Environment Specification/Distributed Computing: for
      *  Remote Procedure Calls", Appendix A.
      *  http://publib.boulder.ibm.com/infocenter/iseries/v5r3/ic2924/index.htm
      *=========================================================================
      *  Parameters:
      *   i_option      - Specifies how to return the UUID.
      *                   Default:        *HEX
      *                   cUUID_HEX     - Returns a hexadecimal UUID with
      *                                   a length of 16 byte.
      *                   cUUID_STRING  - Returns the string representation
      *                                   of a UUID with a length of 32 bytes.
      *
      *  Returns:
      *   uuid          - The UUID of type structure of type uuid_t:
      *                       uuid.value   - the value of the generated UUID
      *                       uuid.length  - the length of the generated UUID
      *=========================================================================
      *
     P f_genUUID...
     P                 B                   export
      *
     D f_genUUID...
     D                 PI                         likeds(uuid_t  )
     D  i_option                      5U 0 value  options(*nopass)
      *
      *  Return value
     D uuid            DS                  likeds(uuid_t) inz
      *
      *  Parameter positions
     D p_option        C                   const(1)
      *
      *  Fields for optional parameters
     D option          S                   like(i_option) inz
      *
      *  Helper fields
     D uuidHex         S             16A   inz
     D uuidString      S             32A   inz
     D uuidTemplate    DS                  likeds(uuid_template_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get optional parameters
         if %parms >= p_option;
            option = i_option;
         else;
            option = cUUID_HEX;
         endif;

         p_assert((option = cUUID_HEX) or (option = cUUID_STRING):
                  'i_option is not valid.');

         // Generate UUID:
         uuidTemplate.bytPrv   = %size(uuid_t);
         uuidTemplate.bytAvl   = 0;
         uuidTemplate.reserved = *ALLx'00';
         uuidTemplate.uuid     = *ALLx'00';
         genUUID(%addr(uuidTemplate));

         if uuidTemplate.bytAvl = 0;
            uuid.value  = '';
            uuid.length = 0;
         else;
            if option = cUUID_HEX;
               // Return UUID as hex value
               uuid.value  = uuidTemplate.uuid;
               uuid.length = %size(uuidTemplate.uuid);
            else;
               // Convert hexadecimal UUID to string
               uuid.value  = f_cvtBufferToHexString(%addr(uuidTemplate.uuid):
                                                    %size(uuidTemplate.uuid));
               uuid.length = %size(uuidTemplate.uuid) * 2;
            endif;
         endif;

         return   uuid;

      /END-FREE
      *
     P f_genUUID...
     P                 E
      *
      *=========================================================================
      *  Generates a MD5 fingerprint (hash code).
      *=========================================================================
      *  Parameters:
      *   i_pString     - Pointer to a buffer or a variable or a literal
      *                   that contains the source string.
      *   i_options     - Specifies how to return the MD5.
      *                   Default:        cMD5_HEX + cMD5_ONLY
      *                   cMD5_HEX      - Returns a hexadecimal 16-byte MD5
      *                                   fingerprint (hash code).
      *                   cMD5_STRING   - Returns a hexadecimal 32-byte MD5
      *                                   fingerprint (hash code).
      *                   cMD5_ONLY     - Use this option to pass the
      *                                   complete buffer.
      *                   cMD5_FIRST    - Use this option to pass the first
      *                                   portion of a multi-part buffer.
      *                   cMD5_MIDDLE   - Use this option to pass the middle
      *                                   portions of a multi-part buffer.
      *                   cMD5_FINAL    - Use this option to pass the final
      *                                   portion of a multi-part buffer.
      *   i_length      - Length of the source string. If a variable or
      *                   a string is specified at i_pString, length
      *                   can be omitted.
      *
      *  Returns:
      *   md5           - The MD5 of type structure of type md5_t:
      *                       md5.value    - the value of the generated MD5
      *                       md5.length   - the length of the generated MD5
      *=========================================================================
      *
     P f_genMD5...
     P                 B                   export
      *
     D f_genMD5...
     D                 PI                         likeds(md5_t   )
     D  i_pString                      *   const  options(*string)
     D  i_options                     5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      *  Return value
     D MD5             DS                  likeds(md5_t  ) inz
      *
      *  Parameter positions
     D p_options       C                   const(2)
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D options         S                   like(i_options) inz
     D length          S                   like(i_length ) inz
      *
      *  Helper fields
     D isOutputString  S               N   inz(cFalse)
     D hashContext     S            160A   static   inz(*ALLx'00' )
     D ctrlsSeq        S                   like(controls.sequence) inz
     D numOptions      DS                  qualified
     D  sequence                      5U 0 inz
     D  output                        5U 0 inz
     D controls        DS                  likeds(cipherCtrls_t  ) inz
     D msg             DS                  likeds(msg_t          ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get optional parameters ...
         // ... options
         if %parms >= p_options;
            options = i_options;
         else;
            options = cMD5_HEX + cMD5_ONLY;
         endif;

         // ... length
         if %parms >= p_length;
            length = i_length;
         else;
            length = strlen(i_pString);
         endif;

         // Check/get sequence options
         numOptions.sequence = 0;
         if f_isBitOn(cMD5_ONLY  : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cMD5_ONLY;
            ctrlsSeq = cCIPHER_ONLY;
         endif;
         if f_isBitOn(cMD5_FIRST : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cMD5_FIRST;
            ctrlsSeq = cCIPHER_FIRST;
         endif;
         if f_isBitOn(cMD5_MIDDLE: options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cMD5_MIDDLE;
            ctrlsSeq = cCIPHER_MIDDLE;
         endif;
         if f_isBitOn(cMD5_FINAL : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cMD5_FINAL;
            ctrlsSeq = cCIPHER_FINAL;
         endif;

         select;
         when  numOptions.sequence =  0;
            ctrlsSeq = cCIPHER_ONLY;
         when  numOptions.sequence <> 1;
            msg = f_newMsg('CPF9898':
                           'Invalid number of sequence options': cMsg_Escape);
            f_sndPgmMsg(msg);
         endsl;

         // Check/get output options
         numOptions.output = 0;
         if f_isBitOn(cMD5_STRING: options);
            numOptions.output = numOptions.output + 1;
            options        = options - cMD5_STRING;
            isOutputString = cTrue;
         endif;
         if f_isBitOn(cMD5_HEX: options);
            numOptions.output = numOptions.output + 1;
            options        = options - cMD5_HEX;
            isOutputString = cFalse;
         endif;

         if  numOptions.output <> 1;
            msg = f_newMsg('CPF9898':
                           'Invalid number of output options': cMsg_Escape);
            f_sndPgmMsg(msg);
         endif;

         if  options <> 0;
            msg = f_newMsg('CPF9898':
                           'Invalid option flags found': cMsg_Escape);
            f_sndPgmMsg(msg);
         endif;

         // Initialize cipher function
         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FIRST);
            hashContext = *ALLx'00';
         endif;

         controls.function      = x'0005';
         controls.hashAlg       = cCIPHER_MD5;   // Hex 00 = MD5
                                                 // Hex 01 = SHA-1
         controls.sequence      = ctrlsSeq;      // Hex 00 = Only
                                                 // Hex 01 = First
                                                 // Hex 02 = Middle
                                                 // Hex 03 = Final
         controls.dataLength    = length;
         controls.output        = cCIPHER_HASH;  // Hex 00 =  Hash
                                                 // Hex 01 =  HMAC
         controls.reserved_1    = *ALLx'00';
         controls.hashContext   = %addr(hashContext);
         controls.HMACKey       = *NULL;
         controls.HMACKeyLength = 0;
         controls.reserved_2    = *ALLx'00';

         // Generate MD5 hash code.
         cipher(%addr(MD5.value): %addr(controls): i_pString);

         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FINAL);
            if isOutputString;
               // Convert hexadecimal MD5 to string
               MD5.value  = f_cvtBufferToHexString(%addr(MD5.value): 16);
               MD5.length = 32;
            else;
               // Return MD5 as hex value
               MD5.length = 16;
            endif;
         else;
            MD5.value  = '';
            MD5.length = 0;
         endif;

         return   MD5;

      /END-FREE
      *
     P f_genMD5...
     P                 E
      *
      *=========================================================================
      *  Generates a SHA-1 fingerprint (hash code).
      *=========================================================================
      *  Parameters:
      *   i_pString     - Pointer to a buffer or a variable or a literal
      *                   that contains the source string.
      *   i_options     - Specifies how to return the SHA-1.
      *                   Default:        cSHA1_HEX + cSHA1_ONLY
      *                   cSHA1_HEX     - Returns a hexadecimal 20-byte SHA-1
      *                                   fingerprint (hash code).
      *                   cSHA1_STRING  - Returns a hexadecimal 40-byte SHA-1
      *                                   fingerprint (hash code).
      *                   cSHA1_ONLY    - Use this option to pass the
      *                                   complete buffer.
      *                   cSHA1_FIRST   - Use this option to pass the first
      *                                   portion of a multi-part buffer.
      *                   cSHA1_MIDDLE  - Use this option to pass the middle
      *                                   portions of a multi-part buffer.
      *                   cSHA1_FINAL   - Use this option to pass the final
      *                                   portion of a multi-part buffer.
      *   i_length      - Length of the source string. If a variable or
      *                   a string is specified at i_pString, length
      *                   can be omitted.
      *
      *  Returns:
      *   sha1          - The SHA-1 of type structure of type sha1_t:
      *                       sha1.value   - the value of the generated SHA-1
      *                       sha1.length  - the length of the generated SHA-1
      *=========================================================================
      *
     P f_genSHA1...
     P                 B                   export
      *
     D f_genSHA1...
     D                 PI                         likeds(sha1_t  )
     D  i_pString                      *   const  options(*string)
     D  i_options                     5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      *  Return value
     D SHA1            DS                  likeds(sha1_t ) inz
      *
      *  Parameter positions
     D p_options       C                   const(2)
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D options         S                   like(i_options) inz
     D length          S                   like(i_length ) inz
      *
      *  Helper fields
     D isOutputString  S               N   inz(cFalse)
     D hashContext     S            160A   static   inz(*ALLx'00' )
     D ctrlsSeq        S                   like(controls.sequence) inz
     D numOptions      DS                  qualified
     D  sequence                      5U 0 inz
     D  output                        5U 0 inz
     D controls        DS                  likeds(cipherCtrls_t) inz
     D msg             DS                  likeds(msg_t        ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get optional parameters ...
         // ... options
         if %parms >= p_options;
            options = i_options;
         else;
            options = cSHA1_HEX + cSHA1_ONLY;
         endif;

         // ... length
         if %parms >= p_length;
            length = i_length;
         else;
            length = strlen(i_pString);
         endif;

         // Check/get sequence options
         numOptions.sequence = 0;
         if f_isBitOn(cSHA1_ONLY  : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cSHA1_ONLY;
            ctrlsSeq = cCIPHER_ONLY;
         endif;
         if f_isBitOn(cSHA1_FIRST : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cSHA1_FIRST;
            ctrlsSeq = cCIPHER_FIRST;
         endif;
         if f_isBitOn(cSHA1_MIDDLE: options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cSHA1_MIDDLE;
            ctrlsSeq = cCIPHER_MIDDLE;
         endif;
         if f_isBitOn(cSHA1_FINAL : options);
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cSHA1_FINAL;
            ctrlsSeq = cCIPHER_FINAL;
         endif;

         select;
         when  numOptions.sequence =  0;
            ctrlsSeq = cCIPHER_ONLY;
         when  numOptions.sequence <> 1;
            msg = f_newMsg('CPF9898':
                           'Invalid number of sequence options': cMsg_Escape);
            f_sndPgmMsg(msg);
         endsl;

         // Check output options
         numOptions.output = 0;
         if f_isBitOn(cSHA1_STRING: options);
            numOptions.output = numOptions.output + 1;
            options        = options - cSHA1_STRING;
            isOutputString = cTrue;
         endif;
         if f_isBitOn(cSHA1_HEX: options);
            numOptions.output = numOptions.output + 1;
            options        = options - cSHA1_HEX;
            isOutputString = cFalse;
         endif;

         if  numOptions.output <> 1;
            msg = f_newMsg('CPF9898':
                           'Invalid number of output options': cMsg_Escape);
            f_sndPgmMsg(msg);
         endif;

         if  options <> 0;
            msg = f_newMsg('CPF9898':
                           'Invalid option flags found': cMsg_Escape);
            f_sndPgmMsg(msg);
         endif;

         // Initialize cipher function
         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FIRST);
            hashContext = *ALLx'00';
         endif;

         controls.function      = x'0005';
         controls.hashAlg       = cCIPHER_SHA1;  // Hex 00 = MD5
                                                 // Hex 01 = SHA-1
         controls.sequence      = ctrlsSeq;      // Hex 00 = Only
                                                 // Hex 01 = First
                                                 // Hex 02 = Middle
                                                 // Hex 03 = Final
         controls.dataLength    = length;
         controls.output        = cCIPHER_HASH;  // Hex 00 =  Hash
                                                 // Hex 01 =  HMAC
         controls.reserved_1    = *ALLx'00';
         controls.hashContext   = %addr(hashContext);
         controls.HMACKey       = *NULL;
         controls.HMACKeyLength = 0;
         controls.reserved_2    = *ALLx'00';

         // Generate SHA-1 hash code.
         cipher(%addr(SHA1.value): %addr(controls): i_pString);

         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FINAL);
            if isOutputString;
               // Convert hexadecimal SHA-1 to string
               SHA1.value  = f_cvtBufferToHexString(%addr(SHA1.value): 20);
               SHA1.length = 40;
            else;
               // Return SHA-1 as hex value
               SHA1.length = 20;
            endif;
         else;
            SHA1.value  = '';
            SHA1.length = 0;
         endif;

         return   SHA1;

      /END-FREE
      *
     P f_genSHA1...
     P                 E
      *
      *=========================================================================
      *  Calculates a CRC32 checksum for a given string buffer.
      *=========================================================================
      *  Code was taken and converted to RPG from:
      *  http://www.vbaccelerator.com/home/VB/Code/Libraries/CRC32/article.asp
      *=========================================================================
      *  Parameters:
      *   i_pString     - Pointer to a buffer or a variable or a literal
      *                   that contains the source string.
      *   i_options     - Specifies how to return the CRC32.
      *                   Default:        cCRC32_ONLY.
      *                   cCRC32_ONLY   - Use this option to pass the
      *                                   complete buffer.
      *                   cCRC32_FIRST  - Use this option to pass the first
      *                                   portion of a multi-part buffer.
      *                   cCRC32_MIDDLE - Use this option to pass the middle
      *                                   portions of a multi-part buffer.
      *                   cCRC32_FINAL  - Use this option to pass the final
      *                                   portion of a multi-part buffer.
      *   i_length      - Length of the source string. If a variable or
      *                   a string is specified at i_pString, length
      *                   can be omitted.
      *
      *  Returns:
      *   crc32         - The CRC32 of type structure of type crc32_t:
      *                       crc32.value  - the value of the generated CRC32
      *                       crc32.length - the length of the generated CRC32
      *=========================================================================
      *
     P f_genCRC32...
     P                 B                   export
      *
     D f_genCRC32...
     D                 PI                         likeds(crc32_t )
     D  i_pString                      *   const  options(*string)
     D  i_options                     5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      *  Return value
     D CRC32           DS                  likeds(crc32_t) inz
      *
      *  Parameter positions
     D p_options       C                   const(2)
     D p_length        C                   const(3)
      *
      *  Fields for optional parameters
     D options         S                   like(i_options) inz
     D length          S                   like(i_length ) inz
      *
      *  Helper fields
     D ctrlsSeq        S             10I 0                       inz
     D aBufChar        S              3U 0 based(pABufChar     )
     D i               S             10U 0 inz
     D iLookup         S             10U 0 inz
     D numOptions      DS                  qualified
     D  sequence                      5U 0                       inz
     D msg             DS                  likeds(msg_t        ) inz
      *
      *  Static helper fields
     D                 DS                                              static
      /if defined(C_COMPILER)
     D  crc32Result                  10U 0 inz
      /else
     D  crc32Result                  10U 0 inz
      /endif
      /if not defined(C_COMPILER)
     D crc32Result1_1          1      1A
     D crc32Result1_3          1      3A
     D crc32Result2_4          2      4A
      *
     D isInit          S               N   inz(cFalse)                 static
     D crc32Table      S             10U 0 inz                         static
     D                                     dim(256)
      /endif
      /if not defined(*V5R3M0)
     D tmpResult       S             10U 0
     D hex000000FF     S             10U 0 inz(x'FF')
      /endif
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get optional parameters ...
         // ... options
         if %parms >= p_options;
            options = i_options;
         else;
            options = cCRC32_ONLY;
         endif;

         // ... length
         if %parms >= p_length;
            length = i_length;
         else;
            length = strlen(i_pString);
         endif;

         // Check/get sequence options
         numOptions.sequence = 0;
      /if defined(*V5R2M0)
         if %bitAnd(cCRC32_ONLY  : options) = cCRC32_ONLY;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_ONLY;
            ctrlsSeq = cCIPHER_ONLY;
         endif;
         if %bitAnd(cCRC32_FIRST : options) = cCRC32_FIRST;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_FIRST;
            ctrlsSeq = cCIPHER_FIRST;
         endif;
         if %bitAnd(cCRC32_MIDDLE: options) = cCRC32_MIDDLE;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_MIDDLE;
            ctrlsSeq = cCIPHER_MIDDLE;
         endif;
         if %bitAnd(cCRC32_FINAL : options) = cCRC32_FINAL;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_FINAL;
            ctrlsSeq = cCIPHER_FINAL;
         endif;
      /else
         if lf_bitAnd(cCRC32_ONLY  : options) = cCRC32_ONLY;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_ONLY;
            ctrlsSeq = cCIPHER_ONLY;
         endif;
         if lf_bitAnd(cCRC32_FIRST : options) = cCRC32_FIRST;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_FIRST;
            ctrlsSeq = cCIPHER_FIRST;
         endif;
         if lf_bitAnd(cCRC32_MIDDLE: options) = cCRC32_MIDDLE;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_MIDDLE;
            ctrlsSeq = cCIPHER_MIDDLE;
         endif;
         if lf_bitAnd(cCRC32_FINAL : options) = cCRC32_FINAL;
            numOptions.sequence = numOptions.sequence + 1;
            options  = options - cCRC32_FINAL;
            ctrlsSeq = cCIPHER_FINAL;
         endif;
      /endif

         select;
         when  numOptions.sequence =  0;
            ctrlsSeq = cCIPHER_ONLY;
         when  numOptions.sequence <> 1;
            msg = f_newMsg('CPF9898':
                           'Invalid number of sequence options': cMsg_Escape);
            f_sndPgmMsg(msg);
         endsl;

         if  options <> 0;
            msg = f_newMsg('CPF9898':
                           'Invalid option flags found': cMsg_Escape);
            f_sndPgmMsg(msg);
         endif;

         // Initialize CRC32
         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FIRST);
      /if not defined(C_COMPILER)
            crc32Result = x'FFFFFFFF';
            if not isInit;
               lp_crc32Table(crc32Table);
               isInit = cTrue;
            endif;
      /else
            crc32Result = x'FFFFFFFF';
      /endif
         endif;

         // Compute CRC32 checksum
      /if defined(C_COMPILER)
         crc32Result = c_crc32(crc32Result: i_pString: length);
      /elseif defined(*V5R2M0)
         for i = 0 to length - 1;
            pABufChar = i_pString + i;
            iLookup   = %bitxor(%bitand(crc32Result: x'FF'): aBufChar);
            crc32Result2_4 = crc32Result1_3;                         // nasty shift-right
            crc32Result1_1 = x'00';                                  // 8-bit
            crc32Result = %bitxor(crc32Result: crc32Table(iLookup + 1));
         endfor;
      /else
         for i = 0 to length - 1;
            pABufChar = i_pString + i;
            // iLookup   = %bitxor(%bitand(crc32ResultU: x'FF'): aBufChar);
            iLookup = 0;
            ANDSTR(%addr(tmpResult)  : %addr(crc32Result):
                   %addr(hex000000FF): 4);
            XORSTR(%addr(iLookup)+3: %addr(tmpResult)+3:
                   %addr(aBufChar): 1);
            crc32Result2_4 = crc32Result1_3;                         // nasty shift-right
            crc32Result1_1 = x'00';                                  // 8-bit
            // crc32Result = %bitxor(crc32Result: crc32Table(iLookup + 1));
            tmpResult = crc32Table(iLookup + 1);
            XORSTR(%addr(crc32Result): %addr(crc32Result):
                   %addr(tmpResult  ): 4);
         endfor;
      /endif

         // Set return value
         if (ctrlsSeq = cCIPHER_ONLY) or (ctrlsSeq = cCIPHER_FINAL);
      /if defined(*V5R2M0)
            crc32Result = %bitnot(crc32Result);
      /else
            COMSTR(%addr(crc32Result): %addr(crc32Result): 4);
      /endif
            // Convert hexadecimal CRC32 to string
            CRC32.value = f_cvtBufferToHexString(%addr(crc32Result):
                                                 %size(crc32Result));
            CRC32.length = 8;
         else;
            CRC32.value  = '';
            CRC32.length = 0;
         endif;

         return   CRC32;

      /END-FREE
      *
     P f_genCRC32...
     P                 E
      *
      /if not defined(C_COMPILER)
      *=========================================================================
    R *  *** private ***
      *  Initialize crc32Table with official used by CRC32 in PKZip.
      *  Often the polynomial is shown reversed (04C11DB7).
      *=========================================================================
      *
     P lp_crc32Table...
     P                 B
      *
     D lp_crc32Table...
     D                 PI
     D  io_crc32Table                10U 0        dim(256)
      *
      *  Helper fields
     D i               S             10I 0 inz
     D j               S             10I 0 inz
     D dwCrc           S             10U 0 inz
     D                 DS
     D dwPolynomial                  10U 0
     D dwPolynomialH           1      4    inz(x'EDB88320')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

            for i = 0 to 255;
               dwCrc = i;
               for j = 8 downto 1;
      /if defined(*V5R2M0)
                  if %bitand(dwCrc: x'01') <> 0;
                     dwCrc = %bitand(%uns(
                                %bitand(dwCrc: x'FFFFFFFE') / 2): x'7FFFFFFF');
                     dwCrc = %bitxor(dwCrc: dwPolynomial);
                  else;
                     dwCrc = %bitand(%uns(
                                %bitand(dwCrc: x'FFFFFFFE') / 2): x'7FFFFFFF');
                  endif;
      /else
                  if lf_bitand(dwCrc: x'01') <> 0;
                     dwCrc = lf_bitand(%uns(
                               lf_bitand(dwCrc: x'FFFFFFFE') / 2): x'7FFFFFFF');
                     dwCrc = lf_bitxor(dwCrc: dwPolynomial);
                  else;
                     dwCrc = lf_bitand(%uns(
                               lf_bitand(dwCrc: x'FFFFFFFE') / 2): x'7FFFFFFF');
                  endif;
      /endif
               endfor;
               io_crc32Table(i+1) = dwCrc;
            endfor;

         return;

      /END-FREE
      *
     P lp_crc32Table...
     P                 E
      *
      /endif
      /if not defined(*V5R2M0)                                                              //
      *=========================================================================
    R *  *** private ***
      *  Returns the bit-wise ANDing of the arguments.
      *=========================================================================
      *
     P lf_bitAND...
     P                 B
      *
     D lf_bitAND...
     D                 PI            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Return value
     D result          S             10U 0
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         ANDSTR(%addr(result): %addr(i_arg1): %addr(i_arg2): %len(result));

         return result;

      /END-FREE
      *
     P lf_bitAND...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns the bit-wise ORing of the arguments.
      *=========================================================================
      *
     P lf_bitOR...
     P                 B
      *
     D lf_bitOR...
     D                 PI            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Return value
     D result          S             10U 0
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         XORSTR(%addr(result): %addr(i_arg1): %addr(i_arg2): %len(result));

         return result;

      /END-FREE
      *
     P lf_bitOR...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns the bit-wise exclusive ORing of the arguments.
      *=========================================================================
      *
     P lf_bitXOR...
     P                 B
      *
     D lf_bitXOR...
     D                 PI            10U 0
     D  i_arg1                       10U 0 value
     D  i_arg2                       10U 0 value
      *
      *  Return value
     D result          S             10U 0
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         XORSTR(%addr(result): %addr(i_arg1): %addr(i_arg2): %len(result));

         return result;

      /END-FREE
      *
     P lf_bitXOR...
     P                 E
      *
      *=========================================================================
    R *  *** private ***
      *  Returns the bit-wise inverse of the bits of the argument.
      *=========================================================================
      *
     P lf_bitNOT...
     P                 B
      *
     D lf_bitNOT...
     D                 PI            10U 0
     D  i_arg                        10U 0 value
      *
      *  Return value
     D result          S             10U 0
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         COMSTR(%addr(result): %addr(i_arg): %len(result));

         return result;

      /END-FREE
      *
     P lf_bitNOT...
     P                 E
      *
      /endif
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R8  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R8 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Handle/Memory            "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R8  - SrvPgm: Basic Routines - Handle/Memory                *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  30.12.2004                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  27.04.2005  Th.Raddatz    Replaced handle_t.value with             *
      *                            handle_t.pUserHandle to dynamically      *
      *                            allocate storage for user handle.        *
      *                                                                     *
      *  28.04.2005  Th.Raddatz    Fixed problem that let HANDLE_isNULL()   *
      *                            crash, because of wrong assert().        *
      *                                                                     *
      *  14.02.2006  Th.Raddatz    Added procedures:  MEMORY_allocate()     *
      *                                               MEMORY_freeAll()      *
      *                                                                     *
      *  21.02.2006  Th.Raddatz    Changed HANDLE_isTypeOf() to return      *
      *                            'invalid handle' in case the handle      *
      *                            is *NULL.                                *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN
     H BNDDIR('QC2LE')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R8
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
     D baseHandle_t    DS            32    qualified   based(pDummy)   align
     D  type                         20A
     D  size                         10I 0
      *
      /if not defined(*V5R2M0)
     D handle_t        DS                  qualified   based(pDummy)   align
     D  baseHandle                         like(baseHandle_t  )
     D  pUserHandle                    *
      /else
     D handle_t        DS                  qualified   based(pDummy)   align
     D  baseHandle                         likeds(baseHandle_t)
     D  pUserHandle                    *
      /endif
      *
      * -----------------------------------------
      *  Imported Prototypes
      * -----------------------------------------
      /COPY QBASICS1,HEAPAPI
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
     D g_handleList    S               *   dim(32767) inz
      *
     D g_mmStatus      DS                  qualified
     D  numAlloc                     10U 0 inz(0)
      *
      *=========================================================================
      *  Creates a new handle.
      *=========================================================================
      *  Parameters:
      *   i_type        - The type of the handle.
      *   i_size        - The size of memory needed for the handle data.
      *
      *  Returns:
      *   aHandle       - Returns the handle on success, else a NULL handle.
      *=========================================================================
     P HANDLE_new...
     P                 B                   export
      *
     D HANDLE_new...
     D                 PI                         like(HANDLE_handle_t)
     D  i_type                             value  like(HANDLE_type_t  )
     D  i_size                       10U 0 value
      *
      *  Return value
     D aHandle         S                   like(HANDLE_handle_t) inz
      *
      *  Helper fields
     D handle          DS                  likeds(handle_t    ) based(pHandle)
      *
      * V5R1
     D baseHandle      DS                  likeds(baseHandle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Find a free handle element
         aHandle = %lookup(*NULL: g_handleList);

         // If there is no free element, ...
         if   aHandle = 0;
            // then return a NULL handle
            aHandle = HANDLE_null();
         else;
            // else allocate memory for a base handle
            // and the size of memory requested.
            pHandle = %alloc(%size(baseHandle_t) + i_size);
            g_handleList(aHandle) = pHandle;

            // Initialize handle - V5R3
            // handle.baseHandle.type = i_type;
            // handle.baseHandle.size = i_size;
            // handle.pUserHandle = %alloc(baseHandle.size);
            // memset(handle.pUserHandle: x'00': baseHandle.size);

            // Initialize handle - V5R1
            baseHandle.type = i_type;
            baseHandle.size = i_size;
            handle.baseHandle = baseHandle;
            handle.pUserHandle = %alloc(baseHandle.size);
            memset(handle.pUserHandle: x'00': baseHandle.size);
         endif;

         return   aHandle;

      /END-FREE
      *
     P HANDLE_new...
     P                 E
      *
      *=========================================================================
      *  Returns a NULL handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   aHandle       - Returns a NULL handle.
      *=========================================================================
     P HANDLE_null...
     P                 B                   export
      *
     D HANDLE_null...
     D                 PI                         like(HANDLE_handle_t)
      *
      *  Return value
     D aHandle         S                   like(HANDLE_handle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Return a NULL handle
         aHandle = 0;

         return   aHandle;

      /END-FREE
      *
     P HANDLE_null...
     P                 E
      *
      *=========================================================================
      *  Checks a handle for a NULL value.
      *=========================================================================
      *  Parameters:
      *   i_handle      - A given handle.
      *
      *  Returns:
      *   isNull        - Returns cTrue if the handle is NULL, else cFalse.
      *=========================================================================
     P HANDLE_isNull...
     P                 B                   export
      *
     D HANDLE_isNull...
     D                 PI              N
     D  i_handle                           value  like(HANDLE_handle_t)
      *
      *  Return value
     D isNull          S               N   inz(cFalse)
      *
      *  Helper fields
     D handle          DS                  likeds(handle_t) based(pHandle)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Also allow 0 here!
         p_assert(i_handle >= 0 and i_handle <= %elem(g_handleList):
                  'Value of io_handle is out of range');

         // Get handle adress
         if   i_handle = 0;
            pHandle = *NULL;
         else;
            pHandle = g_handleList(i_handle);
         endif;

         // Check handle NULL value
         if   pHandle = *NULL;
            isNull = cTrue;
         else;
            isNull = cFalse;
         endif;

         return   isNull;

      /END-FREE
      *
     P HANDLE_isNull...
     P                 E
      *
      *=========================================================================
      *  Checks the type of a given handle.
      *=========================================================================
      *  Parameters:
      *   i_handle      - A given handle.
      *   i_type        - The type of the handle.
      *
      *  Returns:
      *   isValid       - Returns cTrue on success, else cFalse.
      *=========================================================================
     P HANDLE_isTypeOf...
     P                 B                   export
      *
     D HANDLE_isTypeOf...
     D                 PI              N
     D  i_handle                           value  like(HANDLE_handle_t)
     D  i_type                             value  like(HANDLE_type_t  )
      *
      *  Return value
     D isValid         S               N   inz(cFalse)
      *
      *  Helper fields
     D handle          DS                  likeds(handle_t) based(pHandle)
      *
      /if not defined(*V5R2M0)
     D baseHandle      DS                  likeds(baseHandle_t) inz
      /endif
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_handle < 1 or i_handle > %elem(g_handleList));
            isValid = cFalse;
            return isValid;
         endif;

         // Get handle adress
         pHandle = g_handleList(i_handle);

         if pHandle <> *NULL;

      /if not defined(*V5R2M0)
            baseHandle = handle.baseHandle;
            if baseHandle.type = i_type;
               isValid = cTrue;
            else;
               isValid = cFalse;
            endif;
      /else
            if handle.baseHandle.type = i_type;
               isValid = cTrue;
            else;
               isValid = cFalse;
            endif;
      /endif
         else;
            isValid = cFalse;
         endif;

         return   isValid;

      /END-FREE
      *
     P HANDLE_isTypeOf...
     P                 E
      *
      *=========================================================================
      *  Retrieves a pointer to the handle data from a given handle.
      *=========================================================================
      *  Parameters:
      *   i_handle      - A given handle.
      *
      *  Returns:
      *   pHandle       - Returns the pointer of a given handle.
      *=========================================================================
     P HANDLE_getPointer...
     P                 B                   export
      *
     D HANDLE_getPointer...
     D                 PI              *
     D  i_handle                           value  like(HANDLE_handle_t)
      *
      *  Return value
     D pUserHandle     S               *   inz
      *
      *  Helper fields
     D handle          DS                  likeds(handle_t) based(pHandle)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_handle >= 1 and i_handle <= %elem(g_handleList):
                  'Value of io_handle is out of range');

         // Get handle adress
         pHandle = g_handleList(i_handle);

         // Get address of user handle
         pUserHandle = handle.pUserHandle;

         return   pUserHandle;

      /END-FREE
      *
     P HANDLE_getPointer...
     P                 E
      *
      *=========================================================================
      *  Deletes a given handle.
      *=========================================================================
      *  Parameters:
      *   io_handle      - The handle to delete.
      *
      *  Returns:
      *   void
      *=========================================================================
     P HANDLE_delete...
     P                 B                   export
      *
     D HANDLE_delete...
     D                 PI
     D  io_handle                                 like(HANDLE_handle_t)
      *
      *  Helper fields
     D handle          DS                  likeds(handle_t) based(pHandle)
      *
      * V5R1
     D baseHandle      DS                  likeds(baseHandle_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(io_handle >= 1 and io_handle <= %elem(g_handleList):
                  'Value of io_handle is out of range');

         // Get handle adress
         pHandle = g_handleList(io_handle);

         p_assert(pHandle <> *NULL:
                  'Handle address is already *NULL');

         // Initialize handle memory - V5R3
         // memset(handle.pUserHandle: x'00': baseHandle.size);
         // handle.baseHandle.size = 0;
         // handle.baseHandle.type = *ALLx'00';

         // Initialize handle memory - V5R1
         baseHandle = handle.baseHandle;
         memset(handle.pUserHandle: x'00': baseHandle.size);
         dealloc(N) handle.pUserHandle;
         baseHandle.size = 0;
         baseHandle.type = *ALLx'00';
         handle.baseHandle = baseHandle;

         // Free handle memory
         dealloc(N) pHandle;

         // Free index in handle list
         g_handleList(io_handle) = *NULL;

         // Free user handle
         io_handle = HANDLE_null();

         return;

      /END-FREE
      *
     P HANDLE_delete...
     P                 E
      *
      *=========================================================================
      *  Allocates a memory cell and keeps track of it.
      *=========================================================================
      *  Parameters:
      *   i_aMemList    - Pointer to the last cell of the chain of memory call.
      *   i_size        - The number of bytes to allocate.
      *
      *  Returns:
      *   pMemory       - A pointer to the memory cell.
      *=========================================================================
     P MEMORY_allocate...
     P                 B                   export
      *
     D MEMORY_allocate...
     D                 PI              *
     D  io_aMemList                    *
     D  i_size                       10I 0 value
      *
      *  Return value
     D pMemory         S               *   inz
      *
      *
     D cell            DS                  qualified   based(pCell)
     D  pPrvCell                       *
     D  size                         10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%rem(i_size : %size(pDummy)) <> 0);
            i_size = (%div(i_size : %size(pDummy)) + 1) * %size(pDummy);
         endif;

         if (i_size = 0);
            pMemory = *NULL;
         else;
            pMemory = %alloc(i_size + %size(cell));
            pCell   = pMemory + i_size;            // Position cell right after payload
            cell.pPrvCell    = io_aMemList;        // Remember the address of the prv. cell
            cell.size        = i_size;             // Remember the size of the current cell
            io_aMemList      = pCell;              // Remember this cell
         endif;

         return pMemory;

      /END-FREE
      *
     P MEMORY_allocate...
     P                 E
      *
      *=========================================================================
      *  Frees all allocated memory cells.
      *=========================================================================
      *  Parameters:
      *   io_aMemList   - Pointer to the last cell of the chain of memory call.
      *                   returned from f_gsoap_Environment_new().
      *
      *  Returns:
      *   void
      *=========================================================================
     P MEMORY_freeAll...
     P                 B                   export
      *
     D MEMORY_freeAll...
     D                 PI
     D  io_aMemList                    *
      *
      *  Helper fields
     D pMemory         S               *   inz
      *
     D cell            DS                  qualified   based(pCell)
     D  pPrvCell                       *
     D  size                         10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         dow (io_aMemList <> *NULL);
            pCell            = io_aMemList;             // Get last cell allocated
            pMemory          = pCell - cell.size;       // Get start address of this cell
            io_aMemList      = cell.pPrvCell;           // Go back to prv. cell
            cell.size        = 0;                       // Clear size of this cell
            cell.pPrvCell    = *NULL;                   // Clear mem-ptr of this cell
            free(pMemory);                              // Free memory of this cell
         enddo;

         return;

      /END-FREE
      *
     P MEMORY_freeAll...
     P                 E
      *
      *=========================================================================
      *  Frees a given memory cell.
      *=========================================================================
      *  Parameters:
      *   io_pMem       - Pointer to the memory cell to be free.
      *
      *  Returns:
      *   void
      *=========================================================================
     P MEMORY_free...
     P                 B                   export
      *
     D MEMORY_free...
     D                 PI
     D  io_aMemList                    *
     D  io_pMem                        *
      *
      *  Helper fields
     D pMemory         S               *   inz
      *
     D prvCell         DS                  qualified   based(pPrvCell)
     D  pPrvCell                       *
     D  size                         10I 0
      *
     D cell            DS                  qualified   based(pCell)
     D  pPrvCell                       *
     D  size                         10I 0
      *
     D nextCell        DS                  qualified   based(pNextCell)
     D  pPrvCell                       *
     D  size                         10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Return to caller because there's nothing to do.
         if io_aMemList = *NULL;
            return;
         endif;

         // When we start searching for the requested cell,
         // there is no cell before the current cell.
         pPrvCell = *NULL;

         // Point "cell" to last allocated cell.
         pCell = io_aMemList;

         // Spin through chain on allocated memory cells
         // searching for the cell to free:
         dow (pCell <> *NULL);
            pMemory = pCell - cell.size;       // Get start address of this cell

            // If we hit the cell to delete ...
            if pMemory = io_pMem;
               // ... let "nextCel" point to next cell in chain of cells.
               pNextCell        = cell.pPrvCell;

               // If there is no cell before the cell to delete ...
               if pPrvCell = *NULL;
                  // ... set pointer of "nextCell" as the start of the list of cells.
                  io_aMemList = pNextCell;
               else;
                  // ... else link "nextCell" to "prvCell"
                  prvCell.pPrvCell = pNextCell;
               endif;

               // Clear cell data and free memory
               cell.size        = 0;                    // Clear size of this cell
               cell.pPrvCell    = *NULL;                // Clear mem-ptr of this cell
               free(pMemory);                           // Free memory of this cell

               pNextCell = *NULL;
               leave;   // Ready => Leave
            endif;

            // Rememeber this cell as the previous cell.
            pPrvCell  = pCell;

            // Goto next cell
            pCell = cell.pPrvCell;
         enddo;

         return;

      /END-FREE
      *
     P MEMORY_free...
     P                 E
      *
      *=========================================================================
      *  Return the Tools/400 default memory manager implementation.
      *=========================================================================
      *  Parameters:
      *
      *  Returns:
      *   memMgr        - The default memory manager.
      *=========================================================================
     P MemoryManager_getDefaultManager...
     P                 B                   export
      *
     D MemoryManager_getDefaultManager...
     D                 PI                        likeds(MemoryManager_manager_t)
      *
      *  Return value
     D memMgr          DS                  likeds(MemoryManager_manager_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         memMgr.pAllocate   = %paddr('BASICS1R8_MemoryManager_allocate');
         memMgr.pReallocate = %paddr('BASICS1R8_MemoryManager_reallocate');
         memMgr.pFree       = %paddr('BASICS1R8_MemoryManager_free');

         return memMgr;

      /END-FREE
      *
     P MemoryManager_getDefaultManager...
     P                 E
      *
      *=========================================================================
      *  Reserve Storage Block
      *=========================================================================
      *  Parameters:
      *   i_size        - The size, in bytes, of the desired memory allocation.
      *
      *  Returns:
      *   pMemory       - The reserved storage block.
      *=========================================================================
     P MemoryManager_allocate...
     P                 B                   export
      *
     D MemoryManager_allocate...
     D                 PI              *
     D  i_size                       10U 0 value
     D  i_heapID                     10I 0 value  options(*nopass)
      *
      *  Return value
     D pMemory         S               *   inz
      *
      *  Parameter positions
     D p_heapID        C                   const(2)
      *
      *  Optional parameter fields
     D heapID          S                   like(i_heapID ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_heapID);
            heapID = i_heapID;
         else;
            heapID = 0;
         endif;

         select;
         when (heapID = -1);
            // TODO: allocate teraspace memory
         when (heapID > 0);
            CEEGTST(heapID: i_size: pMemory: *omit);
         other;
            pMemory = malloc(i_size);
         endsl;

         if (pMemory <> *NULL);
            g_mmStatus.numAlloc = g_mmStatus.numAlloc + 1;
         endif;

         return pMemory;

      /END-FREE
      *
     P MemoryManager_allocate...
     P                 E
      *
      *=========================================================================
      *  Change Reserved Storage Block Size
      *=========================================================================
      *  Parameters:
      *   i_pMem        - Address of a previously allocated memory block.
      *   i_size        - The number of bytes of storage to be allocated for
      *                   the new storage block.
      *
      *  Returns:
      *   pMemory       - The reserved storage block.
      *=========================================================================
     P MemoryManager_reallocate...
     P                 B                   export
      *
     D MemoryManager_reallocate...
     D                 PI              *
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  Return value
     D pMemory         S               *   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pMemory = realloc(i_pMem: i_size);

         return pMemory;

      /END-FREE
      *
     P MemoryManager_reallocate...
     P                 E
      *
      *=========================================================================
      *  Release Storage Blocks
      *=========================================================================
      *  Parameters:
      *   io_pMem       - A previously allocated storage block.
      *
      *  Returns:
      *   void
      *=========================================================================
     P MemoryManager_free...
     P                 B                   export
      *
     D MemoryManager_free...
     D                 PI
     D  io_pMem                        *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(io_pMem <> *NULL);

         free(io_pMem);
         io_pMem = *NULL;

         g_mmStatus.numAlloc = g_mmStatus.numAlloc - 1;

         return;

      /END-FREE
      *
     P MemoryManager_free...
     P                 E
      *
      *=========================================================================
      *  Creates a new heap
      *=========================================================================
      *  Parameters:
      *   i_initialSize - The initial amount of storage, in bytes, allocated
      *                   for the new heap.
      *   i_increment   - The number of bytes by which the heap is extended
      *                   when it is necessary to enlarge the heap to satisfy
      *                   an allocation request.
      *   i_allocStrat  - The allocation strategy used.
      *
      *  Returns:
      *   headID        - The heap identifier of the created heap.
      *=========================================================================
     P MemoryManager_createHeap...
     P                 B                   export
      *
     D MemoryManager_createHeap...
     D                 PI            10I 0
     D  i_initialSize                10I 0 const  options(*nopass: *omit)
     D  i_increment                  10I 0 const  options(*nopass: *omit)
     D  i_allocStrat                 10I 0 const  options(*nopass: *omit)
      *
      *  Return value
     D heapID          S             10I 0 inz
      *
      *  Parameter positions
     D p_initialSize   C                   1
     D p_increment     C                   2
     D p_allocStrat    C                   3
      *
      *  Fields for optional parameters
     D initialSize     S                   like(i_initialSize) inz
     D increment       S                   like(i_increment  ) inz
     D allocStrat      S                   like(i_allocStrat ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_initialSize and %addr(i_initialSize) <> *NULL);
            initialSize = i_initialSize;
         else;
            initialSize = 0;
         endif;

         if (%parms() >= p_increment and %addr(i_increment) <> *NULL);
            increment = i_increment;
         else;
            increment = 0;
         endif;

         if (%parms() >= p_allocStrat and %addr(i_allocStrat) <> *NULL);
            allocStrat = i_allocStrat;
         else;
            allocStrat = 0;
         endif;

         CEECRHP(heapID: initialSize: increment: allocStrat: *omit);

         return heapID;

      /END-FREE
      *
     P MemoryManager_createHeap...
     P                 E
      *
      *=========================================================================
      *  Deletes an existing heap.
      *=========================================================================
      *  Parameters:
      *   io_heapID     - The heap identifier of the heap to be deleted.
      *
      *  Returns:
      *   void
      *=========================================================================
     P MemoryManager_deleteHeap...
     P                 B                   export
      *
     D MemoryManager_deleteHeap...
     D                 PI
     D  io_heapID                    10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         CEEDSHP(io_heapID: *omit);
         io_heapID = 0;

         return;

      /END-FREE
      *
     P MemoryManager_deleteHeap...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing BASICS1R9  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "BASICS1R9 "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Display Information      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  BASICS1R9  - SrvPgm: Basic Routines - Display Information          *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  22.06.2005                                              *
      *  E-mail  :  thomas.raddatz@tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Datum       Name          nderung                                 *
      *  ----------  ------------  ---------------------------------------  *
      *  23.01.2009  Th.Raddatz    Renamed f_getDisplayMode() to            *
      *                            Display_getMode().                       *
      *                            Added Display_supportsDS4().             *
      *                                                                     *
      *  26.01.2009  Th.Raddatz    Added Display_getRows() and              *
      *                            Display_getColumns().                    *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *                                                                     *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                      *
      *                              SRCFILE(&SL/&SF) +                     *
      *                              SRCMBR(&SM);                           *
      *                                                                     *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V6R1M0);                                      *
      *     >>END-COMPILE<<                                                 *
      *                                                                     *
      *     >>EXECUTE<<                                                     *
      *                                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN BNDDIR('QSNAPI')
      *  Standard H-Specs
      /COPY QBASICS1,H_SPEC
      /COPY QBASICS1,COPYRIGHT
      *=====================================================================*
      *
      * -----------------------------------------
      *  Exported functions
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R9
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      /COPY QBASICS1,BASICS1R0
      *
      * -----------------------------------------
      *  Private prototypes
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      *  Retrieve Display Mode       Return value: Display Mode
     D QsnRtvMod...
     D                 PR             1A          extproc('QsnRtvMod')
     D  o_dspMode                     1A          options(*omit)
     D  i_hLowLvlEnv                 10I 0 const  options(*omit)
     D  io_errCode                32767A          options(*omit: *varsize)
      *
      *  Query 5250 (QsnQry5250) API Return value: return code 0=succes, -1=error
     D QsnQry5250...
     D                 PR            10I 0        extproc('QsnQry5250')
     D  o_rcvVar                  32767A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  io_errCode                32767A          options(*omit: *varsize)
      *
      *  Data structure of QsnQry5250 API.
     D QSN_Q5250_t     DS                  based(pDummy)  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  qrySts                 9      9A
     D  wrksCtlUnit           10     11I 0
     D  codeLevel             12     14A
     D  reserved_1            15     30A
     D  wrksTypCde            31     31A
     D  mschnTypCde           32     35A
     D  mdlNbr                36     38A
     D  kbd_ID                39     39A
     D  extKbd_ID             40     40A
     D  PC_kbd_ID             41     41A
     D  srlNbr                42     45A
     D  maxInpFlds            46     47I 0
     D  ctlUnitCust           49     50A
     D  reserved_2            51     51A
     D  devCpblts             51     62A
     D   devCpblts_0                  1A   overlay(devCpblts)
     D   devCpblts_1                  1A   overlay(devCpblts: *next)
     D   devCpblts_2                  1A   overlay(devCpblts: *next)
     D   devCpblts_3                  1A   overlay(devCpblts: *next)
     D   devCpblts_4                  1A   overlay(devCpblts: *next)
     D   devCpblts_5                  1A   overlay(devCpblts: *next)
     D   devCpblts_6                  1A   overlay(devCpblts: *next)
     D   devCpblts_7                  1A   overlay(devCpblts: *next)
     D   devCpblts_8                  1A   overlay(devCpblts: *next)
     D   devCpblts_9                  1A   overlay(devCpblts: *next)
     D   devCpblts_10                 1A   overlay(devCpblts: *next)
     D   devCpblts_11                 1A   overlay(devCpblts: *next)
     D  gridBufs              63     63A
     D  typGrdLnSup           64     64A
     D  reserved_3            65     65A
     D  imgFax                66     66A
     D  imgFaxScl             67     67A
     D  imgFaxRtg             68     68A
     D  imgFaxSpt             69     69A
     D  invTags               70     70A
     D  reserved_4            71     72A
      *
      * -----------------------------------------
      *  Global constants
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Global fields
      * -----------------------------------------
      *
      *=========================================================================
      *  Returns the current display mode.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   dspMode       - Current display mode:
      *                   cDISPLAY_MODE_DS3   24x80
      *                   cDISPLAY_MODE_DS4   27x132
      *=========================================================================
     P Display_getMode...
     P                 B                   export
      *
     D Display_getMode...
     D                 PI                         like(display_mode_t)
      *
      *  Return value
     D dspMode         S                   like(display_mode_t) inz
      *
      *  Local fields
     D dspModeRaw      S              1A                        inz
     D errCode         DS                  likeds(errCode_t   ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear errCode;
         QsnRtvMod(dspModeRaw: *omit: errCode);

         if dspModeRaw = '3';
            dspMode = cDISPLAY_MODE_DS3;
         else;
            dspMode = cDISPLAY_MODE_DS4;
         endif;

         return dspMode;

      /END-FREE
      *
     P Display_getMode...
     P                 E
      *
      *=========================================================================
      *  Returns cTrue if the display device support 27x132 mode.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   isDS4         - cTrue if the device support 27x132 mode, else cFalse.
      *=========================================================================
     P Display_supportsDS4...
     P                 B                   export
      *
     D Display_supportsDS4...
     D                 PI              N
      *
      *  Return value
     D isDS4           S               N   inz(cFalse)
      *
      *  Local fields
     D rc              S             10I 0 inz
     D QSN_Q5250       DS                  likeds(QSN_Q5250_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         rc = QsnQry5250(QSN_Q5250: %size(QSN_Q5250): *omit);
         if (%bitand(QSN_Q5250.devCpblts_1: x'20') = x'20');
            isDS4 = cTrue;
         else;
            isDS4 = cFalse;
         endif;

         return isDS4;

      /END-FREE
      *
     P Display_supportsDS4...
     P                 E
      *
      *=========================================================================
      *  Returns cTrue if the display device supports GUI characters.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   isGUI         - cTrue if the device support GUI characters,
      *                   else cFalse.
      *=========================================================================
     P Display_supportsGUI...
     P                 B                   export
      *
     D Display_supportsGUI...
     D                 PI              N
      *
      *  Return value
     D isGUI           S               N   inz(cFalse)
      *
      *  Local fields
     D rc              S             10I 0 inz
     D QSN_Q5250       DS                  likeds(QSN_Q5250_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         rc = QsnQry5250(QSN_Q5250: %size(QSN_Q5250): *omit);
         if (%bitand(QSN_Q5250.devCpblts_4: x'04') = x'04');
            isGUI = cTrue;
         else;
            isGUI = cFalse;
         endif;

         return isGUI;

      /END-FREE
      *
     P Display_supportsGUI...
     P                 E
      *
      *=========================================================================
      *  Returns the number of rows that can be displayed on the screen.
      *=========================================================================
      *  Parameters:
      *   dspMode       - Display mode.
      *                   Default: current display mode
      *                   cDISPLAY_MODE_DS3   24x80
      *                   cDISPLAY_MODE_DS4   27x132
      *
      *  Returns:
      *   rows          - Number of rows that can be displayed.
      *=========================================================================
     P Display_getRows...
     P                 B                   export
      *
     D Display_getRows...
     D                 PI             5I 0
     D  i_dspMode                          const  like(display_mode_t)
     D                                            options(*nopass)
      *
      *  Parameter positions
     D p_dspMode       C                   1
      *
      *  Fields for optional parameters
     D dspMode         S                   like(i_dspMode ) inz
      *
      *  Return value
     D rows            S              5I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_dspMode);
            dspMode = i_dspMode;
         else;
            dspMode = Display_getMode();
         endif;

         if (dspMode = cDISPLAY_MODE_DS3);
            rows = 24;
         else;
            rows = 27;
         endif;

         return rows;

      /END-FREE
      *
     P Display_getRows...
     P                 E
      *
      *=========================================================================
      *  Returns the number of columns that can be displayed on the screen.
      *=========================================================================
      *  Parameters:
      *   dspMode       - Display mode.
      *                   Default: current display mode
      *                   cDISPLAY_MODE_DS3   24x80
      *                   cDISPLAY_MODE_DS4   27x132
      *
      *  Returns:
      *   columns       - Number of columns that can be displayed.
      *=========================================================================
     P Display_getColumns...
     P                 B                   export
      *
     D Display_getColumns...
     D                 PI             5I 0
     D  i_dspMode                          const  like(display_mode_t)
     D                                            options(*nopass)
      *
      *  Parameter positions
     D p_dspMode       C                   1
      *
      *  Fields for optional parameters
     D dspMode         S                   like(i_dspMode ) inz
      *
      *  Return value
     D columns         S              5I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_dspMode);
            dspMode = i_dspMode;
         else;
            dspMode = Display_getMode();
         endif;

         if (dspMode = cDISPLAY_MODE_DS3);
            columns = 80;
         else;
            columns = 132;
         endif;

         return columns;

      /END-FREE
      *
     P Display_getColumns...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing CEELIB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "CEELIB    "
mbrtype =  "RPGLE     "
mbrtext =  "Prototypes of CEE APIs                   (include)"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(CEELIB)
 DEF  /DEFINE CEELIB
      *
      * ---------------------------------------------------------------
      *   Program or Procedure Call APIs
      * ---------------------------------------------------------------
      *
      *  Condition token, used as feedback code
     D cee_fc_t        DS                  qualified               based(pDummy)
     D  Condition_ID...
     D                         1      4A
     D   MsgSev                1      2I 0
     D   Msg_No                3      4U 0
     D  Flags                  5      5A
     D  Facility_ID...
     D                         6      8A
     D  I_S_Info               9     12A
      *
      *  Retrieve Operational Descriptor Information (CEEDOD)
     D CEEDOD...
     D                 PR
     D                                            extproc('CEEDOD')
     D  i_posn                       10I 0 const
     D  o_desctype                   10I 0
     D  o_datatype                   10I 0
     D  o_descinf1                   10I 0
     D  o_descinf2                   10I 0
     D  o_datalen                    10I 0
     D  o_fc                         12A          options(*omit   )
      *
      *  Reference fields for CEEDOD API
     D descInf_t       DS                  based(pDummy)   qualified
     D  desctype                     10I 0
     D  datatype                     10I 0
     D  descinf1                     10I 0
     D  descinf2                     10I 0
     D  datalen                      10I 0
      *
      *  Test for Omitted Argument (CEETSTA) API
     D CEETSTA...
     D                 PR
     D                                            extproc('CEETSTA')
     D  io_isPresent                 10I 0
     D  i_argNum                     10I 0 const
     D  o_fc                         12A          options(*omit   )
      *
      *  Get String Information (CEEGSI) API
     D CEEGSI...
     D                 PR
     D                                            extproc('CEEGSI')
     D  i_posn                       10I 0 const
     D  o_datatype                   10I 0
     D  o_curlen                     10I 0
     D  o_maxlen                     10I 0
     D  o_fb                         12A          options(*omit   )
      *
      *  Reference fields for CEEGSI API
     D strInf_t        DS                  based(pDummy)   qualified
     D  datatype                     10I 0
     D  curlen                       10I 0
     D  maxlen                       10I 0
      *
      * ---------------------------------------------------------------
      *   Math APIs
      * ---------------------------------------------------------------
      *
      *  Logarithm base 10 (double float)
     D CEESDLG1...
     D                 PR                  extproc('CEESDLG1')
     D  i_value                       8F   const
     D  o_result                      8F
      *
      * ---------------------------------------------------------------
      *   ILE CEE Date and Time APIs
      * ---------------------------------------------------------------
      *
      *  Calculate Day of Week from Lilian Date (CEEDYWK) API
     D CEEDYWK         PR                  opdesc extproc('CEEDYWK')
     D   lilian_date                 10I 0 const
     D   day_no                      10I 0
     D   feedback                    12A   options(*omit)
      *
      *  Convert Lilian Date to Character Format (CEEDATE) API
     D CEEDATE         PR                  opdesc extproc('CEEDATE')
     D   lilian_date                 10I 0 const
     D   date_format                 80A   const options(*varsize)
     D   char_date                   80A   options(*varsize)
     D   feedback                    12A   options(*omit)
      *
      *  Convert Date to Lilian Format (CEEDAYS) API
     D CEEDAYS         PR                  opdesc extproc('CEEDAYS')
     D   char_date                   80A   const options(*varsize)
     D   date_format                 80A   const options(*varsize)
     D   lilian_date                 10I 0
     D   feedback                    12A   options(*omit)
      *
      *  Convert Seconds to Character Timestamp (CEEDATM) API
     D CEEDATM         PR                  opdesc extproc('CEEDATM')
     D  input_seconds                 8F   const
     D  picture_string...
     D                               80A   const options(*varsize)
     D  output_timestamp...
     D                               80A         options(*varsize)
     D   feedback                    12A   options(*omit)
      *
      *  Get Offset from Universal Time Coordinated to Local Time (CEEUTCO) API
     D CEEUTCO         pr                  extproc('CEEUTCO')
     D  offsethours                  10i 0
     D  offsetminutes                10i 0
     D  offsetseconds                 8f
     D  feedback                     12a   options(*nopass)
      *
     D cee_utco_t      ds                  qualified   based(pDummy)
     D  offhours                     10i 0
     D  offmins                      10i 0
     D  offsecs                       8f
      *
      *  Convert Timestamp to Number of Seconds (CEESECS) API
     D CEESECS         pr                  extproc('CEESECS') opdesc
     D  inTimestamp                 255a   const options(*varsize)
     D  inPicture                   255a   const options(*varsize)
     D  outSeconds                    8f
     D  outFC                        12a         options(*omit)
      *
      * ---------------------------------------------------------------
      *   Activation Group and Control Flow APIs
      * ---------------------------------------------------------------
      *
      *  Register Activation Group Exit Procedure (CEE4RAGE) API
     D CEE4RAGE...
     D                 PR                  extproc('CEE4RAGE')
     D  i_pProc                        *   const procptr
     D   fc                          12A         options(*OMIT)
      *
     D END_ACTGRP_CODE_EXCEPTION_MESSAGE...
     D                 C                   x'40000000'
     D END_ACTGRP_CODE_ABNORMAL_END...
     D                 C                   x'00008000'
     D END_ACTGRP_CODE_ACTGRP_IS_ENDING...
     D                 C                   x'00004000'
     D END_ACTGRP_CODE_INIT_BY_RCLACTGRP...
     D                 C                   x'00002000'
     D END_ACTGRP_CODE_INIT_BY_JOB_END...
     D                 C                   x'00001000'
     D END_ACTGRP_CODE_INIT_BY_EXIT_VERB...
     D                 C                   x'00000800'
     D END_ACTGRP_CODE_INIT_BY_FUNCTION_CHECK...
     D                 C                   x'00000400'
     D END_ACTGRP_CODE_INIT_BY_OUT_OF_SCOPE_JUMP...
     D                 C                   x'00000200'
      *
     D CEE4RAGE_user_exit...
     D                 PR                         extproc('CEE4RAGE_user_exit')
     D  i_ag_mark                    10U 0 const
     D  i_reason                     10U 0 const
     D  io_result_code...
     D                               10U 0 const
     D  io_user_rc                   10I 0 const
      *
      *  Register Call Stack Entry Termination User Exit Procedure (CEERTX)
     D CEERTX...
     D                 PR                         extproc('CEERTX')
     D  i_procPtr                      *   const  procptr
     D  i_rtxToken                     *   const  options(*omit)
     D  o_fc                         12A          options(*omit)
      *
     D CEERTX_user_exit...
     D                 PR                         extproc('CEERTX_user_exit')
     D  i_rtxToken                     *   const
      *
      *  Unregister Call Stack Entry Termination User Exit Procedure (CEEUTX)
     D CEEUTX...
     D                 PR                         extproc('CEEUTX')
     D  i_procPtr                      *   const  procptr
     D  o_fc                         12A          options(*omit)
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing CLIB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "CLIB      "
mbrtype =  "RPGLE     "
mbrtext =  "Prototypes of C-Library                  (include)"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(CLIB)
 DEF  /DEFINE CLIB
      *
      *  Basic C data types
      /IF NOT DEFINED(C_DATA_TYPES)
      /DEFINE C_DATA_TYPES
      * C Data Types
     D char_t          S              1A   based(pDummy)
     D short_t         S              5I 0 based(pDummy)
     D ushort_t        S              5U 0 based(pDummy)
     D int_t           S             10I 0 based(pDummy)
     D uint_t          S             10U 0 based(pDummy)
     D long_t          S             10I 0 based(pDummy)
     D ulong_t         S             10U 0 based(pDummy)
     D float_t         S              4F   based(pDummy)
     D double_t        S              8F   based(pDummy)
      /ENDIF
      *
      *  stdin, stdout and stderr
     D stdin           S               *   import('_C_IFS_stdin')
     D stdout          S               *   import('_C_IFS_stdout')
     D stderr          S               *   import('_C_IFS_stderr')
      *
      *  system -- Execute a Command
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     0                  the command is successful
      *     -1                 for a NULL pointer
      *     1                  the command fails
     D system          PR            10I 0 extproc('system')
     D  i_clCommand                    *   value options(*string)
      *
     D EXCP_MSGID      S              7A   import('_EXCP_MSGID')
      *
      *  time -- Determine Current Time
      *     The time() function returns the current calendar time.
      *     The return value is also stored in the location that
      *     is given by timeptr.
     D time...
     D                 PR            10i 0 extproc('time')
     D  timeptr                        *   value
      *
      *  strftime -- Convert to Formatted Time
      *     strftime() returns the number of bytes placed into the
      *     array pointed to by 'dest'.
     D strftime...
     D                 PR            10i 0 extproc('strftime')
     D  dest                           *   value
     D  maxsize                      10i 0 value
     D  format                         *   value options(*string)
     D  timeptr                            const  likeds(tm_t)
      *
     D tm_t            DS                  qualified  based(pDummy)
     D  tm_sec                       10I 0
     D  tm_min                       10I 0
     D  tm_hour                      10I 0
     D  tm_mday                      10I 0
     D  tm_mon                       10I 0
     D  tm_year                      10I 0
     D  tm_wday                      10I 0
     D  tm_yday                      10I 0
     D  tm_isdst                     10I 0
      *
      *  localtime() -- Correct Local Time, returns tm_t*
      *     The localtime() function converts a time value, in
      *     seconds, to a structure of type tm.
     D localtime...
     D                 PR              *   extproc('localtime')
     D  time                         10I 0 const
      *
      *  localtime_r() -- Correct Local Time
      *     It is the same as localtime() except that it passes
      *     in the place to store the returned structure result.
     D localtime_r...
     D                 PR              *   extproc('localtime_r')
     D  time                         10I 0 const
     D  tm                                 const  likeds(tm_t)
      *
      *  strtok -- Tokenize String
      *     The first time the strtok() function is called, it returns
      *     a pointer to the first token in i_string. In later calls
      *     it returns a pointer to the next token. A null pointer is
      *     returned when there are no more tokens.
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_delimiters                   *   value  options(*string)
      *
      *  atoi -- Convert Character String to Integer
      *     The atoi() function returns an int value of the
      *     interpreted input string.
     D atoi            PR            10I 0        extproc('atoi')
     D  i_string                       *   value  options(*string)
      *
      *  memcpy -- Copy Bytes
      *     The behavior is undefined if copying takes place
      *     between objects that overlap.
      *     The memcpy() function returns a pointer to dest.
     D memcpy          PR              *          extproc('memcpy')
     D  i_pDest                        *   value
     D  i_pSrc                         *   value
     D  i_count                      10U 0 value
      *
      *  memset -- Set Bytes to Value
      *     The memset() function returns a pointer to dest.
     D memset          PR              *          extproc('memset')
     D  i_pDest                        *   value
     D  i_char                       10I 0 value
     D  i_count                      10U 0 value
      *
      *  memmove -- Copy Bytes
      *     memmove allows copying between objects that may overlap
      *     as if src is first copied into a temporary array.
      *     The memmove() function returns a pointer to dest.
     D memmove         PR              *          extproc('memmove')
     D  pMemDest                       *   value
     D  pMemSrc                        *   value
     D  memSize                            value like(size_t)
      *
      *  memcmp -- Compare Buffers
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        buf1 less than buf2
      *     0                  buf1 identical to buf2
      *     Greater than 0     buf1 greater than buf2
     D memcmp          PR            10I 0        extproc('memcmp')
     D  pBuf1                          *   value
     D  pBuf2                          *   value
     D  count                              value like(size_t)
      *
      *  memicmp -- Compare Bytes (ignore case)
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        buf1 less than buf2
      *     0                  buf1 identical to buf2
      *     Greater than 0     buf1 greater than buf2
     D memicmp         PR            10I 0        extproc('__memicmp')
     D  pBuf1                          *   value
     D  pBuf2                          *   value
     D  count                        10U 0 value
      *
      *  strcmp() -- Compare Strings
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        string 1 less than string 2
      *     0                  string 1 equivalent to string 2
      *     Greater than 0     string 1 greater than string 2
     D strcmp...
     D                 PR            10I 0
     D                                            extproc('strcmp')
     D  string1                        *   value  options(*string)
     D  string2                        *   value  options(*string)
      *
      *  strcasecmp() -- Compare Strings without Case Sensitivity
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        string 1 less than string 2
      *     0                  string 1 equivalent to string 2
      *     Greater than 0     string 1 greater than string 2
     D strcasecmp...
     D                 PR            10I 0
     D                                            extproc('strcasecmp')
     D  string1                        *   value  options(*string)
     D  string2                        *   value  options(*string)
      /IF NOT DEFINED(TESTPTR)
      /DEFINE TESTPTR
      *
      *  Test Pointer (TESTPTR)
     D testptr         PR            10I 0 extproc('_TESTPTR')
     D  i_ptr                          *   value
     D  i_test_type                  10I 0 value
      *
     D cTESTPTR_TYPE_PROCPTR...
     D                 C                   0
     D cTESTPTR_NO_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   0
     D cTESTPTR_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   1
      *
     D cTESTPTR_TYPE_MEMPTR...
     D                 C                   1
     D cTESTPTR_NON_TERASPACE...
     D                 C                   0
     D cTESTPTR_TERASPACE...
     D                 C                   1
      *
     D cTESTPTR_ERROR_NOT_EXIST...
     D                 C                   x'2401'
     D cTESTPTR_ERROR_INVALID...
     D                 C                   x'2402'
     D cTESTPTR_ERROR_OBJECT_DESTROYED...
     D                 C                   x'2202'
      /ENDIF
      *
      *  malloc() - Reserve Storage Block
     D TS_malloc...
     D                 PR              *   extproc('_C_TS_malloc')
     D  i_size                       10U 0 value
      *
      *  realloc() - Change Reserved Storage Block Size
     D TS_realloc...
     D                 PR              *   extproc('_C_TS_realloc')
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  free() - Release Storage Blocks
     D TS_free...
     D                 PR                  extproc('_C_TS_free')
     D  i_pMem                         *   value
      *
      *  _C_TS_malloc_info() - Determine amount of teraspace memory used
     D TS_malloc_info...
     D                 PR            10I 0 extproc('_C_TS_malloc_info')
     D  o_c_mallinfo                       const  likeds(C_mallinfo_t)
     D  i_size                       10U 0 value
      *
      *  _C_TS_malloc_debug() - Determine amount of teraspace memory
      *                         used (with optional dumps and verification)
     D TS_malloc_debug...
     D                 PR            10I 0 extproc('_C_TS_malloc_debug')
     D  i_dump_level                 10U 0 value
     D  i_vrfy_level                 10U 0 value
     D  o_c_mallinfo                       const  likeds(C_mallinfo_t)
     D  i_size                       10U 0 value
      *
      * The following are possible values for the dump_level parameter
     D C_NO_DUMPS      C                   0
      *  Dumps the _C_mallinfo_t structure:
     D C_DUMP_TOTALS   C                   1
      *  Does a hex dump of all allocated chunks of teraspace storage,
      *  this is the entire 512K chunk of storage:
     D C_DUMP_CHUNKS   C                   2
      *  Dumps each of the allocated nodes.
      *  There is a node for each malloc performed with the header
      *  associated with that malloc:
     D C_DUMP_NODES    C                   3
      *  Dumps the cartesian tree used to keep track of the freed nodes:
     D C_DUMP_TREE     C                   4
     D C_DUMP_ALL      C                   9999
      *
      *  The following are possible values for the verify_level parameter
     D C_NO_CHECKS     C                   0
     D C_CHECK_TOTALS  C                   1
     D C_CHECK_CHUNKS  C                   2
     D C_CHECK_NODES   C                   3
     D C_CHECK_TREE    C                   4
     D C_CHECK_ALL     C                   9998
      *  Will call abort() if verification fails
     D C_CHECK_ALL_AND_ABORT...
     D                 C                   9999
      *
      * The following structure is used to return information
      * from the _C_TS_malloc_info routine.  The fields are:
      *   total_bytes        - bytes allocated from system
      *                        (high water mark)
      *   allocated_bytes    - number of allocated bytes
      *   unallocated_bytes  - number of unallocated bytes
      *   allocated_blocks   - number of allocated blocks
      *   unallocated_blocks - number of unallocated blocks
      *   requested_bytes    - bytes actually requested from malloc
      *   pad_bytes          - bytes used to pad allocation length
      *                        to a multiple of 16
      *   overhead_bytes     - bytes used for malloc overhead
     D C_mallinfo_t...
     D                 DS                  qualified               based(pDummy)
     D  total_bytes...
     D                               20I 0
     D  allocated_bytes...
     D                               20I 0
     D  unallocated_bytes...
     D                               20I 0
     D  allocated_blocks...
     D                               20I 0
     D  unallocated_blocks...
     D                               20I 0
     D  requested_bytes...
     D                               20I 0
     D  pad_bytes...
     D                               20I 0
     D  overhead_bytes...
     D                               20I 0
      *
      *  malloc -- Reserve Storage Block
     D malloc          PR              *          extproc('malloc')
     D  i_size                       10U 0 value
      *
      *  realloc -- Change Reserved Storage Block Size
     D realloc         PR              *          extproc('realloc')
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  free -- Release Storage Blocks
     D free            PR                         extproc('free')
     D  i_pMem                         *   value
      *
      *  srand -- Set Seed for rand Function   e.g.:   srand(getSeed(*null))
     D srand           PR                         extproc('srand')
     D  i_seed                       10U 0 value
      *
      *  rand -- Generate Random Number                x = rand()
     D rand            PR            10I 0        extproc('rand')
      *
     D RAND_MAX        C                   const(32767)
      *
      *  getSeed -- Get Seed for srand function
     D getSeed         PR            10I 0        extproc('time')
     D  i_timePtr                      *   value
      *
      *  strlen -- Determine String Length
     D strlen...
     D                 PR            10U 0 extproc('strlen')
     D  i_string                       *   value
      *
      *  tmpnam -- Produce Temporary File Name
     D tmpnam          PR              *          extproc('tmpnam')
     D  pTmpNme                        *   value
      *
      *  _C_IFS_tmpnam -- Produce Temporary File Name for the IFS file system
     D ifs_tmpnam      PR              *          extproc('_C_IFS_tmpnam')
     D  fileName                       *   value
      *
     D L_tmpnam        C                   const(39)                            ! <stdio.h>
      *
     D TMP_MAX         C                   const(32767)                         ! <stdio.h>
      *
      *  qsort -- Sort Array
     D qsort           PR              *                       extproc('qsort')
     D  memPtr                         *   value
     D  numElem                            value  like(size_t)
     D  width                              value  like(size_t)
     D  pSortFunc                      *   value  procptr
      *
      *  bsearch -- Search Arrays
     D bsearch         PR              *          extproc('bsearch')
     D  keyPtr                         *   value
     D  memPtr                         *   value
     D  numElem                            value  like(size_t)
     D  width                              value  like(size_t)
     D  pSearchFnc                     *   value  procptr
      *
      *  iconv_open()--Code Conversion Allocation API
     D iconv_open...
     D                 PR                  extproc('iconv_open')
     D                                     like(iconv_t   )
     D  i_toCode                       *   value
     D  i_fromCode                     *   value
      *
     D iconv_t         DS                  qualified   based(pDummy)   align
     D  return_value                 10I 0
     D  cd                           10I 0 dim(12)
      *
     D iconv_fromcode_t...
     D                 DS                  qualified   based(pDummy)
     D  ibmccsid                      8A
     D  ccsid                         5A
     D  convAlt                       3A
     D  substAlt                      1A
     D  shiftStateAlt                 1A
     D  inpLengthOpt                  1A
     D  errOption                     1A
     D  reserved                     12A
      *
     D iconv_tocode_t...
     D                 DS                  qualified   based(pDummy)
     D  ibmccsid                      8A
     D  ccsid                         5A
     D  reserved                     19A
      *
      *  QtqIconvOpen()--Code Conversion Allocation API
     D QtqIconv_open...
     D                 PR                  extproc('QtqIconvOpen')
     D                                     likeds(iconv_t )
     D  i_toCode                           const  likeds(QtqCode_t)
     D  i_fromCode                         const  likeds(QtqCode_t)
      *
     D QtqCode_t...
     D                 DS                  qualified   based(pDummy)
     D  ccsid                        10I 0
     D  conversionA                  10I 0
     D  substitutionA                10I 0
     D  shiftStateA                  10I 0
     D  inpLenOpt                    10I 0
     D  errOptMxdDta                 10I 0
     D  reserved                     12A
      *
      *  iconv()--Code Conversion API
     D iconv...
     D                 PR            10U 0        extproc('iconv')
     D  i_cd                               value likeds(iconv_t  )
     D  i_pInBuf                       *
     D  i_inBytLeft                  10U 0
     D  i_pOutBuf                      *
     D  i_outBytLeft                 10U 0
      *
     D cICONV_ERROR    C                   const(4294967295)
      *
      *  iconv_close()--Code Conversion Deallocation API
     D iconv_close...
     D                 PR            10I 0        extproc('iconv_close')
     D  i_cd                               value likeds(iconv_t  )
      *
      *  0/-1 = stat()--Get File Information                include <sys/stat.h>
     D stat...
     D                 PR            10I 0        extproc('stat')               = int
     D  i_pPath                        *   value options(*string)               = *path
     D  i_pStat                        *   value                                = *buf
      *
      *  0/-1 = fstat()--Get File Information by Descriptor include <sys/stat.h>
     D fstat...
     D                 PR            10I 0        extproc('fstat')              = int
     D  i_fd                         10I 0 value                                = int
     D  i_stat                             const likeds(st_stat_t)              = *buf
      *
      *  0/-1 = lstat()--Get File or Link Information       include <sys/stat.h>
     D lstat...
     D                 PR            10I 0        extproc('lstat')              = int
     D  i_pPath                        *   value options(*string)               = *path
     D  i_pStat                        *   value                                = *buf
      *
     D st_stat_t       DS                  qualified   based(pDummy)   align
     D  mode                         10U 0                                      mode_t =uint
     D  ino                          10U 0                                      ino_t  =uint
     D  nlink                         5U 0                                      nlink_t=ushort
     D  reserved2                     2A
     D  uid                          10U 0                                      uid_t  =uint
     D  gid                          10U 0                                      gid_t  =uint
     D  size                         10I 0                                      off_t  =int
     D  atime                        10I 0                                      time_t =long
     D  mtime                        10I 0                                      time_t =long
     D  ctime                        10I 0                                      time_t =long
     D  dev                          10U 0                                      dev_t  =uint
     D  blksize                      10U 0                                      size_t =uint
     D  allocsize                    10U 0                                      ulong
     D  objtype                      11A                                        qp0l_objtype_t
     D  reserved3                     1A
     D  codepage                      5U 0                                      ushort
     D  ccsid                         5U 0                                      ushort
     D  rdev                         10U 0                                      dev_t  =uint
     D  nlink32                      10U 0                                      nlink32_t=ulng
     D  rdev64                       20U 0                                      dev64_t=ullng
     D  dev64                        20U 0                                      dev64_t=ullng
     D  reserved1                    36A
     D  ino_gen_id                   10U 0                                      uint
      *
      *  Qp0lGetAttr()--Get Attributes
     D Qp0lGetAttr...
     D                 PR            10I 0 extproc('Qp0lGetAttr')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
     D  i_attrArray                        const  like(Qlg_attrArray_t  )
     D  i_pBuffer                      *   value
     D  i_bytPrv                     10U 0 value
     D  o_sizeNeeded                 10U 0
     D  o_bytRet                     10U 0
     D  i_followLnk                  10U 0 value
      *
      /if not defined(Qlg_Path_Name)
      /define Qlg_Path_Name
     D Qlg_Path_Name_t...
     D                 DS                  qualified align         based(pDummy)
     D   CCSID                       10I 0
     D   Country_ID                   2A
     D   Language_ID                  3A
     D   Reserved                     3A
     D   Path_Type                   10U 0
     D   Path_Length                 10I 0
     D   Path_Name_Delimiter...
     D                                2A
     D   Reserved2                   10A
     D   Path_Name                  256A
      *
     D QLG_PATH_JOB_CCSID...
     D                 C                   const(0)
     D QLG_PATH_JOB_COUNTRYID...
     D                 C                   const(X'0000')
     D QLG_PATH_JOB_LANGUAGEID...
     D                 C                   const(X'000000')
      *
      *  The Path_Name is a character string and the delimiter is one byte long.
     D QLG_CHAR_SINGLE...
     D                 C                   const(0)
      *
      *  The Path_Name is a pointer and the delimiter is one byte long.
     D QLG_PTR_SINGLE...
     D                 C                   const(1)
      *
      *  The Path_Name is a character string and the delimiter is two bytes long.
     D QLG_CHAR_DOUBLE...
     D                 C                   const(2)
      *
      *  The Path_Name is a pointer and the delimiter is two bytes long.
     D QLG_PTR_DOUBLE...
     D                 C                   const(3)
      *
      /endif
      *
     D Qlg_attrArray_t...
     D                 DS                  qualified               based(pDummy)
     D  numE                         10I 0
     D  attr                         10I 0 dim(64)
      *
     D Qlg_rtnAttr_t...
     D                 DS                  qualified               based(pDummy)
     D  ofsNextAttr                  10I 0
     D  ID                           10I 0
     D  size                         10I 0
     D  reserved                      4A
      *
     D QP0L_ATTR_OBJTYPE...
     D                 C                   const(0)                             CHAR(10)
     D QP0L_ATTR_DATA_SIZE...
     D                 C                   const(1)                             UINT(4)
     D QP0L_ATTR_ALLOC_SIZE...
     D                 C                   const(2)                             UINT(4)
     D QP0L_ATTR_EXTENDED_ATTR_SIZE...
     D                 C                   const(3)                             UINT(4)
     D QP0L_ATTR_CREATE_TIME...
     D                 C                   const(4)                             UINT(4)
     D QP0L_ATTR_ACCESS_TIME...
     D                 C                   const(5)                             UINT(4)
     D QP0L_ATTR_CHANGE_TIME...
     D                 C                   const(6)                             UINT(4)
     D QP0L_ATTR_MODIFY_TIME...
     D                 C                   const(7)                             UINT(4)
     D QP0L_ATTR_STG_FREE...
     D                 C                   const(8)                             CHAR(1)
     D QP0L_ATTR_CHECKED_OUT...
     D                 C                   const(9)                             chkOut Fmt
     D QP0L_ATTR_LOCAL_REMOTE...
     D                 C                   const(10)                            CHAR(1)
      *
     D QP0L_DONOT_FOLLOW_SYMLNK...
     D                 C                   const(x'00')
     D QP0L_FOLLOW_SYMLNK...
     D                 C                   const(x'01')
      *
     D QP0L_NOT_CHECKED_OUT...
     D                 C                   const(x'00')
     D QP0L_CHECKED_OUT...
     D                 C                   const(x'01')
      *
     D QP0L_LOCAL_OBJ...
     D                 C                   const(x'01')
     D QP0L_REMOTE_OBJ...
     D                 C                   const(x'02')
      *
      *  QlgGetcwd()--Get Current Directory (using NLS-enabled path name)
      *  Returns: Qlg_Path_Name_T
     D QlgGetcwd...
     D                 PR              *   extproc('QlgGetcwd')
     D  o_path                             const  likeds(Qlg_Path_Name_t)
     D  i_size                             value  like(size_t)
      *
      *  getcwd()--Get Current Directory
     D getcwd...
     D                 PR              *   extproc('getcwd')
     D  o_path                    65535A   const  options(*varsize)
     D  i_size                             value  like(size_t)
      *
      *  QlgChdir()--Change Current Directory (using NLS-enabled path name)
      *  Returns: Qlg_Path_Name_T
     D QlgChdir...
     D                 PR            10I 0 extproc('QlgChdir')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
      *
      *  chdir()--Change Current Directory
     D chdir...
     D                 PR            10I 0 extproc('chdir')
     D  i_path                         *   value  options(*string)
      *
      *  QSYSINC/SYS.TYPES
     D off_t           S             10I 0 based(pDummy)
     D size_t          S             10U 0 based(pDummy)
     D ssize_t         S             10I 0 based(pDummy)
     D time_t          S             10I 0 based(pDummy)
      *
      *  0/-1 = chmod()--Change File Authorizations         include <sys/stat.h>
     D chmod...
     D                 PR            10I 0        extproc('chmod')              = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_mode                       10U 0 value                                = mode_t =uint
      *
      *  mkdir()--Make Directory                            include <sys/stat.h>
     D mkdir...
     D                 PR            10I 0        extproc('mkdir')              = rc
     D  i_pPath                        *   value options(*string)               = *path
     D  i_mode                       10U 0 value                                = mode_t =uint
      *
      *  rmdir()--Remove Directory                          include <sys/stat.h>
     D rmdir...
     D                 PR            10I 0        extproc('rmdir')              = rc
     D  i_pPath                        *   value options(*string)               = *path
      *
      *  opendir()--Open Directory                          include <dirent.h>
     D opendir...
     D                 PR              *          extproc('opendir')            = *DIR
     D  i_pDirName                     *   value options(*string)               = *dirname
      *
      *  readdir()--Read Directory Entry
     D readdir...
     D                 PR              *          extproc('readdir')            = *dirent
     D  i_dirp                         *   value                                = *DIR
      *
     D dirent_t        DS                  qualified  based(pDummy)
     D   d_reserv1                   16A
     D   d_fileno_gen_id...
     D                               10U 0
     D   d_fileno                    10U 0
     D   d_reclen                    10U 0
     D   d_reserv3                   10I 0
     D   d_reserv4                    8A
      /if not defined(*V5R2M0)
     D   d_nlsinfo                         like(qlg_nls_t)
      /else
     D   d_nlsinfo                         likeds(qlg_nls_t)
      /endif
     D   d_namelen                   10U 0
     D   d_name                     640A
      *
     D qlg_nls_t       DS                  qualified  based(pDummy)    align
     D  ccsid                        10I 0
     D  country_id                    2A
     D  language_id                   3A
     D  nls_reserved                  3A
      *
      *  rewinddir()--Reset Directory Stream to Beginning
     D rewinddir...
     D                 PR                  extproc('rewinddir')
     D  i_dirp                         *   value                                = *DIR
      *
      *  closedir()--Close Directory
     D closedir...
     D                 PR            10I 0        extproc('closedir')           = rc
     D  i_dirp                         *   value                                = *DIR
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  <sys/stat.h>
     D S_IRUSR         C                   const(         256)                  ! Read For Own
     D S_IWUSR         C                   const(         128)                  ! Write For Ow
     D S_IXUSR         C                   const(          64)                  ! Exc/Srch For
     D S_IRWXU         C                   const(         448)                  ! Rd/Wrt/Exc O
      *
     D S_IRGRP         C                   const(          32)                  ! Read For Gro
     D S_IWGRP         C                   const(          16)                  ! Write For Gr
     D S_IXGRP         C                   const(           8)                  ! Exc/Srch For
     D S_IRWXG         C                   const(          56)                  ! Rd/Wrt/Exc G
      *
     D S_IROTH         C                   const(           4)                  ! Read For Oth
     D S_IWOTH         C                   const(           2)                  ! Write For Ot
     D S_IXOTH         C                   const(           1)                  ! Exc/Srch For
     D S_IRWXO         C                   const(           7)                  ! Rd/Wrt/Exc O
      *
     D S_ISUID         C                   const(        2048)
     D S_ISGID         C                   const(        1024)
     D S_ISVTX         C                   const(         512)
      *
      *  <h/fcntl.h>
     D O_CREAT         C                   const( 8)                            ! Append Mode
     D O_EXCL          C                   const(16)                            ! Exclusive Us
     D O_TRUNC         C                   const(64)                            ! Truncate Fla
      *
     D O_APPEND        C                   const(256)                           ! Append Mode
      *
     D O_CODEPAGE      C                   const(  8388608)                     ! Codepage Fla
     D O_TEXTDATA      C                   const( 16777216)                     ! Text Data Fl
     D O_FORCE_SCAN    C                   const( 67108864)                     ! Force scan
     D O_INHERITMODE   C                   const(134217728)                     ! Inherit Mode
     D O_CCSID         C                   const(       32)                     ! CCSID
     D O_TEXT_CREAT    C                   const( 33554432)                     !
      *
     D O_SHARE_RDONLY  C                   const( 65536)                        ! Shared Read
     D O_SHARE_WRONLY  C                   const(131072)                        ! Shared Write
     D O_SHARE_RDWR    C                   const(262144)                        ! Shared Rd/Wr
     D O_SHARE_NONE    C                   const(524288)                        ! No Share
      *
     D O_RDONLY        C                   const(1)                             ! Read Only
     D O_WRONLY        C                   const(2)                             ! Write Only
     D O_RDWR          C                   const(4)                             ! Read/Write
      *
      *  value/-1 = read()--Write from Descriptor           include <unistd.h>
     D read...
     D                 PR                  extproc('read')   like(ssize_t   )   = ssize_t
     D  i_fd                         10I 0 value                                = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_buflen                           value like(size_t    )               = size_t
      *
      *  value/-1 = write()--Write to Descriptor            include <unistd.h>
     D write...
     D                 PR                  extproc('write')  like(ssize_t   )   = ssize_t
     D  i_fd                         10I 0 value                                = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_buflen                           value like(size_t    )               = size_t
      *
      *  0/-1 = ftruncate()--Truncate File                  include <unistd.h>
     D ftruncate...
     D                 PR            10I 0 extproc('ftruncate')                 = int
     D  i_fd                         10I 0 value                                = int
     D  i_length                           value like(off_t     )               = off_t
      *
      *  off_t = lseek()--Set File Read/Write Offset        include <unistd.h>
     D lseek...
     D                 PR                  extproc('lseek')  like(off_t     )   = off_t
     D  i_fd                         10I 0 value                                = int
     D  i_offset                           value like(off_t     )               = off_t
     D  i_whence                     10I 0 value                                = int
      *
      *  <h/unistd.h>
     D SEEK_SET        C                   const(0)                             ! seek start
     D SEEK_CUR        C                   const(1)                             ! seek curPos
     D SEEK_END        C                   const(2)                             ! seek end
      *
      *  0/-1 = unlink()--Remove Link to File               include <unistd.h>
     D unlink...
     D                 PR            10I 0 extproc('unlink')                    = int
     D  i_pPath                        *   value options(*string)               = *path
      *
      *  0/-1 = Qp0lRenameKeep()--Rename File or Directory, Keep "new" If It Exists
     D Qp0lRenameKeep...
     D                 PR            10I 0 extproc('Qp0lRenameKeep')            = int
     D  i_pOldPath                     *   value options(*string)               = *path
     D  i_pNewPath                     *   value options(*string)               = *path
      *
      *  0/-1 = Qp0lRenameUnlink()--Rename File or Directory, Unlink "new" If It Exists
     D Qp0lRenameUnlink...
     D                 PR            10I 0 extproc('Qp0lRenameUnlink')          = int
     D  i_pOldPath                     *   value options(*string)               = *path
     D  i_pNewPath                     *   value options(*string)               = *path
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
      /IF NOT DEFINED(c_close_function)
      /DEFINE c_close_function
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      /ENDIF
      *
      *  erno--Set Pointer to Runtime Error Code
     D errno           PR              *                     extproc('__errno')
      *
      *  strerror -- Set Pointer to Runtime Error Message
     D strerror        PR              *                     extproc('strerror')
     D  errno                        10I 0 value
      *
      *  <sys/errno.h>
     D EDOM_C          C                   const(3001)                          domain error i
     D ERANGE_C        C                   const(3002)                          range error in
     D ETRUNC_C        C                   const(3003)                          truncation on
     D ENOTOPEN_C      C                   const(3004)                          file has not b
     D ENOTREAD_C      C                   const(3005)                          file not opene
     D ERECIO_C        C                   const(3008)                          file opened fo
     D ENOTWRITE_C     C                   const(3009)                          file not opene
     D ESTDIN_C        C                   const(3010)                          stdin cannot b
     D ESTDOUT_C       C                   const(3011)                          stdout cannot
     D ESTDERR_C       C                   const(3012)                          stderr cannot
     D EBADSEEK_C      C                   const(3013)                          bad offset to
     D EBADNAME_C      C                   const(3014)                          invalid file n
     D EBADMODE_C      C                   const(3015)                          invalid file m
     D EBADPOS_C       C                   const(3017)                          invalid positi
     D ENOPOS_C        C                   const(3018)                          no record at s
     D ENUMMBRS_C      C                   const(3019)                          no ftell if mo
     D ENUMRECS_C      C                   const(3020)                          no ftell if to
     D EBADFUNC_C      C                   const(3022)                          invalid functi
     D ENOREC_C        C                   const(3026)                          record not fou
     D EBADDATA_C      C                   const(3028)                          message data i
     D EBADOPT_C       C                   const(3040)                          bad option on
     D ENOTUPD_C       C                   const(3041)                          file not opene
     D ENOTDLT_C       C                   const(3042)                          file not opene
     D EPAD_C          C                   const(3043)                          padding occurr
     D EBADKEYLN_C     C                   const(3044)                          bad key length
     D EPUTANDGET_C    C                   const(3080)                          illegal write
     D EGETANDPUT_C    C                   const(3081)                          illegal read a
     D EIOERROR_C      C                   const(3101)                          I/O exception
     D EIORECERR_C     C                   const(3102)                          I/O exception
      *
      *  The following values are defined by POSIX ISO/IEC 9945-1:1990.
     D EINVAL_C        C                   const(3021)                          invalid argume
     D EIO_C           C                   const(3006)                          input/output e
     D ENODEV_C        C                   const(3007)                          no such device
     D EBUSY_C         C                   const(3029)                          resource busy
     D ENOENT_C        C                   const(3025)                          no such file o
     D EPERM_C         C                   const(3027)                          operation not
      *
      *  AS/400 specific error numbers
     D EACCES_C        C                   const(3401)                          Permission den
     D ENOTDIR_C       C                   const(3403)                          Not a director
     D ENOSPC_C        C                   const(3404)                          No space avail
     D EXDEV_C         C                   const(3405)                          Improper link.
     D EWOULDBLOCK_C   C                   const(3406)                          Operation woul
     D EAGAIN_C        C                   const(3406)                          Operation woul
     D EINTR_C         C                   const(3407)                          Interrupted fu
     D EFAULT_C        C                   const(3408)                          The address us
     D ETIME_C         C                   const(3409)                          Operation time
     D ENXIO_C         C                   const(3415)                          No such device
     D ECLOSED_C       C                   const(3417)                          Socket closed
     D EADDRINUSE_C    C                   const(3420)                          Address alread
     D EADDRNOTAVAIL_C...
     D                 C                   const(3421)                          Address not av
     D EAFNOSUPPORT_C  C                   const(3422)                          The type of so
     D EALREADY_C      C                   const(3423)                          Operation alre
     D ECONNABORTED_C  C                   const(3424)                          Connection end
     D ECONNREFUSED_C  C                   const(3425)                          A remote host
     D ECONNRESET_C    C                   const(3426)                          A connection w
     D EDESTADDRREQ_C  C                   const(3427)                          Operation requ
     D EHOSTDOWN_C     C                   const(3428)                          A remote host
     D EHOSTUNREACH_C  C                   const(3429)                          A route to the
     D EINPROGRESS_C   C                   const(3430)                          Operation in p
     D EISCONN_C       C                   const(3431)                          A connection h
     D EMSGSIZE_C      C                   const(3432)                          Message size o
     D ENETDOWN_C      C                   const(3433)                          The network is
     D ENETRESET_C     C                   const(3434)                          A socket is co
     D ENETUNREACH_C   C                   const(3435)                          Cannot reach t
     D ENOBUFS_C       C                   const(3436)                          There is not e
     D ENOPROTOOPT_C   C                   const(3437)                          The protocol d
     D ENOTCONN_C      C                   const(3438)                          Requested oper
     D ENOTSOCK_C      C                   const(3439)                          The specified
     D ENOTSUP_C       C                   const(3440)                          Operation not
     D EOPNOTSUPP_C    C                   const(3440)                          Operation not
     D EPFNOSUPPORT_C  C                   const(3441)                          The socket pro
     D EPROTONOSUPPORT_C...
     D                 C                   const(3442)                          No protocol of
     D EPROTOTYPE_C    C                   const(3443)                          The socket typ
     D ERCVDERR_C      C                   const(3444)                          An error indic
     D ESHUTDOWN_C     C                   const(3445)                          Cannot send da
     D ESOCKTNOSUPPORT_C...
     D                 C                   const(3446)                          The specified
     D ETIMEDOUT_C     C                   const(3447)                          A remote host
     D EUNATCH_C       C                   const(3448)                          The protocol r
     D EBADF_C         C                   const(3450)                          Descriptor not
     D EMFILE_C        C                   const(3452)                          Too many open
     D ENFILE_C        C                   const(3453)                          Too many open
     D EPIPE_C         C                   const(3455)                          Broken pipe.
     D EEXIST_C        C                   const(3457)                          File exists.
     D EDEADLK_C       C                   const(3459)                          Resource deadl
     D ENOMEM_C        C                   const(3460)                          Storage alloca
     D EOWNERTERM_C    C                   const(3462)                          The mutex no l
     D EDESTROYED_C    C                   const(3463)                          he synchroniza
     D ETERM_C         C                   const(3464)                          Operation term
     D EMLINK_C        C                   const(3468)                          Maximum link c
     D ESPIPE_C        C                   const(3469)                          Seek request n
     D ENOSYS_C        C                   const(3470)                          Function not i
     D EISDIR_C        C                   const(3471)                          Specified targ
     D EROFS_C         C                   const(3472)                          Read-only file
     D EUNKNOWN_C      C                   const(3474)                          Unknown system
     D EITERBAD_C      C                   const(3475)                          Iterator is in
     D EDAMAGE_C       C                   const(3484)                          A damaged obje
     D ELOOP_C         C                   const(3485)                          A loop exists
     D ENAMETOOLONG_C  C                   const(3486)                          A path name is
     D ENOLCK_C        C                   const(3487)                          No locks avail
     D ENOTEMPTY_C     C                   const(3488)                          Directory not
     D ENOSYSRSC_C     C                   const(3489)                          System resourc
     D ECONVERT_C      C                   const(3490)                          Conversion err
     D E2BIG_C         C                   const(3491)                          Argument list
     D EILSEQ_C        C                   const(3492)                          Conversion sto
     D ESOFTDAMAGE_C   C                   const(3497)                          Object has sof
     D ENOTENROLL_C    C                   const(3498)                          User not enrol
     D EOFFLINE_C      C                   const(3499)                          Object is susp
     D EROOBJ_C        C                   const(3500)                          Object is a re
     D ELOCKED_C       C                   const(3506)                          Area being rea
     D EFBIG_C         C                   const(3507)                          Object too lar
     D EIDRM_C         C                   const(3509)                          The semaphore,
     D ENOMSG_C        C                   const(3510)                          The queue does
     D EFILECVT_C      C                   const(3511)                          File ID conver
     D EBADFID_C       C                   const(3512)                          A File ID coul
     D ESTALE_C        C                   const(3513)                          A File ID coul
     D ESRCH_C         C                   const(3515)                          No such proces
     D ENOTSIGINIT_C   C                   const(3516)                          Process not en
     D ECHILD_C        C                   const(3517)                          No child proce
     D EBADH_C         C                   const(3520)                          Handle is not
     D ETOOMANYREFS_C  C                   const(3523)                          The operation
     D ENOTSAFE_C      C                   const(3524)                          Function not a
     D EOVERFLOW_C     C                   const(3525)                          Object is too
     D EJRNDAMAGE_C    C                   CONST(3526)                          Journal damage
     D EJRNINACTIVE_C  C                   CONST(3527)                          Journal inacti
     D EJRNRCVSPC_C    C                   CONST(3528)                          Journal space
     D EJRNRMT_C       C                   CONST(3529)                          Journal is rem
     D ENEWJRNRCV_C    C                   CONST(3530)                          New journal re
     D ENEWJRN_C       C                   CONST(3531)                          New journal is
     D EJOURNALED_C    C                   CONST(3532)                          Object already
     D EJRNENTTOOLONG_C...
     D                 C                   CONST(3533)                          Entry too larg
     D EDATALINK_C     C                   CONST(3534)                          Object is a Da
     D ENOTAVAIL_C     C                   CONST(3535)                          Independent AS
     D ENOTTY_C        C                   CONST(3536)                          Inappropriate
     D EFBIG2_C        C                   CONST(3540)                          Write or trunc
     D ETXTBSY_C       C                   CONST(3543)                          Text file busy
     D EASPGRPNOTSET_C...
     D                 C                   CONST(3544)                          ASP group not
     D ERESTART_C      C                   CONST(3545)                          System call ca
     D ESCANFAILURE_C  C                   CONST(3546)                          Object marked
      *
      *  Unix return codes
     D RC_OK           C                   const(0)
     D RC_ERROR        C                   const(-1)
      *
      *  Convert External Form to Numeric Value (CVTEFN)
     D cvtefnd...
     D                 PR             8F   extproc('cvtefnd')
     D  i_source                       *   value
     D  i_len                        10U 0 value
     D  i_mask                         *   value
      *
      *  Test Bit in String (TSTBTS)
     D tstbts...
     D                 PR            10I 0 extproc('tstbts')
     D  bit_string                     *   value
     D  bit_offset                   10I 0 value
      *
      *  getenv()--Get Value of Environment Variable
     D getenv...
     D                 PR              *   extproc('getenv')
     D  name                           *   value  options(*string)
      *
      *  putenv()--Change or Add Environment Variable
     D putenv...
     D                 PR            10I 0 extproc('putenv')
     D  string                         *   value  options(*string)
      *
      *  Qp0zDltEnv()--Delete an Environment Variable
     D Qp0zDltEnv...
     D                 PR            10I 0 extproc('Qp0zDltEnv')
     D  name                           *   value  options(*string)
      *
      *  Qp0zInitEnv()--Initialize Environment for Variables
     D Qp0zInitEnv...
     D                 PR            10I 0 extproc('Qp0zInitEnv')
      *
     D ENVIRON         S               *   import('environ')
      *
      *  Generate Universal Unique Identifier (GENUUID)
     D genUUID...
     D                 PR                  extproc('_GENUUID')
     D  uuid_template                  *   value
      *
     D uuid_template_t...
     D                 DS                  qualified  based(pDummy)
     D  bytPrv                       10U 0
     D  bytAvl                       10U 0
     D  reserved                      8A
     D  uuid                         16A
      *
      *  Convert Hex to Character (CVTHC)
     D cvthc...
     D                 PR                  extproc('cvthc')
     D  pResult                        *   value
     D  pSource                        *   value
     D  sourceSize                   10I 0 value
      *
      *  Convert Eight Bit Character to Hex Nibbles (CVTCH)
     D cvtch...
     D                 PR                  extproc('cvtch')
     D  pResult                        *   value
     D  pSource                        *   value
     D  sourceLen                    10I 0 value
      *
      *  Cipher (CIPHER)
     D cipher...
     D                 PR                  extproc('_CIPHER')
     D                                 *   const
     D                                 *   value
     D                                 *   const
      *
     D cipherCtrls_t   DS                  qualified  based(pDummy)  align
     D  function               1      2A
     D  hashAlg                3      3A
     D  sequence               4      4A
     D  dataLength             5      8U 0
     D  output                 9      9A
     D  reserved_1            10     16A
     D  hashContext           17     32*
     D  HMACKey               33     48*
     D  HMACKeyLength         49     52U 0
     D  reserved_2            53     96A
      *
     D cCIPHER_MD5...
     D                 C                   const(x'00')
     D cCIPHER_SHA1...
     D                 C                   const(x'01')
      *
     D cCIPHER_ONLY...
     D                 C                   const(x'00')
     D cCIPHER_FIRST...
     D                 C                   const(x'01')
     D cCIPHER_MIDDLE...
     D                 C                   const(x'02')
     D cCIPHER_FINAL...
     D                 C                   const(x'03')
      *
     D cCIPHER_HASH...
     D                 C                   const(x'00')
     D cCIPHER_HMAC...
     D                 C                   const(x'01')
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing COPYRIGHT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "COPYRIGHT "
mbrtype =  "RPGLE     "
mbrtext =  "Copyright information                             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /if not defined(COPYRIGHT_DSPEC)
     H COPYRIGHT('V1.15.1 - 09.02.2017 - mailto:thomas.raddatz@tools400.de')
      /eof
      /endif
     D BASICS1_VERSION...
     D                 C                   '1.15.1'
     D BASICS1_DATE...
     D                 C                   '09.02.2017'
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDENVVAR  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDENVVAR  "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Environment variable                    "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(envVar_t  )
      /DEFINE envVar_t
      * ============================================================= *
      *   Environment variable.                                       *
      * ============================================================= *
      *
     D envVar_t        DS                  qualified           based(pDummy)
     D  name                        128A   varying
     D  value                      1024A   varying
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDERRCODE  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDERRCODE "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : API error code                          "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(errCode_t )
      /DEFINE errCode_t
      *===============================================================*
      *  API error code                                               *
      *===============================================================*
     D errCode_t       DS                  qualified           based(pDummy)
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved_1                    1A
     D  excDta                      256A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDINFDS  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDINFDS   "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : File information data structure         "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(fileInfDS_t)
      /DEFINE fileInfDS_t
      *===============================================================*
      *  File information data structure                              *
      *===============================================================*
     D fileInfDS_t     DS                  based(pDummy)   qualified
      * Reserved 01
     D  reserved_01            1      8A
      * Open indication 1=open
     D  isOpen                 9      9A
      * End of file 1=EOF
     D  isEOF                 10     10A
      * Status
     D  status                11     15S 0
      * Operation code, first 5 pos.
     D  opCode                16     20A
      * IO-Type:
      *   F=The last operation was specified for a file name
      *   R=The last operation was specified for a record
      *   I=The last operation was an implicit file operation.
     D  IO_type               21     21A
      * Routine of operation code
     D  routine               22     29A
      * RPG source listing line nbr
     D  srcSeq                30     37A
      * Record format
     D  rcdFormat             38     45A
      * System message number
     D  sysMsgNbr             46     52A
      * Reserved 02
     D  reserved_02           53     66A
      *
      * Valid after post:
      *    Screen size (product of the number of rows
      *    and the number of columns on the device screen).
     D  screenSize            67     70S 0
      *    The display's keyboard type.
      *       00 = alphanumeric or katakana
      *       10 = ideographic
     D  kbdType               71     72S 0
      *    The display type.
      *       00 = alphanumeric or katakana
      *       10 = ideographic
      *       20 = DBCS
     D  displayType           73     74S 0
      *    Always set to 00.
     D  mode                  75     76S 0
      * Reserved_03
     D  reserved_03           77     80A
      *
      *  -------------------------------
      *    Open Feedback
      *  -------------------------------
     D  openFeedback                       likeds(openFeedback_t)
      *
      *  -------------------------------
      *    Input/Output Feedback
      *  -------------------------------
     D  IO_feedback                        likeds(IO_feedback_t )
      *
      *  -------------------------------
      *    I/O Feedback, File specific
      *  -------------------------------
     D  IO_feedback_file...
     D                              256A
      *    I/O Feedback Database File
     D  IO_feedback_DB...
     D                                     likeds(IO_feedback_DB_t)
     D                                     overlay(IO_feedback_file)
      *
      *  -------------------------------
      *    Open Feedback
      *  -------------------------------
     D openFeedback_t...
     D                 DS           160    qualified
      * DS=Display DB=File SP=Spooled File
     D  ODP_type               1      2A
      * File name
     D  file                   3     12A
      * Library
     D  lib                   13     22A
      * Spool file name
     D  spoolFile             23     32A
      * Spool file library
     D  spoolLib              33     42A
      * Spool file number
     D  spoolNbr              43     44I 0
      * Record length
     D  maxRcdLength          45     46I 0
      * Key length
     D  maxKeyLength          47     48I 0
      * Member
     D  mbr                   49     58A
      * Reserved
     D  reserved_01           59     62I 0
      * Reserved
     D  reserved_02           63     66I 0
      * File type
      *     1  =  Display
      *     2  =  Printer
      *     4  =  Diskette
      *     5  =  Tape
      *     9  =  Save
      *    10  =  DDM
      *    11  =  ICF
      *    20  =  Inline data
      *    21  =  Database
     D  fileType              67     68I 0
      * Reserved
     D  reserved_03           69     71A
      * Number of lines on a display screen or       (Display, printer)
      * number of lines on a printed page.
     D  rows                  72     73I 0
      * Length of the null field byte map.           (Database)
     D  lenNullFldMap         72     73I 0
      * Number of positions on a display screen or   (Display, printer)
      * number of characters on a printed line.
     D  columns               74     75I 0
      * Length of the null key field byte map.       (Database)
     D  lenKeyFldMap          74     75I 0
      * Number of records in the member at open
      * at open time.
     D numRcdsAtOpen          76     79I 0
      * Access type
     D accessType             80     81A
      * Duplicate key?
     D isDupKey               82     82A
      * Source file?
     D isSrcFile              83     83A
      * Reserved
     D reserved_04            84     93A
      * Reserved
     D reserved_05            94    103A
      * Offset to volume label fields of open
      * feedback area.
     D ofsVolLblFld          104    105I 0
      * Max rcds in blk
     D maxBlkRcds            106    107I 0
      * Overflow line
     D overflow              108    109I 0
      * Blk increment
     D blkInc                110    111I 0
      * Reserved
     D reserved_06           112    115A
      * Miscellaneous flags
     D flags1                116    116A
      * Requester name
     D requester             117    126A
      * Open count
     D openCount             127    128I 0
      * Reserved
     D reserved_07           129    129A
      * Num based mbrs
     D numBasedMbrs          131    132I 0
      * Miscellaneous flags
     D flags2                133    133A
      * Open identifier
     D openID                134    135A
      * Max rcd fmt length
     D maxRcdFmtLen          136    137I 0
      * Database CCSID
     D CCSID                 138    139I 0
      * Miscellaneous flags
     D flags3                140    140A
      * Reserved
     D reserved_08           141    146A
      * Num devs defined
     D numDevices            147    148I 0
      *
      *  -------------------------------
      *    Input/Output Feedback
      *  -------------------------------
     D IO_feedback_t...
     D                 DS           126    qualified
      * Offset to file dependant feedback
     D ofsFileDepFB            1      2I 0
      * Write count
     D writeCount              3      6I 0
      * Read count
     D readCount               7     10I 0
      * Write/read count
     D writeReadCount         11     14I 0
      * Other I/O count
     D otherCount             15     18I 0
      * Reserved
     D reserved_01            19     19A
      * Current operation
      *   hex 01 =  Read or read block or read from invited devices
      *   hex 02 =  Read direct
      *   hex 03 =  Read by key
      *   hex 05 =  Write or write block
      *   hex 06 =  Write-read
      *   hex 07 =  Update
      *   hex 08 =  Delete
      *   hex 09 =  Force-end-of-data
      *   hex 0A =  Force-end-of-volume
      *   hex 0D =  Release record lock
      *   hex 0E =  Change end-of-data
      *   hex 0F =  Put deleted record
      *   hex 11 =  Release device
      *   hex 12 =  Acquire device
     D operation              20     20A
      * Rcd format name
     D IO_rcdFmt              21     30A
      * Device class
     D deviceClass            31     32A
      * Pgm device name
     D IO_pgmDevice           33     42A
      * Rcd len of I/O
     D IO_rcdLength           43     46I 0
      * Reserved
     D reserved_02            47    126A
      *
      *  -------------------------------
      *    I/O Feedback Database File
      *  -------------------------------
     D IO_feedback_DB_t...
     D                 DS                  qualified
      * Number of locked records
     D  numLckRcds            11     12I 0
      * Maximum number of fields
     D  maxNumFlds            13     14I 0
      * Nbr of key fields
     D  nbrOfKeyFlds          21     22I 0
      * Key length
     D  keyLength             27     28I 0
      * Data member number.
     D  dtaMbrNum             29     30I 0
      * Relative record number in data member.
     D  rcdNbr                31     34U 0
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDMBRD0100  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDMBRD0100"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QUSRMBRD API - MBRD0100                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(mbrd0100_t)
      /DEFINE mbrd0100_t
      *===============================================================*
      *  QUSRMBRD API - MBRD0100                                      *
      *===============================================================*
     D mbrd0100_t      DS                  qualified           based(pDummy)
     D  bytePrv                      10I 0
     D  byteAvl                      10I 0
     D  filNme                       10A
     D  filLib                       10A
     D  mbr                          10A
     D  attr                         10A
     D  srcTyp                       10A
     D  crtDatTim                    13A
     D  chgDatTim                    13A
     D  text                         50A
     D  isSrcFile                     1A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDMBRD0200  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDMBRD0200"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QUSRMBRD API - MBRD0200                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(mbrd0200_t)
      /DEFINE mbrd0200_t
      *===============================================================*
      *  QUSRMBRD API - MBRD0200                                      *
      *===============================================================*
     D mbrd0200_t      DS                  qualified           based(pDummy)
     D  bytePrv                      10I 0
     D  byteAvl                      10I 0
     D  filNme                       10A
     D  filLib                       10A
     D  mbr                          10A
     D  attr                         10A
     D  srcTyp                       10A
     D  crtDatTim                    13A
     D  chgDatTim                    13A
     D  text                         50A
     D  isSrcFile                     1A
      * - - - - - - - - - - - - - - - - -
     D rmtFile                        1A
     D lglFile                        1A
     D odpSharing                     1A
     D reserved_1                     2A
     D numRcdAllMbr                  10I 0
     D numDltRcd                     10I 0
     D dtaSpcSize                    10I 0
     D accPthSize                    10I 0
     D numPhyMbrs                    10I 0
     D mbrChgDatTim                  13A
     D mbrSavDatTim                  13A
     D mbrRstDatTim                  13A
     D mbrExpDate                     7A
     D reserved_2                     6A
     D numDaysUsed                   10I 0
     D dateLastUsed                   7A
     D useResetDate                   7A
     D reserved_3                     2A
     D dtaSpcSizeMult                10I 0
     D accPthSizeMult                10I 0
     D mbrTextCCSID                  10I 0
     D ofsAddInf                     10I 0
     D lenAddInf                     10I 0
     D numRcdAllMbrU                 10U 0
     D numDltRcdU                    10U 0
     D reserved_4                     6A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDMSG  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDMSG     "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Message                                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(msg_t     )
      /DEFINE msg_t
      * ============================================================= *
      *   Message structure                                           *
      * ============================================================= *
      *
     D msg_t           DS                  qualified           based(pDummy)
      /if defined(*V5R3M0)
     D  ID                                 likeds(msgID_t)
      /else
     D  ID                            7A
      /endif
     D  data                        512A
     D  type                         10A
     D  file                         10A
     D  lib                          10A
      *
      /if defined(*V5R3M0)
     D msgID_t         DS                  qualified           based(pDummy)
     D  prefix                        3A
     D  nbr                           4S 0
      /endif
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDOBJD0100  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDOBJD0100"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QUSROBJD API - OBJD0100                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(objd0100_t)
      /DEFINE objd0100_t
      *===============================================================*
      *  QUSROBJD API - OBJD0300                                      *
      *===============================================================*
      *
     D objd0100_t      DS                  qualified           based(pDummy)
     D  bytRet                       10I 0
     D  bytAvl                       10I 0
     D  name                         10A
     D  lib                          10A
     D  type                         10A
     D  rtnLib                       10A
     D  auxStgP                      10I 0
     D  owner                        10A
     D  domain                        2A
     D  crtDatTim                    13A
     D  chgDatTim                    13A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDQFILE  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDQFILE   "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Qualified file name                     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(qFile_t   )
      /DEFINE qFile_t
      * ============================================================= *
      *   Qualified file name                                         *
      *===============================================================*
      *
     D qFile_t         DS                  qualified           based(pDummy)
     D  name                         10A
     D  lib                          10A
     D  mbr                          10A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDQOBJ  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDQOBJ    "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Qualified object name                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(qObj_t    )
      /DEFINE qObj_t
      * ============================================================= *
      *   Qualified object name                                       *
      *===============================================================*
      *
     D qObj_t          DS                  qualified           based(pDummy)
     D  name                         10A
     D  lib                          10A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDQQSYSOBJ  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDQQSYSOBJ"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Qualified QSYS object name              "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(qQSYSObj_t)
      /DEFINE qQSYSObj_t
      * ============================================================= *
      *   Qualified QSYS object name                                  *
      *===============================================================*
      *
     D qQSYSObj_t      DS                  qualified           based(pDummy)
     D  name                         10A
     D  lib                          10A
     D  mbr                          10A
     D  type                         10A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDRCVM0200  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDRCVM0200"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QMHRCVM  API - RCVM0200                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(rcvm0200_t)
      /DEFINE rcvm0200_t
      *===============================================================*
      *  QMHRCVM API - RCVM0200                                       *
      *===============================================================*
      *
     D rcvm0200_t      DS                  qualified           based(pDummy)
      * Bytes returned
     D  bytRet                       10I 0
      * Bytes available
     D  bytAvl                       10I 0
      * Message Severity
     D  msgSev                       10I 0
      * Message ID
     D  msgID                         7A
      * Message Type
     D  msgType                       2A
      * Message Key
     D  msgKey                        4A
      * Message File
     D  msgF                         10A
      * Message Library Specified
     D  msgLS                        10A
      * Message Library Used
     D  msgLU                        10A
      * Sending Job
     D  sndJob                       10A
      * Sending User Profile
     D  sndUsr                       10A
      * Sending Job Number
     D  sndNbr                        6A
      * Sending Program
     D  sndPgm                       12A
      * Sending program Instr. Nbr.
     D  sndINb                        4A
      * Sending Date
     D  sndDat                        7A
      * Sending Time
     D  sndTim                        6A
      * Receiving program
     D  rcvPgm                       10A
      * Receiving Program Instr. Nbr
     D  rcvINb                        4A
      * Sending Type
     D  sndTyp                        1A
      * Receiving Type
     D  rcvTyp                        1A
      * Reserved 01
     D  reserved_01                   1A
      * Conversion Status ID Text
     D  cStIDTx                      10I 0
      * Conversion Status ID Data
     D  cStIDDt                      10I 0
      * Alert Option
     D  alrOpt                        9A
      * CCSID of msg and help
     D  ccsidMH                      10I 0
      * CCSID of replacement data
     D  ccsidRD                      10I 0
      * Length replacement data ret.
     D  lnRplDtR                     10I 0
      * Length replacement data avl.
     D  lnRplDtA                     10I 0
      * Length message ret.
     D  lnMgR                        10I 0
      * Length message avl.
     D  lnMgA                        10I 0
      * Length message help ret.
     D  lnMgHR                       10I 0
      * Length message help avl.
     D  lnMgHA                       10I 0
      * Value of varying length!
     D  value                      4096A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDRCVM0300  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDRCVM0300"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QMHRCVM  API - RCVM0300                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(rcvm0300_t)
      /DEFINE rcvm0300_t
      *===============================================================*
      *  QMHRCVM API - RCVM0300                                       *
      *===============================================================*
      *
     D rcvm0300_t      DS                  qualified           based(pDummy)
      * Bytes returned
     D  bytRet                 1      4I 0
      * Bytes available
     D  bytAvl                 5      8I 0
      * Message Severity
     D  msgSev                 9     12I 0
      * Message ID
     D  msgID                 13     19A
      * Message Type
     D  msgType               20     21A
      * Message Key
     D  msgKey                22     25A
      * Message File
     D  msgF                  26     35A
      * Message Library Specified
     D  msgLS                 36     45A
      * Message Library Used
     D  msgLU                 46     55A
      * Alert option
     D  alertOpt              56     64A
      * CCSID conversion status indicator of message and message help
     D  ccsidConvStatMsg...
     D                        65     68I 0
      * CCSID conversion status indicator of message data or text
     D  ccsidConvStatMsgData...
     D                        69     72I 0
      * CCSID of replacement data or impromptu message text
     D  ccsidRplData...
     D                        73     76I 0
      * CCSID of replacement data and message help
     D  ccsidMsgHlp...
     D                        77     80I 0
      * Length of replacement data or impromptu message text returned
     D  lenRplDataR...
     D                        81     84I 0
      * Length of replacement data or impromptu message text available
     D  lenRplDataA...
     D                        85     88I 0
      * Length of message returned
     D  lenMsgR...
     D                        89     92I 0
      * Length of message available
     D  lenMsgA...
     D                        93     96I 0
      * Length of message help returned
     D  lenMsgHlpR...
     D                        97    100I 0
      * Length of message help available
     D  lenMsgHlpA...
     D                       101    104I 0
      * Length of sender information returned
     D  lenSndInfR...
     D                       105    108I 0
      * Length of sender information available
     D  lenSndInfA...
     D                       109    112I 0
      *
      * The offsets to       CHAR(*)      Replacement data or impromptu message text
      * these fields         CHAR(*)      Message
      * equal the offset     CHAR(*)      Message help
      * to the last          CHAR(*)      Sender information
      * fixed-length
      * field plus the
      * length of the
      * previous variable
      * length fields.
      *
      /ENDIF
      *
      /IF NOT DEFINED(sndInf_t)
      /DEFINE sndInf_t
      *===============================================================*
      *  QMHRCVM API - Sender Information Format                      *
      *===============================================================*
      *
     D sndInf_t        DS                  based(pDummy) qualified
      * Sending job
     D  job...
     D                         1     10A
      * Sending user profile
     D  user...
     D                        11     20A
      * Sending job's number
     D  jobNbr...
     D                        21     26A
      * Date sent
     D  date...
     D                        27     33A
      * Time sent
     D  time...
     D                        34     39A
      * Sending type
     D  sndType...
     D                        40     40A
      * Receiving type
     D  rcvType...
     D                        41     41A
      * Sending program name
     D  sndPgm...
     D                        42     53A
      * Sending module name
     D  sndModule...
     D                        54     63A
      * Sending procedure name
     D  sndProc...
     D                        64    319A
      * Reserved
     D  reserved_01...
     D                       320    320A
      * Number of statement numbers or instruction numbers
      * available for the sending program or procedure
     D  sndPgmNumStmtNbrs...
     D                       321    324A
      * Sending program's statement numbers or
      * instruction numbers
     D  sndPgmStmtNbrs...
     D                       325    354A
     D   sndPgmStmtNbr...
     D                               10A   dim(3) overlay(sndPgmStmtNbrs)
      * Receiving program name
     D  rcvPgm...
     D                       355    364A
      * Receiving module name
     D  rcvModule...
     D                       365    374A
      * Receiving procedure name
     D  rcvProc...
     D                       375    630A
      * Reserved
     D  reserved_02...
     D                       631    640A
      * Number of statement numbers or instruction numbers
      * available for the receiving program or procedure.
     D  rcvPgmNumStmtNbrs...
     D                       641    644I 0
      * Receiving program's statement number or
      * instruction number
     D  rcvPgmStmtNbrs...
     D                       645    674A
     D   rcvPgmStmtNbr...
     D                               10A   dim(3) overlay(rcvPgmStmtNbrs)
      * Reserved
     D  reserved_03...
     D                       675    676A
      * Displacement to long sending program name
     D  ofsSndPgmLName...
     D                       677    680I 0
      * Length of long sending program name
     D  lenSndPgmLName...
     D                       681    684I 0
      * Displacement to long sending procedure name
     D  ofsSndPrcLName...
     D                       685    688I 0
      * Length of long sending procedure name
     D  lenSndPrcLName...
     D                       689    692I 0
      * Displacement to long receiving procedure name
     D  ofsRcvPrcLName...
     D                       693    696I 0
      * Length of long receiving procedure name
     D  lenRcvPrcLName...
     D                       697    700I 0
      *
      * The                  CHAR(*)      Reserved
      * offsets              CHAR(*)      Long sending program name
      * to these             CHAR(*)      Long sending procedure name
      * fields               CHAR(*)      Long receiving procedure name
      * are found
      * in the
      * displacemet
      * fields
      * identified
      * in this
      * table.
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDRTVM0100  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDRTVM0100"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QMHRTVM  API - RTVM0100                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(rtvm0100_t)
      /DEFINE rtvm0100_t
      *===============================================================*
      *  QMHRTVM API - RTVM0100                                       *
      *===============================================================*
      *
     D rtvm0100_t      DS                  qualified           based(pDummy)
      *  Bytes returned
     D  BYTRET                        9B 0
      *  Bytes available
     D  BYTAVL                        9B 0
      *  Length of message returned
     D  LENMSGRET                     9B 0
      *  Length of message available
     D  LENMSGAVL                     9B 0
      *  Length of msg help returned
     D  LENHLPRET                     9B 0
      *  Length of msg help available
     D  LENHLPAVL                     9B 0
      *  Msg text and data of varying length!
     D  DATA                       2048A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDRTVM0300  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDRTVM0300"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QMHRTVM  API - RTVM0300                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(rtvm0300_t)
      /DEFINE rtvm0300_t
      *===============================================================*
      *  QMHRTVM API - RTVM0300                                       *
      *===============================================================*
      *
     D rtvm0300_t      DS                  qualified           based(pDummy)
      *  Bytes returned
     D  bytRet                       10I 0
      *  Bytes available
     D  bytAvl                       10I 0
      *  Message severity
     D  msgSev                       10I 0
      *  Alert index
     D  altIdx                       10I 0
      * Alert Option
     D  altOpt                        9A
      * Log indicator
     D  logInd                        1A
      * Message ID
     D  msgID                         7A
      * Reserved
     D  reserved_01                   3A
      * Nbr. of subst. var. formats
     D  numVarFmt                    10I 0
      * CCSID conv. stat. ind. text
     D  csIndTxt                     10I 0
      * CCSID conv. stat. ind. data
     D  csIndDta                     10I 0
      * CCSID of Text returned
     D  ccsidTxt                     10I 0
      * Offset of default reply
     D  ofsDftR                      10I 0
      * Length of default reply ret.
     D  lenDftRpyR                   10I 0
      * Length of default reply avl.
     D  lenDftRpyA                   10I 0
      * Offset of message
     D  ofsMsg                       10I 0
      * Length of message returned
     D  lenMsgR                      10I 0
      * Length of message available
     D  lenMsgA                      10I 0
      * Offset of message
     D  ofsMsgHlp                    10I 0
      * Length of message help ret.
     D  lenMsgHlpR                   10I 0
      * Length of message help avl.
     D  lenMsgHlpA                   10I 0
      * Ofs. of subst. var. formats
     D  ofsVarFmt                    10I 0
      * Length subst. var. fmt. ret.
     D  lenVarFmtR                   10I 0
      * Length subst. var. fmt. avl.
     D  lenVarFmtA                   10I 0
      * Length subst. var. element
     D  lenVarFmtE                   10I 0
      * Data
     D  data                       4096A
      *                       CHAR(*)  Default reply
      *                       CHAR(*)  Message
      *                       CHAR(*)  Message help
      *                       CHAR(*)  Substitution variable formats
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDRTVM0400  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDRTVM0400"
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : QMHRTVM  API - RTVM0400                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(rtvm0400_t)
      /DEFINE rtvm0400_t
      *===============================================================*
      *  QMHRTVM API - RTVM0400                                       *
      *===============================================================*
      *
     D rtvm0400_t      DS                  qualified           based(pDummy)
      *  Bytes returned
     D  bytRet                       10I 0
      *  Bytes available
     D  bytAvl                       10I 0
      *  Message severity
     D  msgSev                       10I 0
      *  Alert index
     D  altIdx                       10I 0
      * Alert Option
     D  altOpt                        9A
      * Log indicator
     D  logInd                        1A
      * Message ID
     D  msgID                         7A
      * Reserved
     D  reserved_01                   3A
      * Nbr. of subst. var. formats
     D  numVarFmt                    10I 0
      * CCSID conv. stat. ind. text
     D  csIndTxt                     10I 0
      * CCSID conv. stat. ind. data
     D  csIndDta                     10I 0
      * CCSID of Text returned
     D  ccsidTxt                     10I 0
      * Offset of default reply
     D  ofsDftR                      10I 0
      * Length of default reply ret.
     D  lenDftRpyR                   10I 0
      * Length of default reply avl.
     D  lenDftRpyA                   10I 0
      * Offset of message
     D  ofsMsg                       10I 0
      * Length of message returned
     D  lenMsgR                      10I 0
      * Length of message available
     D  lenMsgA                      10I 0
      * Offset of message
     D  ofsMsgHlp                    10I 0
      * Length of message help ret.
     D  lenMsgHlpR                   10I 0
      * Length of message help avl.
     D  lenMsgHlpA                   10I 0
      * Ofs. of subst. var. formats
     D  ofsVarFmt                    10I 0
      * Length subst. var. fmt. ret.
     D  lenVarFmtR                   10I 0
      * Length subst. var. fmt. avl.
     D  lenVarFmtA                   10I 0
      * Length subst. var. element
     D  lenVarFmtE                   10I 0
      * Reply type
     D  rpyType                      10A
      * Reserved
     D  reserved_02                   2A
      * Maximum reply length
     D  maxRpyLen                    10I 0
      * Maximum reply decimal positions
     D  maxRpyDecPos                 10I 0
      * Offset of valid reply value entries
     D  ofsRpyE                      10I 0
      * Number of valid reply values entries returned
     D  numRpyER                     10I 0
      * Length of valid reply value entries returned
     D  lenRpyER                     10I 0
      * Length of valid reply value entries available
     D  lenRpyEA                     10I 0
      * Length of valid reply value entry
     D  lenRpyE                      10I 0
      * Offset of special reply value entries
     D  ofsSpcRpyE                   10I 0
      * Number of special reply values returned
     D  numSpcRpyER                  10I 0
      * Length of special reply value entries returned
     D  lenSpcRpyER                  10I 0
      * Length of special reply value entries available
     D  lenSpcRpyEA                  10I 0
      * Length of special reply value entry
     D  lenSpcRpyE                   10I 0
      * Offset of lower range reply value
     D  ofsLowRpyE                   10I 0
      * Length of lower range reply value returned
     D  lenLowRpyER                  10I 0
      * Length of lower range reply value available
     D  lenLowRpyEA                  10I 0
      * Offset of upper range reply value
     D  ofsUpRpyE                    10I 0
      * Length of upper range reply value returned
     D  ofsUpRpyER                   10I 0
      * Length of upper range reply value available
     D  ofsUpRpyEA                   10I 0
      * Offset of relational test entry
     D  ofsRelTestE                  10I 0
      * Length of relational test entry returned
     D  lenRelTestER                 10I 0
      * Length of relational test entry available
     D  lenRelTestEA                 10I 0
      * Message creation date
     D  crtDate                       7A
      * Reserved
     D  reserved_03                   1A
      * Message creation level number
     D  crtLvlNbr                    10I 0
      * Message modification date
     D  modDate                       7A
      * Reserved
     D  reserved_04                   1A
      * Message modification level number
     D  modLvlNbr                    10I 0
      * Stored CCSID of message
     D  storedCCSID                  10I 0
      * Offset of dump list entries
     D  ofsDmpListE                  10I 0
      * Number of dump list entries returned
     D  numDmpListER                 10I 0
      * Length of dump list entries returned
     D  lenDmpListER                 10I 0
      * Length of dump list entries available
     D  lenDmpListEA                 10I 0
      * Default program name
     D  dftPgmName                   10A
      * Default program library name
     D  dftPgmLib                    10A
      * Data
     D  data                       4096A
      *                       CHAR(*)  Default reply
      *                       CHAR(*)  Message
      *                       CHAR(*)  Message help
      *                       CHAR(*)  Substitution variable formats
      *                       CHAR(*)  Valid reply value entries
      *                       CHAR(*)  Special reply value entries
      *                       CHAR(*)  Lower range reply value
      *                       CHAR(*)  Upper range reply value
      *                       CHAR(*)  Relational test entry
      *                       CHAR(*)  Dump list entries
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDURL  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDURL     "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : URL                                     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(url_t)
      /DEFINE url_t
      *
      *  URL
     D url_t           S            446A   varying
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing H_SPEC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "H_SPEC    "
mbrtype =  "RPGLE     "
mbrtext =  "H-Specifications                                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
      /IF NOT DEFINED(NO_DECEDIT)
     H DECEDIT('0,')
      /ENDIF
     H DATEDIT(*DMY.)
     H DATFMT(*ISO ) TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
     H CCSID(*CHAR: *JOBRUN)
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing HEAPAPI  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "HEAPAPI   "
mbrtype =  "RPGLE     "
mbrtext =  "Storage Management APIs                           "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(HEAPAPI)
 DEF  /DEFINE HEAPAPI
      *
      *  Get Heap Storage (CEEGTST) API
     D CEEGTST...
     D                 PR
     D                                            extproc('CEEGTST')
     D  i_heap_id                    10I 0 const
     D  i_size                       10I 0 const
     D  o_address                      *
     D  o_fc                         12A          options(*omit)
      *
      *  Reallocate Storage (CEECZST) API
     D CEECZST...
     D                 PR
     D                                            extproc('CEECZST')
     D  io_address                     *
     D  i_new_size                   10I 0 const
     D  o_fc                         12A          options(*omit)
      *
      *  Free Storage (CEEFRST) API
     D CEEFRST...
     D                 PR
     D                                            extproc('CEEFRST')
     D  i_address                      *   const
     D  o_fc                         12A          options(*omit)
      *
      *  Allocation Strategy Type (CEE4ALC)
     D CEE4ALC         DS
     D   MaxSglAloc                  10I 0
     D   MinBdy                      10I 0
     D   CrtSiz                      10I 0
     D   ExtSiz                      10I 0
     D   res1                         5I 0
     D   AllocBits                    3U 0
     D   InitValue                    3U 0
     D   res2                         5A
      *
      *  Use BITON to set on the appropriate bit.
      *  For example:   BITON     AllocInit     AllocBits
     D ALC_ABITS_AllocStrat...
     D                 C                    x'80'
     D ALC_BITS_NoMark...
     D                 C                    x'40'
     D ALC_ABITS_BlkXfer...
     D                 C                    x'20'
     D ALC_ABITS_PAG...
     D                 C                    x'10'
     D ALC_ABITS_AllocInit...
     D                 C                    x'08'
      *
      *  Create Heap (CEECRHP) API
     D CEECRHP...
     D                 PR
     D                                            extproc('CEECRHP')
     D  o_heap_id                    10I 0
     D  i_initial_size...
     D                               10I 0 const  options(*omit)
     D  i_increment                  10I 0 const  options(*omit)
     D  i_alloc_start_id...
     D                               10I 0 const  options(*omit)
     D  o_fc                         12A          options(*omit)
      *
      *  Mark Heap (CEEMKHP) API
     D CEEMKHP...
     D                 PR
     D                                            extproc('CEEMKHP')
     D  i_heap_id                    10I 0 const
     D  o_mark                         *
     D  o_fc                         12A          options(*omit)
      *
      *  Release Heap (CEERLHP) API
     D CEERLHP...
     D                 PR
     D                                            extproc('CEERLHP')
     D  i_mark                         *   const
     D  o_fc                         12A          options(*omit)
      *
      *  Discard Heap (CEEDSHP) API
     D CEEDSHP...
     D                 PR
     D                                            extproc('CEEDSHP')
     D  i_heap_id                    10I 0 const
     D  o_fc                         12A          options(*omit)
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing MEMMGR  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "MEMMGR    "
mbrtype =  "RPGLE     "
mbrtext =  "BasicList - Memory Manager Prototypes             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *
     D mm_memMgr       DS                  likeds(MemoryManager...
     D                                            _manager_t)
      *
     D mm_allocate...
     D                 PR              *   extproc(mm_memMgr.pAllocate)
     D  i_size                       10U 0 value
     D  i_heap                       10I 0 value  options(*nopass)
      *
     D mm_reallocate...
     D                 PR              *   extproc(mm_memMgr.pReallocate)
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
     D mm_free...
     D                 PR                  extproc(mm_memMgr.pFree)
     D  io_pMem                        *
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing MILIB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "MILIB     "
mbrtype =  "RPGLE     "
mbrtext =  "Prototypes for MI-Library                (include)"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(MILIB)
 DEF  /DEFINE MILIB
      *
      *  QSYSINC/MIH.MICOMMON: Requested Authority bitmasks and typedef
      *                        The bitmasks are or'd together to give
      *                        desired combinations
     D AUTH_OBJ_CTRL   C                   const(x'8000')
     D AUTH_OBJ_MGMT   C                   const(x'4000')
     D AUTH_POINTER    C                   const(x'2000')
     D AUTH_SPACE      C                   const(x'1000')
     D AUTH_RETRIEVE   C                   const(x'0800')
     D AUTH_INSERT     C                   const(x'0400')
     D AUTH_DELETE     C                   const(x'0200')
     D AUTH_UPDATE     C                   const(x'0100')
     D AUTH_OWNER      C                   const(x'0080')
     D AUTH_EXCLUDED   C                   const(x'0040')
     D AUTH_LST_MGMT   C                   const(x'0020')
     D AUTH_EXECUTE    C                   const(x'0010')
     D AUTH_ALTER      C                   const(x'0008')
     D AUTH_REF        C                   const(x'0004')
     D AUTH_ALL        C                   const(x'FF1C')
     D AUTH_NONE       C                   const(x'0000')
      *
      *  QSYSINC/MIH.MIOBJTYP:  MI Object Type
     D MI_Program      C                   const(x'0201')
     D MI_Library      C                   const(x'0401')
     D MI_Usrspc       C                   const(x'1934')
     D MI_Usrq         C                   const(x'0A02')
     D MI_Usridx       C                   const(x'0E0A')
     D WLI_ALRTBL      C                   const(x'0E09')
     D WLI_AUTL        C                   const(x'1B01')
     D WLI_BLKSF       C                   const(x'1E05')
     D WLI_BNDDIR      C                   const(x'1937')
     D WLI_CFGL        C                   const(x'0E0D')
     D WLI_CHTFMT      C                   const(x'190D')
     D WLI_CLD         C                   const(x'190B')
     D WLI_CLS         C                   const(x'1904')
     D WLI_CMD         C                   const(x'1905')
     D WLI_CNNL        C                   const(x'1701')
     D WLI_COSD        C                   const(x'1401')
     D WLI_CRG         C                   const(x'192C')
     D WLI_CRQD        C                   const(x'0E0F')
     D WLI_CSI         C                   const(x'1935')
     D WLI_CSPMAP      C                   const(x'1922')
     D WLI_CSPTBL      C                   const(x'1923')
     D WLI_CTLD        C                   const(x'1201')
     D WLI_DDIR        C                   const(x'1F02')
     D WLI_DEVD        C                   const(x'1001')
     D WLI_DIR         C                   const(x'0C01')
     D WLI_DOC         C                   const(x'190E')
     D WLI_DSTMF       C                   const(x'1F01')
     D WLI_DTAARA      C                   const(x'190A')
     D WLI_DTADCT      C                   const(x'1920')
     D WLI_DTAQ        C                   const(x'0A01')
     D WLI_EDTD        C                   const(x'1908')
     D WLI_EXITRG      C                   const(x'1913')
     D WLI_FCT         C                   const(x'0E04')
     D WLI_FILE        C                   const(x'1901')
     D WLI_FLR         C                   const(x'1912')
     D WLI_FNTRSC      C                   const(x'1926')
     D WLI_FNTTBL      C                   const(x'192B')
     D WLI_FORMDF      C                   const(x'1928')
     D WLI_FTR         C                   const(x'0E0B')
     D WLI_GSS         C                   const(x'190C')
     D WLI_IGCDCT      C                   const(x'0E06')
     D WLI_IGCSRT      C                   const(x'191A')
     D WLI_IGCTBL      C                   const(x'1910')
     D WLI_IPXD        C                   const(x'191E')
     D WLI_JOBD        C                   const(x'1903')
     D WLI_JOBQ        C                   const(x'0E01')
     D WLI_JOBSCD      C                   const(x'0E0C')
     D WLI_JRN         C                   const(x'0901')
     D WLI_JRNRCV      C                   const(x'0701')
     D WLI_LIB         C                   const(x'0401')
     D WLI_LIND        C                   const(x'1101')
     D WLI_LOCALE      C                   const(x'1921')
     D WLI_MEDDFN      C                   const(x'191C')
     D WLI_MENU        C                   const(x'1916')
     D WLI_MGTCOL      C                   const(x'192D')
     D WLI_MODD        C                   const(x'1501')
     D WLI_MODULE      C                   const(x'0301')
     D WLI_MSGF        C                   const(x'0E03')
     D WLI_MSGQ        C                   const(x'1902')
     D WLI_M36         C                   const(x'1E04')
     D WLI_M36CFG      C                   const(x'1924')
     D WLI_NODL        C                   const(x'0E0E')
     D WLI_NTBD        C                   const(x'1914')
     D WLI_NWID        C                   const(x'1601')
     D WLI_NWSD        C                   const(x'1D01')
     D WLI_NODGRP      C                   const(x'192A')
     D WLI_OOPOOL      C                   const(x'2002')
     D WLI_OUTQ        C                   const(x'0E02')
     D WLI_OVL         C                   const(x'1929')
     D WLI_PAGDFN      C                   const(x'1936')
     D WLI_PAGSEG      C                   const(x'1927')
     D WLI_PDG         C                   const(x'1930')
     D WLI_PGM         C                   const(x'0201')
     D WLI_PNLGRP      C                   const(x'1915')
     D WLI_PRDAVL      C                   const(x'1933')
     D WLI_PRDDFN      C                   const(x'191B')
     D WLI_PRDLOD      C                   const(x'191D')
     D WLI_PSFCFG      C                   const(x'1925')
     D WLI_QMFORM      C                   const(x'1932')
     D WLI_QMQRY       C                   const(x'1931')
     D WLI_QRYDFN      C                   const(x'1911')
     D WLI_RCT         C                   const(x'0E08')
     D WLI_S36         C                   const(x'1919')
     D WLI_SBSD        C                   const(x'1909')
     D WLI_SCHIDX      C                   const(x'0E07')
     D WLI_SOCKET      C                   const(x'1E03')
     D WLI_SOMOBJ      C                   const(x'2001')
     D WLI_SPADCT      C                   const(x'1C01')
     D WLI_SQLPKG      C                   const(x'0202')
     D WLI_SQLUDT      C                   const(x'191F')
     D WLI_SRVPGM      C                   const(x'0203')
     D WLI_SSND        C                   const(x'0E05')
     D WLI_STMF        C                   const(x'1E01')
     D WLI_SVRSTG      C                   const(x'1917')
     D WLI_SYMLNK      C                   const(x'1E02')
     D WLI_TBL         C                   const(x'1906')
     D WLI_USRPRF      C                   const(x'0801')
     D WLI_USRIDX      C                   const(x'0E0A')
     D WLI_USRQ        C                   const(x'0A02')
     D WLI_USRSPC      C                   const(x'1934')
     D WLI_VLDL        C                   const(x'0E10')
     D WLI_WSCST       C                   const(x'1938')
      *
      *  Activate Bound Program, Returned value: Activation mark
     D QleActBndPgm    PR            10I 0 extproc('QleActBndPgm')
     D  i_pgmPtr                       *   const   procptr
     D  i_actMark                    10I 0 const   options(*omit)
     D  i_actInf                  32767A   const   options(*omit: *varsize)
     D  i_actInfLen                  10I 0 const   options(*omit)
     D  io_errCode                32767A           options(*omit: *varsize)
      *
      *  Type definitions
     D actInf_t        DS                  qualified      based(pDummy)
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     16A
     D  actGrpMark            17     20I 0
     D  actMark               21     24I 0
     D  reserved_2            25     31A
     D  flags                 32     32A
     D  reserved_3            33     48A
      *
      *  Get Export, Returned value: Exported item - PTR(OPN)
     D QleGetExp       PR              *   extproc('QleGetExp')
     D  i_actMark                    10I 0 const   options(*omit)
     D  i_expNum                     10I 0 const   options(*omit)
     D  i_expNameLen                 10I 0 const   options(*omit)
     D  i_expName                 32767A   const   options(*omit: *varsize)
     D  o_pExpItem                     *           options(*omit) procptr
     D  o_expItmType                 10I 0         options(*omit)
     D  io_errCode                32767A           options(*omit: *varsize)
      /IF NOT DEFINED(TESTPTR)
      /DEFINE TESTPTR
      *
      *  Test Pointer (TESTPTR)
     D testptr         PR            10I 0 extproc('_TESTPTR')
     D  i_ptr                          *   value
     D  i_test_type                  10I 0 value
      *
     D cTESTPTR_TYPE_PROCPTR...
     D                 C                   0
     D cTESTPTR_NO_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   0
     D cTESTPTR_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   1
      *
     D cTESTPTR_TYPE_MEMPTR...
     D                 C                   1
     D cTESTPTR_NON_TERASPACE...
     D                 C                   0
     D cTESTPTR_TERASPACE...
     D                 C                   1
      *
     D cTESTPTR_ERROR_NOT_EXIST...
     D                 C                   x'2401'
     D cTESTPTR_ERROR_INVALID...
     D                 C                   x'2402'
     D cTESTPTR_ERROR_OBJECT_DESTROYED...
     D                 C                   x'2202'
      /ENDIF
      *
      *  Materialize Pointer (MATPTR)
     D matptr          PR            10I 0 extproc('matptr')
     D  i_MPTR_Template_T...
     D                                 *   value
     D  i_anyPtr                       *   value
      *
     D matptr_TPL_t    DS                  qualified               based(pDummy)
     D  bytPrv                 1      4I 0
     D  bytAvl                 5      8I 0
     D  type                   9      9A
      *
     D matptr_spacePtr_TPL_t...
     D                 DS                  qualified               based(pDummy)
     D  baseInf                            likeds(matptr_TPL_t )
     D  ContextID             10     41A
     D   ContextType          10     10A
     D   ContextSubType...
     D                        11     11A
     D   ContextName          12     41A
     D  ObjectID              42     73A
     D   ObjectType           42     42A
     D   ObjectSubType...
     D                        43     43A
     D   ObjectName           44     73A
     D  offSpace              74     77I 0
     D  PtrTragetInf          78     79A
     D  reserved_1            80     80A
     D  extOffSpace           81     88I 0
      *
      *  Resolve System Pointer (RSLVSP)
     D rslvsp...
     D                 PR              *   extproc('rslvsp') procptr
     D  i_objtype                     5U 0 value
     D  i_obj                          *   value   options(*string)
     D  i_lib                          *   value   options(*string)
     D  i_auth                        5U 0 value
      *
      *  Convert Type (QLICVTTP) API
     D QLICVTTP...
     D                 PR                  extpgm('QLICVTTP')
     D  i_conversion                 10A   const
     D  io_symObjType                10A
     D  io_hexObjType                 5U 0
     D  io_errCode                32767A          options(*varsize)
      *
      *  AND String (ANDSTR)
     D ANDSTR...
     D                 PR                  extproc('_ANDSTR')
     D  i_pReceiver                    *   value
     D  i_pFirstSrc                    *   value
     D  i_pSecondSrc                   *   value
     D  i_length                     10U 0 value
      *
      *  OR String (ORSTR)
     D ORSTR...
     D                 PR                  extproc('_ORSTR')
     D  i_pReceiver                    *   value
     D  i_pFirstSrc                    *   value
     D  i_pSecondSrc                   *   value
     D  i_length                     10U 0 value
      *
      *  XOR (Exclusive Or) String (XORSTR)
     D XORSTR...
     D                 PR                  extproc('_XORSTR')
     D  i_pReceiver                    *   value
     D  i_pFirstSrc                    *   value
     D  i_pSecondSrc                   *   value
     D  i_length                     10U 0 value
      *
      *  Complement String (COMSTR)
     D COMSTR...
     D                 PR                  extproc('_COMSTR')
     D  i_pReceiver                    *   value
     D  i_pSource                      *   value
     D  i_length                     10U 0 value
      *
      *  The standard definition for time in the MI library (QSYSINC/MIH.MICOMMON):
     D mi_time_t       S              8A   inz
      *
      *  The following values can be OR'd for the Wait Options parameter
      *  on the WAITTIME invocation.
     D cWAIT_NORMAL...
     D                 C                   0                                    x'0000'
     D cWAIT_MOD_AS_ENTER...
     D                 C                   32768                                x'8000'
     D cWAIT_MOD_AS_LEAVE...
     D                 C                   16384                                x'4000'
     D cWAIT_MPL_SET...
     D                 C                   8192                                 x'2000'
     D cWAIT_SIGNALS...
     D                 C                   4096                                 x'1000'
      *
      *  Wait On Time (WAITTIME)
     D waitTime        PR                  extproc('waittime')
     D  pmi_time                           const  like(mi_time_t)
     D  option                        5I 0 value
      *
      *  Use mitime function to form an AS/400 system value for time
     D mitime          PR              *   extproc('mitime')
     D  mi_time                            const  like(mi_time_t)
     D  hour                         10I 0 value
     D  min                          10I 0 value
     D  sec                          10I 0 value
     D  hsec                         10I 0 value
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1  "
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Include             cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(D_BASIC)
      /DEFINE D_BASIC
      *
      * -----------------------------------------
      *  Constants
      * -----------------------------------------
      /IF NOT DEFINED(cTrue)
      /DEFINE cTrue
     D cTrue           C                   const(*on )
      /ENDIF
      *
      /IF NOT DEFINED(cFalse)
      /DEFINE cFalse
     D cFalse          C                   const(*off)
      /ENDIF
      *
      * -----------------------------------------
      *  Reference fields
      * -----------------------------------------
      *
      * -----------------------------------------
      *  Prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R1                   Messages
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      /COPY QBASICS1,PBASICS1R3                   Strings
      /COPY QBASICS1,PBASICS1R4                   Assert/This
      /COPY QBASICS1,PBASICS1R5                   Objects
      /COPY QBASICS1,PBASICS1R6                   Commands
      /COPY QBASICS1,PBASICS1R7                   Mathematics
      /COPY QBASICS1,PBASICS1R8                   Handle/Memory
      /COPY QBASICS1,PBASICS1R9                   Display Information
      /COPY QBASICS1,PBASICS1RA                   BasicList
      /COPY QBASICS1,PBASICS1RB                   BasicStack
      /COPY QBASICS1,PBASICS1RC                   BasicMap
      /COPY QBASICS1,PBASICS1RD                   Url
      /COPY QBASICS1,PBASICS1RE                   Date and Time
      /COPY QBASICS1,PBASICS1RF                   System Values
      /COPY QBASICS1,PBASICS1RG                   BasicProperties
      /COPY QBASICS1,PBASICS1RH                   MemoryBufferRdrWtr
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1C7  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1C7"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - C-Helpers           cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1C7)
      /DEFINE BASICS1C7
      *
      *  Returns a table of CRC-32's of all single-byte values (made by make_crc_table)
     D get_crc_table...
     D                 PR              *
     D                                     extproc('get_crc_table')
      *
      *  Returns a table of CRC-32's of all single-byte values (made by make_crc_table)
     D crc32...
     D                 PR                         like(uLong_t)
     D                                     extproc('crc32')
     D  i_crc                              value  like(uLong_t)
     D  i_pBuffer                      *   value
     D  i_length                           value  like(uInt_t )
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,CLIB                         C-Library
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RA  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RA"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicList           cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RA)
      /DEFINE BASICS1RA
      *
     D BasicList_handle_t...
     D                 S               *                      based(pDummy)
     D BasicList_type_t...
     D                 S             32A                      based(pDummy)
      *
     D cBASICLIST_REMOVE_ALL...
     D                 C                          const(-1)
      *
     D cBASICLIST_TYPE_UNKNOWN...
     D                 C                          const('*N')
     D cBASICLIST_TYPE_VSTRING...
     D                 C                          const('*VSTRING')
     D cBASICLIST_TYPE_CHARACTER...
     D                 C                          const('*CHAR')
     D cBASICLIST_TYPE_INTEGER...
     D                 C                          const('*INT')
     D cBASICLIST_TYPE_UINTEGER...
     D                 C                          const('*UINT')
     D cBASICLIST_TYPE_POINTER...
     D                 C                          const('*POINTER')
      *
      *  Creates a new BasicList.
     D BasicList_new...
     D                 PR                         like(BasicList_handle_t)
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_new+
     D                                     ')
     D  i_extType                          const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Clones a given BasicList.
     D BasicList_clone...
     D                 PR                         like(BasicList_handle_t)
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_clone+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Returns the element from the specified position.
     D BasicList_get...
     D                 PR              *
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_get+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Returns the string element from the specified position.
     D BasicList_getString...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getString+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Returns the pointer element from the specified position.
     D BasicList_getPointer...
     D                 PR              *
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getPointer+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Returns the type of the list.
     D BasicList_getListType...
     D                 PR                         like(BasicList_type_t  )
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getListType+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Returns the type of the list.
     D BasicList_isListTypeOf...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_isListTypeOf+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Checks an list entry for a given type.
     D BasicList_isTypeOf...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_isTypeOf+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_type                             const  like(BasicList_type_t  )
      *
      *  Returns the type of the specified list entry.
     D BasicList_getType...
     D                 PR                         like(BasicList_type_t  )
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getType+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Returns the size of of an element.
     D BasicList_getSize...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getSize+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Adds an element to a given BasicList.
     D BasicList_add...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_add+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass: *omit)
     D  i_type                             const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
      *
      *  Adds a NULL value to a given BasicList.
     D BasicList_addNull...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_addNull+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Adds a string element to a given BasicList.
     D BasicList_addString...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_addString+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_string                   4096A   const  varying
      *
      *  Adds a pointer element to a given BasicList.
     D BasicList_addPointer...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_addPointer+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pointer                      *   const
      *
      *  Searches the list for a given element.
     D BasicList_find...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_find+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Searches the list for a given string.
     D BasicList_findString...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_findString+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_string                   4096A   const  varying
      *
      *  Changes the element at the specified position in this list.
     D BasicList_set...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_set+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass: *omit)
     D  i_type                             const  like(BasicList_type_t  )
     D                                            options(*nopass: *omit)
      *
      *  Changes the element at the specified position to NULL.
     D BasicList_setNull...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_setNull+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Changes the string at the specified position in this list.
     D BasicList_setString...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_setString+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_string                   4096A   const  varying
      *
      *  Changes the pointer at the specified position in this list.
     D BasicList_setPointer...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_setPointer+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
     D  i_pointer                      *   const
      *
      *  Specifies an auto-sort function for this list.
     D BasicList_setAutoSort...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_setAutoSort+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pSortFnc                     *   const  procptr
      *
      *  Removes the element at the specified position in this list.
     D BasicList_remove...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_remove+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      *  Returns the number of lements in this list.
     D BasicList_getNumE...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getNumE+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Returns the heap ID of a given BasicList.
     D BasicList_getHeapID...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getHeapID+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Sorts a list using the specified sort function.
     D BasicList_sort...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_sort+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_pSortFnc                     *   const  procptr
      *
      *  Returns cTrue if a given list is sorted.
     D BasicList_isSorted...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_isSorted+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Removes all entries from a given list.
     D BasicList_clear...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_clear+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Returns the total size of memory used by this list.
     D BasicList_getTotalSize...
     D                 PR            20I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_getTotalSize+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Deletes a given BasicList.
     D BasicList_delete...
     D                 PR            10I 0
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_delete+
     D                                     ')
     D  io_pList                                  like(BasicList_handle_t)
      *
      *  Returns a BasicList NULL handle.
     D BasicList_null...
     D                 PR                         like(BasicList_handle_t)
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_null+
     D                                     ')
      *
      *  Checks a given BasicList handle for a NULL value.
     D BasicList_isNull...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_isNull+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
      *
      *  Checks a given BasicList entry for a NULL value.
     D BasicList_isNullValue...
     D                 PR              N
     D                                     extproc('BASICS1RA+
     D                                     _BasicList_isNullValue+
     D                                     ')
     D  i_pList                            const  like(BasicList_handle_t)
     D  i_index                      10I 0 const
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R4
      /COPY QBASICS1,PBASICS1R8
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RB"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicStack          cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RB)
      /DEFINE BASICS1RB
      *
     D BasicStack_handle_t...
     D                 S                   like(BasicList_handle_t)
     D                                     based(pDummy)
      *
      *  Creates a new BasicStack.
     D BasicStack_new...
     D                 PR                         like(BasicStack_handle_t  )
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_new+
     D                                     ')
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10U 0 const  options(*nopass: *omit)
      *
      *  Clones a given BasicStack.   (not yet implemented)
     D BasicStack_clone...
     D                 PR                         like(BasicStack_handle_t  )
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_clone+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Gets the last entry from top of the stack without removing it from stack.
     D BasicStack_peek...
     D                 PR              *
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_peek+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Removes the element at the top of the stack and returnns that element.
     D BasicStack_pop...
     D                 PR              *
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_pop+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const
     D  i_length                     10I 0 const
      *
      *  Pushes an item onto the top of the stack.
     D BasicStack_push...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_push+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Returns the size of of the element that is on top of this stack.
     D BasicStack_getSize...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_getSize+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Returns the number of elements in this stack.
     D BasicStack_getNumE...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_getNumE+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Returns the heap ID of a given BasicList.
     D BasicStack_getHeapID...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_getHeapID+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Removes all entries from a given stack.
     D BasicStack_clear...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_clear+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      *  Deletes a given BasicStack.
     D BasicStack_delete...
     D                 PR            10I 0
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_delete+
     D                                     ')
     D  io_pStack                                 like(BasicStack_handle_t  )
      *
      *  Returns a BasicStack NULL handle.
     D BasicStack_null...
     D                 PR                         like(BasicStack_handle_t  )
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_null+
     D                                     ')
      *
      *  Checks a given BasicStack handle for a NULL value.
     D BasicStack_isNull...
     D                 PR              N
     D                                     extproc('BASICS1RB+
     D                                     _BasicStack_isNull+
     D                                     ')
     D  i_pStack                           const  like(BasicStack_handle_t  )
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RA                    BasicList
      /COPY QBASICS1,PBASICS1R4                    Assert/This/Caller
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RC"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicMap            cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RC)
      /DEFINE BASICS1RC
      *
     D BasicMap_handle_t...
     D                 S                   like(BasicList_handle_t)
     D                                                     based(pDummy)
     D BasicMap_key_t...
     D                 S           4096A   varying         based(pDummy)
      *
     D BasicKeySet_handle_t...
     D                 S               *                   based(pDummy)
      *
      *  Creates a new BasicMap.
     D BasicMap_new...
     D                 PR                         like(BasicMap_handle_t )
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_new+
     D                                     ')
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Clones a given BasicMap.
     D BasicMap_clone...
     D                 PR                         like(BasicMap_handle_t )
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_clone+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Removes the mapping for this key from this map if it is present.
     D BasicMap_remove...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_remove+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns true if this map contains a mapping for the specified key.
     D BasicMap_containsKey...
     D                 PR              N
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_containsKey+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns the value to which this map maps the specified key.
     D BasicMap_get...
     D                 PR              *
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_get+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Returns the string value to which this map maps the specified key.
     D BasicMap_getString...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getString+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns the integer value to which this map maps the specified key.
     D BasicMap_getInteger...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getInteger+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns the value addressed by a given index.
     D BasicMap_getValueByIndex...
     D                 PR              *
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getValueByIndex+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
     D  i_pEntry                       *   const  options(*nopass)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Returns the key addressed by a given index.
     D BasicMap_getKeyByIndex...
     D                 PR                         like(BasicMap_key_t )
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getKeyByIndex+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
     D BasicMap_put...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_put+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_pEntry                       *   const  options(*string)
     D  i_length                     10I 0 const  options(*nopass)
      *
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
     D BasicMap_putString...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_putString+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_string                   4096A   const  varying
      *
      *  Associates the specified value with the specified key in this map.
      *  If the map previously contained a mapping for this key, the old
      *  value is replaced by the specified value.
     D BasicMap_putInteger...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_putInteger+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
     D  i_integer                    10I 0 const
      *
      *  Returns the size of of the element that is associated with this key.
     D BasicMap_getSize...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getSize+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns the size of of the element that is addressed by a given index.
     D BasicMap_getSizeByIndex...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getSizeByIndex+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_index                      10I 0 const
      *
      *  Returns the number of key-value mappings in this map.
     D BasicMap_getNumE...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getNumE+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Returns the heap ID of a given BasicMap.
     D BasicMap_getHeapID...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getHeapID+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Returns a list of all keys that are in a given map.
     D BasicMap_getKeys...
     D                 PR                         like(BasicList_handle_t)
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getKeys+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_pSortFnc                     *   const  procptr
     D                                            options(*nopass)
      *
      *  Returns a list of all values that are in a given map.
     D BasicMap_getValues...
     D                 PR                         like(BasicList_handle_t)
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_getValues+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
     D  i_pSortFnc                     *   const  procptr
     D                                            options(*nopass)
      *
      *  Removes all entries from a given map.
     D BasicMap_clear...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_clear+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Deletes a given BasicMap.
     D BasicMap_delete...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_delete+
     D                                     ')
     D  io_pMap                                   like(BasicMap_handle_t )
      *
      *  Returns a BasicMap NULL handle.
     D BasicMap_null...
     D                 PR                         like(BasicMap_handle_t )
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_null+
     D                                     ')
      *
      *  Checks a given BasicMap handle for a NULL value.
     D BasicMap_isNull...
     D                 PR              N
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_isNull+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Produces a list of keys from a given map.
     D BasicMap_newKeySet...
     D                 PR                         like(BasicKeySet_handle_t)
     D                                     extproc('BASICS1RC+
     D                                     _BasicMap_newKeySet+
     D                                     ')
     D  i_pMap                             const  like(BasicMap_handle_t )
      *
      *  Returns the first entry of a given key set.
     D BasicKeySet_getFirst...
     D                 PR                         like(BasicMap_key_t    )
     D                                     extproc('BASICS1RC+
     D                                     _BasicKeySet_getFirst+
     D                                     ')
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  Returns the next entry of a given key set.
     D BasicKeySet_getNext...
     D                 PR                         like(BasicMap_key_t    )
     D                                     extproc('BASICS1RC+
     D                                     _BasicKeySet_getNext+
     D                                     ')
     D  i_pKeySet                          const  like(BasicKeySet_handle_t)
      *
      *  Deletes the key list associated to a given map.
     D BasicKeySet_delete...
     D                 PR            10I 0
     D                                     extproc('BASICS1RC+
     D                                     _BasicKeySet_delete+
     D                                     ')
     D  io_pKeySet                                like(BasicKeySet_handle_t)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1RA                    BasicList
      /COPY QBASICS1,PBASICS1R4                    Assert/This/Caller
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RD  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RD"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - URL                 cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RD)
      /DEFINE BASICS1RD
      *
      /COPY QBASICS1,FDURL
      *
      *  Error ocdes
     D cURL_ERROR_EMPTY_URL...
     D                 C                   -1
     D cURL_ERROR_NO_PROTOCOL...
     D                 C                   -2
     D cURL_ERROR_UNSUPPORTED_PROTOCOL...
     D                 C                   -3
     D cURL_ERROR_INVALID_PORT_NUMBER...
     D                 C                   -4
     D cURL_ERROR_UNSUPPORTED_OPERATION...
     D                 C                   -5
     D cURL_ERROR_INVALID_OBJECT_DATA...
     D                 C                   -6
      *
      *  Creates a new URL.
     D Url_new...
     D                 PR                         like(url_t )
     D                                     extproc('BASICS1RD+
     D                                     _Url_new+
     D                                     ')
     D  i_url                              const  like(url_t )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the protocol of a given URL.
     D Url_getProtocol...
     D                 PR                         like(url_t )
     D                                     extproc('BASICS1RD+
     D                                     _Url_getProtocol+
     D                                     ')
     D  i_url                              const  like(url_t )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the protocol of a given URL.
     D Url_setProtocol...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setProtocol+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_protocol                         const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the host name of a given URL.
     D Url_getHost...
     D                 PR                         like(url_t )
     D                                     extproc('BASICS1RD+
     D                                     _Url_getHost+
     D                                     ')
     D  i_url                              const  like(url_t )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the host name of a given URL.
     D Url_setHost...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setHost+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_host                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the port of a given URL.
     D Url_getPort...
     D                 PR            10I 0
     D                                     extproc('BASICS1RD+
     D                                     _Url_getPort+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the port number of a given URL.
     D Url_setPort...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setPort+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_port                       10I 0 const
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the path name of a given URL.
     D Url_getPath...
     D                 PR                         like(url_t    )
     D                                     extproc('BASICS1RD+
     D                                     _Url_getPath+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the path of a given URL.
     D Url_setPath...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setPath+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_path                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the file name of a given URL.
     D Url_getFile...
     D                 PR                         like(url_t    )
     D                                     extproc('BASICS1RD+
     D                                     _Url_getFile+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the file of a given URL.
     D Url_setFile...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setFile+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_file                             const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the query part of a given URL.
     D Url_getQuery...
     D                 PR                         like(url_t    )
     D                                     extproc('BASICS1RD+
     D                                     _Url_getQuery+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Sets the query part of a given URL.
     D Url_setQuery...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_setQuery+
     D                                     ')
     D  io_url                                    like(url_t )
     D  i_query                            const  like(url_t ) options(*varsize)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the string representation of a given URL.
     D Url_toString...
     D                 PR           512A          varying
     D                                     extproc('BASICS1RD+
     D                                     _Url_toString+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      *  Returns the library, file and member of a URL of type 'mbr'.
     D Url_getMbr...
     D                 PR              N
     D                                     extproc('BASICS1RD+
     D                                     _Url_getMbr+
     D                                     ')
     D  i_url                              const  like(url_t    )
     D  o_file                       10A          options(*nopass: *omit)
     D  o_lib                        10A          options(*nopass: *omit)
     D  o_mbr                        10A          options(*nopass: *omit)
     D  o_rc                         10I 0        options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RE  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RE"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Date and Time       cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RE)
      /DEFINE BASICS1RE
      *
      *  Produces a date from a given year, month and day.
     D f_dateSerial...
     D                 PR              d
     D                                     extproc('BASICS1RE+
     D                                     _f_dateSerial+
     D                                     ')
     D  i_year                       10i 0 const
     D  i_month                      10i 0 const
     D  i_day                        10i 0 const
      *
      *  Converts an epoch date to a RPG timestamp.
     D f_cvtEpochTS...
     D                 PR              z
     D                                     extproc('BASICS1RE+
     D                                     _f_cvtEpochTS+
     D                                     ')
     D  i_epochSecs                  10i 0 const
     D  i_adjustUTC                    n   const options(*nopass: *omit)
      *
      *  Converts a RPG timestamp to an epoch value.
     D f_cvtTSEpoch...
     D                 PR            10i 0
     D                                     extproc('BASICS1RE+
     D                                     _f_cvtTSEpoch+
     D                                     ')
     D  i_timestamp                    z   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)
      *
      *  Converts a MI time value to a RPG timestamp.
     D f_cvtMiTimeTS...
     D                 PR              z
     D                                     extproc('BASICS1RE+
     D                                     _f_cvtMiTimeTS+
     D                                     ')
     D  i_miTime                     20a   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)
      *
      *  Converts a RPG timestamp to a MI time value.
     D f_cvtTSMiTime...
     D                 PR            20a
     D                                     extproc('BASICS1RE+
     D                                     _f_cvtTSMiTime+
     D                                     ')
     D  i_timestamp                    z   const
     D  i_adjustUTC                    n   const options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RF  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RF"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - System Values       cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RF)
      /DEFINE BASICS1RF
      *
      *  Retrieves an alpha-numeric system value.
     D f_rtvSysVal_char...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1RE+
     D                                     _f_rtvSysVal_char+
     D                                     ')
     D  i_name                       10A   const
     D  o_msg                                     likeds(msg_t )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves a numeric system value.
     D f_rtvSysVal_num...
     D                 PR            15P 5
     D                                     extproc('BASICS1RE+
     D                                     _f_rtvSysVal_num+
     D                                     ')
     D  i_name                       10A   const
     D  o_msg                                     likeds(msg_t )
     D                                            options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RG  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RG"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - BasicProperties     cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RG)
      /DEFINE BASICS1RG
      *
     D BasicProperties_handle_t...
     D                 S               *                      based(pDummy)
      *
     D BasicProperties_decVal_t...
     D                 S             31P10                    based(pDummy)
      *
      *  Creates a new BasicProperties.
     D BasicProperties_new...
     D                 PR                         like(BasicProperties_handle_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_new+
     D                                     ')
     D  i_increment                  10U 0 const  options(*nopass: *omit)
     D  i_heapID                     10I 0 const  options(*nopass: *omit)
      *
      *  Clones a given BasicProperties.
     D BasicProperties_clone...
     D                 PR                         like(BasicProperties_handle_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_clone+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Load properties from a given physical file member.
     D BasicProperties_loadFromMember...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_loadFromMember+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_file                       10A   const  varying
     D  i_lib                        10A   const  varying
     D                                            options(*nopass: *omit)
     D  i_mbr                        10A   const  varying
     D                                            options(*nopass: *omit)
      *
      *  Load properties from a given stream file.
     D BasicProperties_loadFromStmf...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_loadFromStmf+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_stmf                     5000A   const  varying options(*varsize)
      *
      *  Removes the entry that is associated to the specified key.
     D BasicProperties_remove...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_remove+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t    )
     D                                            options(*varsize)
      *
      *  Returns true if the list of properties contains a entry matching
      *  the specified key value.
     D BasicProperties_containsKey...
     D                 PR              N
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_containsKey+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
      *
      *  Returns the string that is associated to the specified key.
     D BasicProperties_getString...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getString+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                  4096A   const  varying
     D                                            options(*nopass: *varsize)
      *
      *  Returns the integer value that is associated to the specified key.
     D BasicProperties_getInteger...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getInteger+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                    10I 0 const  options(*nopass)
      *
      *  Returns the boolean value that is associated to the specified key.
     D BasicProperties_getBoolean...
     D                 PR              N
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getBoolean+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                      N   const  options(*nopass)
      *
      *  Returns the decimal value that is associated to the specified key.
     D BasicProperties_getDecimal...
     D                 PR                         like(BasicProperties_decVal_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getDecimal+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_default                          const  like(BasicProperties_decVal_t)
     D                                            options(*nopass)
      *
      *  Associates the specified string value to a given key.
     D BasicProperties_putString...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_putString+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_string                   4096A   const  varying
     D                                            options(*varsize)
      *
      *  Associates the specified integer value to a given key.
     D BasicProperties_putInteger...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_putInteger+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_integer                    10I 0 const
      *
      *  Associates the specified boolean value to a given key.
     D BasicProperties_putBoolean...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_putBoolean+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_boolean                      N   const
      *
      *  Associates the specified decimal value to a given key.
     D BasicProperties_putDecimal...
     D                 PR                         like(BasicProperties_decVal_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_putDecimal+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
     D  i_key                              const  like(BasicMap_key_t          )
     D                                            options(*varsize)
     D  i_decimal                          const  like(BasicProperties_decVal_t)
      *
      *  Returns the number of key-value mappings in this properties list.
     D BasicProperties_getNumE...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getNumE+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Returns the heap ID of a given BasicProperties.
     D BasicProperties_getHeapID...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_getHeapID+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Removes all entries from a given properties list.
     D BasicProperties_clear...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_clear+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Deletes a given BasicProperties.
     D BasicProperties_delete...
     D                 PR            10I 0
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_delete+
     D                                     ')
     D  io_pProperties...
     D                                            like(BasicProperties_handle_t)
      *
      *  Returns a BasicProperties NULL handle.
     D BasicProperties_null...
     D                 PR                         like(BasicProperties_handle_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_null+
     D                                     ')
      *
      *  Checks a given BasicProperties handle for a NULL value.
     D BasicProperties_isNull...
     D                 PR              N
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_isNull+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      *  Returns the list of key values from a given properties list.
     D BasicProperties_newKeySet...
     D                 PR                         like(BasicKeySet_handle_t)
     D                                     extproc('BASICS1RG+
     D                                     _BasicProperties_newKeySet+
     D                                     ')
     D  i_pProperties                      const  like(BasicProperties_handle_t)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1RH  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1RH"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - MemoryBufferRdrWtr  cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1RH)
      /DEFINE BASICS1RH
      *
      /COPY QBASICS1,CLIB                          C Runtime Library
      *
     D memWtr_handle_t...
     D                 S             10I 0                    based(pDummy)
     D memRdr_handle_t...
     D                 S             10I 0                    based(pDummy)
      *
      *  Creates a memory buffer writer.
     D MemoryWriter_new...
     D                 PR                         like(memWtr_handle_t)
     D                                     extproc('BASICS1RH+
     D                                     _MemoryWriter_new+
     D                                     ')
     D  i_pBuffer                      *   value
     D  i_maxSize                          value  like(size_t         )
      *
      *  Write to a given memory buffer descriptor.
     D MemoryWriter_write...
     D                 PR                          like(ssize_t       )         = ssize_t
     D                                     extproc('BASICS1RH+
     D                                     _MemoryWriter_write+
     D                                     ')
     D  i_fd                               value  like(memWtr_handle_t)         = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_buflen                           value  like(size_t         )         = size_t
      *
      *  Deletes a given memory buffer writer.
     D MemoryWriter_delete...
     D                 PR
     D                                     extproc('BASICS1RH+
     D                                     _MemoryWriter_delete+
     D                                     ')
     D  io_fd                                     like(memWtr_handle_t)
      *
      *  Returns the 'write' procedure of a MemoryWriter.
     D MemoryWriter_writeProc...
     D                 PR              *          procptr
     D                                     extproc('BASICS1RH+
     D                                     _MemoryWriter_writeProc+
     D                                     ')
      *
      *  Creates a memory buffer reader.
     D MemoryReader_new...
     D                 PR                         like(memRdr_handle_t)
     D                                     extproc('BASICS1RH+
     D                                     _MemoryReader_new+
     D                                     ')
     D  i_pBuffer                      *   value
     D  i_size                             value  like(size_t         )
      *
      *  Reads from a given memory buffer descriptor.
     D MemoryReader_read...
     D                 PR                         like(ssize_t        )         = ssize_t
     D                                     extproc('BASICS1RH+
     D                                     _MemoryReader_read+
     D                                     ')
     D  i_fd                               value  like(memRdr_handle_t)         = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_nByte                            value  like(size_t    )              = size_t
      *
      *  Deletes a given memory buffer Reader.
     D MemoryReader_delete...
     D                 PR
     D                                     extproc('BASICS1RH+
     D                                     _MemoryReader_delete+
     D                                     ')
     D  io_fd                                     like(memRdr_handle_t)
      *
      *  Returns the 'read' procedure of a MemoryReader.
     D MemoryReader_readProc...
     D                 PR              *          procptr
     D                                     extproc('BASICS1RH+
     D                                     _MemoryReader_readProc+
     D                                     ')
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R1"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Messages            cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(PBASICSR1)
      /DEFINE PBASICSR1
      *
      *  Reference fields
      /COPY QBASICS1,FDMSG
      /COPY QBASICS1,FDRCVM0200
      /COPY QBASICS1,FDRCVM0300
      /COPY QBASICS1,FDRTVM0100
      /COPY QBASICS1,FDRTVM0300
      /COPY QBASICS1,FDRTVM0400
      *
      *  Constants
      *
      *  Message ID special values:
     D cMSG_ID_OK      C                   const('*OK')
     D cMSG_ID_NONE    C                   const('')
     D cMSG_ID_NULL    C                   const('*NULL')
      *
      *  Parameter: Stack Counter
     D cMsg_AllInact   C                   const(-4)                             - / - /rmv
     D cMsg_Ext        C                   const(-1)                            snd/rcv/rmv
     D cMsg_Prv        C                   const(-2)                            snd/rcv/rmv
     D cMsg_Same       C                   const(-3)                            snd/rcv/rmv
      *
      *  Parameter: Procedure
     D cMsg_ToMyself   C                   const('*')                           snd/rcv/rmv
     D cMsg_ToPgmBdy   C                   const('*PGMBDY')                     snd/ - / -
     D cMsg_ToCtlBdy   C                   const('*CTLBDY')                     snd/ - / -
     D cMsg_ToPgm      C                   const('*PGMNAME')                    snd/ - / -
      *
      *  Parameter: Message Type
     D cMsg_Any        C                   const('*ANY')                         - /rcv/ -
     D cMsg_Comp       C                   const('*COMP')                       snd/rcv/ -
     D cMsg_Copy       C                   const('*COPY')                        - /rcv/ -
     D cMsg_Diag       C                   const('*DIAG')                       snd/rcv/ -
     D cMsg_Escape     C                   const('*ESCAPE')                     snd/rcv/ -
     D cMsg_Escp       C                   const('*EXCP')                        - /rcv/ -
     D cMsg_First      C                   const('*FIRST')                       - /rcv/ -
     D cMsg_Info       C                   const('*INFO')                       snd/rcv/ -
     D cMsg_Inq        C                   const('*INQ')                        snd/ - / -
     D cMsg_Last       C                   const('*LAST')                        --/rcv/ -
     D cMsg_Next       C                   const('*NEXT')                        --/rcv/ -
     D cMsg_Notify     C                   const('*NOTIFY')                     snd/rcv/ -
     D cMsg_Previous   C                   const('*PRV')                         --/rcv/ -
     D cMsg_Rpy        C                   const('*RPY')                         --/rcv/ -
     D cMsg_Rqs        C                   const('*RQS')                        snd/rcv/ -
     D cMsg_Status     C                   const('*STATUS')                     snd/ - / -
      *
      *  Parameter: Action
     D cMsg_Act_Old    C                   const('*OLD')                         - /rcv/ -
     D cMsg_Act_Rmv    C                   const('*REMOVE')                      - /rcv/ -
     D cMsg_Act_Same   C                   const('*SAME')                        - /rcv/ -
      *
      *  Parameter: Message to remove
     D cMsg_Rmv_All    C                   const('*ALL')                         - / - /rmv
     D cMsg_Rmv_ByKey  C                   const('*BYKEY')                       - / - /rmv
     D cMsg_Rmv_New    C                   const('*NEW')                         - / - /rmv
     D cMsg_Rmv_Old    C                   const('*OLD')                         - / - /rmv
     D cMsg_Rmv_Scope  C                   const('*SCOPE')                       - / - /rmv
      *
      *  Retrieve message help text
     D cMsg_RtnCtrlChar_Yes...
     D                 C                   const('*YES')
     D cMsg_RtnCtrlChar_No...
     D                 C                   const('*NO')
      *
      *  Sets the application message file.
     D p_setAppMsgFile...
     D                 PR
     D                                     extproc('BASICS1R1+
     D                                     _p_setAppMsgFile+
     D                                     ')
     D  i_file                       10A   const  options(*nopass)
     D  i_lib                        10A   const  options(*nopass)
      *
      *  Creates a new message.
     D f_newMsg...
     D                 PR                         likeds(msg_t     )
     D                                     extproc('BASICS1R1+
     D                                     _f_newMsg+
     D                                     ')
     D  i_ID                               const  like(msg_t.id    )
     D                                            options(*omit: *nopass)
     D  i_data                      512A   const  varying
     D                                            options(*omit: *nopass)
     D  i_type                             const  like(msg_t.type  )
     D                                            options(*omit: *nopass)
     D  i_file                             const  like(msg_t.file  )
     D                                            options(*omit: *nopass)
     D  i_lib                              const  like(msg_t.lib   )
     D                                            options(*omit: *nopass)
      *
      *  Sends a program message.
     D f_sndPgmMsg...
     D                 PR             4A
     D                                     extproc('BASICS1R1+
     D                                     _f_sndPgmMsg+
     D                                     ')
     D  i_msg                              const  likeds(msg_t   )
     D  i_toStkC                     10I 0 const  options(*nopass: *omit)
     D  i_toProc                    256A   const  options(*nopass: *omit)
     D  i_toMod                      10A   const  options(*nopass: *omit)
     D  i_toPgm                      10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Receives a program message.
     D f_rcvPgmMsg...
     D                 PR                         likeds(rcvm0200_t)
     D                                     extproc('BASICS1R1+
     D                                     _f_rcvPgmMsg+
     D                                     ')
     D  i_msgType                    10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_action                     10A   const  options(*nopass: *omit)
     D  i_wait                       10I 0 const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Removes a program message.
     D p_rmvPgmMsg...
     D                 PR
     D                                     extproc('BASICS1R1+
     D                                     _p_rmvPgmMsg+
     D                                     ')
     D  i_msgToRemove                10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves the message text of a given message.
      *  Replaces substitution variables with message data.
     D f_rtvMsgText...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R1+
     D                                     _f_rtvMsgText+
     D                                     ')
     D  i_msg                              const  likeds(msg_t    )
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves the message help text of a given message.
      *  Replaces substitution variables with message data.
     D f_rtvMsgHelpText...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R1+
     D                                     _f_rtvMsgHelpText+
     D                                     ')
     D  i_msg                              const  likeds(msg_t    )
     D  i_rtnCtrlChr                 10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves the message text of a given message.
      *  Does not replace substitution variables with message data.
     D f_rtvMsgTextRaw...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R1+
     D                                     _f_rtvMsgTextRaw+
     D                                     ')
     D  i_msg                              const  likeds(msg_t    )
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves the message help text of a given message.
      *  Does not replace substitution variables with message data.
     D f_rtvMsgHelpTextRaw...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R1+
     D                                     _f_rtvMsgHelpTextRaw+
     D                                     ')
     D  i_msg                              const  likeds(msg_t    )
     D  i_rtnCtrlChr                 10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Converts a received message of format RCVM0200 to a message.
     D f_cvtRcvMsgToMsg...
     D                 PR                         likeds(msg_t     )
     D                                     extproc('BASICS1R1+
     D                                     _f_cvtRcvMsgToMsg+
     D                                     ')
     D  i_rcvm0200                         const  likeds(rcvm0200_t)
     D  i_type                             const  like(msg_t.type  )
     D                                            options(*omit: *nopass)
      *
      *  Receives a program message and returns a message structure.
     D f_rcvPgmMsgObj...
     D                 PR                         likeds(msg_t )
     D                                     extproc('BASICS1R1+
     D                                     _f_rcvPgmMsgObj+
     D                                     ')
     D  i_msgType                    10A   const
     D  i_msgKey                      4A   const  options(*nopass: *omit)
     D  i_action                     10A   const  options(*nopass: *omit)
     D  i_wait                       10I 0 const  options(*nopass: *omit)
     D  i_fromStkC                   10I 0 const  options(*nopass: *omit)
     D  i_fromProc                  256A   const  options(*nopass: *omit)
     D  i_fromMod                    10A   const  options(*nopass: *omit)
     D  i_fromPgm                    10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Returns the sender information of a receives program message.
     D f_getSndInfOfRcvMsg...
     D                 PR                         likeds(sndInf_t  )
     D                                     extproc('BASICS1R1+
     D                                     _f_getSndInfOfRcvMsg+
     D                                     ')
     D  i_rcvm0200                         const  likeds(rcvm0200_t)
     D  o_longSndPgm                256A          options(*nopass: *omit)
     D  o_longSndPrc                256A          options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      /COPY QBASICS1,PBASICS1R4                   Assert/THIS
      /COPY QBASICS1,PBASICS1R5                   Objects
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R2  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R2"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - API Error Handling  cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R2)
      /DEFINE BASICS1R2
      *
      *  Reference fields
      /COPY QBASICS1,FDERRCODE
      *
      *  Creates a new API error code.
     D f_newApiErrCode...
     D                 PR                         likeds(errCode_t )
     D                                     extproc('BASICS1R2+
     D                                     _f_newApiErrCode+
     D                                     ')
     D  i_monMsg                       N   const  options(*nopass)
      *
      *  Is API error?
     D f_isApiError...
     D                 PR              N
     D                                     extproc('BASICS1R2+
     D                                     _f_isApiError+
     D                                     ')
     D  i_errCode                          const  likeds(errCode_t )
      *
      *  Converts an API error code to a messsage.
     D f_cvtApiErrCodeToMsg...
     D                 PR                         like(msg_t     )
     D                                     extproc('BASICS1R2+
     D                                     _f_cvtApiErrCodeToMsg+
     D                                     ')
     D  i_errCode                          const  likeds(errCode_t )
      *
      *  Returns the C runtime error number.
     D f_errno...
     D                 PR            10I 0
     D                                     extproc('BASICS1R2+
     D                                     _f_errno+
     D                                     ')
      *
      *  Sets the C runtime error number to ZERO (no error).
     D f_clrErrno...
     D                 PR
     D                                     extproc('BASICS1R2+
     D                                     _f_clrErrno+
     D                                     ')
      *
      *  Sets the C runtime error number to a given error code.
     D f_setErrno...
     D                 PR
     D                                     extproc('BASICS1R2+
     D                                     _f_setErrno+
     D                                     ')
     D  i_errno                      10I 0 const
      *
      *  Returns the message text of a C runtime error number.
     D f_strerror...
     D                 PR           128A          varying
     D                                     extproc('BASICS1R2+
     D                                     _f_strerror+
     D                                     ')
     D  i_errno                      10I 0 const
      *
      *  Converts a C runtime error number to a message.
     D f_cvtErrnoToMsg...
     D                 PR                         like(msg_t     )
     D                                     extproc('BASICS1R2+
     D                                     _f_cvtErrnoToMsg+
     D                                     ')
     D  i_errno                      10I 0 const
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R1                   Messages
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R3  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R3"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Strings             cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R3)
      /DEFINE BASICS1R3
      *
      *  Reference fields
      *
      *  Konstants: f_wordWrap()
     D cWORDWRAP_PARAGRAPH_NONE...
     D                 C                   const(1)
     D cWORDWRAP_PARAGRAPH_MSGD...
     D                 C                   const(2)
     D cWORDWRAP_PARAGRAPH_TEXT...
     D                 C                   const(4)
     D cWORDWRAP_PARAGRAPH_TRIMR...
     D                 C                   const(8)
      *
      *  Returns the left portion of a string.
     D f_left...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_left+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_length                     10I 0 const
      *
      *  Returns the sub string that starts at a given position.
     D f_mid...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_mid+
     D                                     ')
     D  i_string                   4096A   const   varying
     D                                             options(*varsize)
     D  i_start                      10I 0 const
     D  i_length                     10I 0 const   options(*nopass: *omit)
      *
      *  Tests if the specified string starts with the specified prefix.
     D f_startsWith...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_startsWith+
     D                                     ')
     D  i_prefix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Tests if the specified string starts with the specified prefix,
      *  ignoring case considerations.
     D f_startsWithIgnoreCase...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_startsWithIgnoreCase+
     D                                     ')
     D  i_prefix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Returns the right portion of a string.
     D f_right...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_right+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_length                     10I 0 const
      *
      *  Tests if the specified string ends with the specified suffix.
     D f_endsWith...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_endsWith+
     D                                     ')
     D  i_suffix                   4096A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Produces an empty string.
     D f_space...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_space+
     D                                     ')
     D  i_length                     10I 0 const
     D  i_char                        1A   const   options(*nopass)
      *
      *  Converts a given string to lower case.
     D f_lcase...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_lcase+
     D                                     ')
     D  i_string                   4096A   const   varying
      *
      *  Converts a given string to upper case.
     D f_ucase...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_ucase+
     D                                     ')
     D  i_string                   4096A   const   varying
      *
      *  Replaces all occurences of a search argument by
      *  a replacement string in a given string.
     D f_replace...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_replace+
     D                                     ')
     D  i_searchArg                4096A   const  varying
     D  i_rplString                4096A   const  varying
     D  i_string                   4096A   const  varying
     D  i_startPos                   10U 0 const  options(*nopass)
      *
      *  Returns the EBCDIC value of a given character.
     D f_ebcdic...
     D                 PR             3U 0
     D                                     extproc('BASICS1R3+
     D                                     _f_ebcdic+
     D                                     ')
     D  i_char                        1A   const   options(*nopass)
      *
      *  Returns the numeric value of a string.
     D f_val...
     D                 PR             8F
     D                                     extproc('BASICS1R3+
     D                                     _f_val+
     D                                     ')
     D  i_string                     64A   const  varying
     D  i_decPoint                    1A   const  options(*nopass)
     D  i_comma                       1A   const  options(*nopass)
     D  i_currSym                     1A   const  options(*nopass)
      *
      *  Performs word wrapping on a given string.
      *  Returns the next line of i_string with each call to f_wordWrap().
     D f_wordWrap...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_wordWrap+
     D                                     ')
     D  i_string                   4096A   const  varying
     D  i_width                      10U 0 const
     D  io_startPos                  10U 0
     D  i_options                    10U 0 const  options(*nopass)
      *
      *  Transforms a numeric from its internal format to a
      *  character form suitable for displaying.
     D f_editCode...
     D                 PR            64A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_editCode+
     D                                     ')
     D  i_pBuffer                      *   const
     D  i_digits                     10I 0 const
     D  i_decPos                     10I 0 const
     D  i_varClass                   10A   const
     D  i_editCode                    2A   const
      *
      *  Transforms a numeric from its internal format to a
      *  character form suitable for displaying.
     D f_editWord...
     D                 PR           512A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_editWord+
     D                                     ')
     D  i_pBuffer                      *   const
     D  i_digits                     10I 0 const
     D  i_varClass                   10A   const
     D  i_editWord                  256A   const  varying
      *
      *  Gets the length of a the formatted string of a given edit code.
     D f_getLengthEditCode...
     D                 PR             5U 0
     D                                     extproc('BASICS1R3+
     D                                     _f_getLengthEditCode+
     D                                     ')
     D  i_digits                     10I 0 const
     D  i_decPos                     10I 0 const
     D  i_editCode                    2A   const
      *
      *  Gets the length of a the formatted string of a given edit word.
     D f_getLengthEditWord...
     D                 PR             5U 0
     D                                     extproc('BASICS1R3+
     D                                     _f_getLengthEditWord+
     D                                     ')
     D  i_digits                     10I 0 const
     D  i_editWord                  256A   const  varying
      *
      *  Removes a keyword from a given string.
     D f_rmvKeyword...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_rmvKeyword+
     D                                     ')
     D  i_keyword                   128A   const   varying
     D  i_string                   4096A   const   varying
      *
      *  Removes quotes from a given string.
     D f_rmvQuotes...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_rmvQuotes+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_quote                       1A   const
      *
      *  Adds quotes to a given string.
     D f_addQuotes...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_addQuotes+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_quote                       1A   const   options(*nopass)
      *
      *  Centers a string.
     D f_center...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_center+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_length                     10U 0 const   options(*nopass)
      *
      *  Right aligns a string.
     D f_alignR...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_alignR+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_length                     10U 0 const   options(*nopass)
      *
      *  Compare strings using wildcard characters. (Compare generic)
     D f_genStrCmp...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_genStrCmp+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_mask                     4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      *
      *  Compare strings using wildcard characters.
     D f_genStrCmpIgnCase...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_genStrCmpIgnCase+
     D                                     ')
     D  i_string                   4096A   const   varying
     D  i_mask                     4096A   const   varying
     D  i_wildcard                    2A   const   options(*nopass)
      *
      *  Returns the last position of a search argument in the source string.
     D f_scanR...
     D                 PR             5I 0
     D                                     extproc('BASICS1R3+
     D                                     _f_scanR+
     D                                     ')
     D  i_searchArg                4096A   const   varying
     D  i_string                   4096A   const   varying
     D  i_start                       5I 0 const   options(*nopass)
      *
      *  Converts a given buffer to a character string of hex values.
     D f_cvtBufferToHexString...
     D                 PR          4096A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_cvtBufferToHexString+
     D                                     ')
     D  i_pBuffer                      *   const
     D  i_size                        5U 0 const
      *
      *  Converts a given pointer to a character string of hex values.
     D f_cvtPtrToHexString...
     D                 PR            32A           varying
     D                                     extproc('BASICS1R3+
     D                                     _f_cvtPtrToHexString+
     D                                     ')
     D  i_pointer                      *   value
      *
      *  Converts a given character string of hex values to a buffer.
     D f_cvtHexStringToBuffer...
     D                 PR             5U 0 opdesc
     D                                     extproc('BASICS1R3+
     D                                     _f_cvtHexStringToBuffer+
     D                                     ')
     D  i_string                   4096A   const   options(*varsize)
     D  i_pBuffer                      *   const
     D  i_size                        5U 0 const
      *
      *  Tests, if a given string contains an invalid character
      *  at a given position.
     D f_containsInvalidCharAt...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_containsInvalidCharAt+
     D                                     ')
     D  i_string                   4096A   const  varying options(*varsize)
     D  i_pos                        10I 0 const
     D  i_chars                     256A   const  varying options(*varsize)
      *
      *  Tests, if a given string contains a specific string
      *  at a given position.
     D f_containsStringAt...
     D                 PR              N
     D                                     extproc('BASICS1R3+
     D                                     _f_containsStringAt+
     D                                     ')
     D  i_string                   4096A   const  varying options(*varsize)
     D  i_pos                        10I 0 const
     D  i_subString                4096A   const  varying options(*varsize)
      *
      *  Returns the string representation of a qualified object name.
     D f_objName...
     D                 PR            21A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_objName+
     D                                     ')
     D  i_qObj                             const  likeds(qObj_t   )
     D  i_lib                        10A   const  options(*nopass)
      *
      *  Replaces unprintable characters in a given string.
     D f_rplUnPrtChars...
     D                 PR          4096A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_rplUnPrtChars+
     D                                     ')
     D  i_string                   4096A   const  varying
     D  i_rplChar                     1A   const  varying options(*nopass)
      *
      *  Formats a given date according to a given puicture string.
     D f_formatDate...
     D                 PR           128A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_formatDate+
     D                                     ')
     D  i_date                         D   const
     D  i_picture                   128A   const  varying
      *
      *  Parses a string representing a date.
     D f_parseDate...
     D                 PR              D
     D                                     extproc('BASICS1R3+
     D                                     _f_parseDate+
     D                                     ')
     D  i_string                    128A   const  varying
     D  i_picture                   128A   const  varying options(*nopass)
      *
      *  Konstants: f_formatMemSize
     D cMEM_SIZE_BYTE...
     D                 C                   'B'
     D cMEM_SIZE_KILO_BYTE...
     D                 C                   'KB'
     D cMEM_SIZE_MEGA_BYTE...
     D                 C                   'MB'
     D cMEM_SIZE_GIGA_BYTE...
     D                 C                   'GB'
     D cMEM_SIZE_TERA_BYTE...
     D                 C                   'TB'
     D cMEM_SIZE_PETA_BYTE...
     D                 C                   'PB'
     D cMEM_SIZE_EXA_BYTE...
     D                 C                   'EB'
     D cMEM_SIZE_ZETTA_BYTE...
     D                 C                   'ZB'
      *
      *  Converts a given memory size in bytes to string.
     D f_formatMemSize...
     D                 PR           128A          varying
     D                                     extproc('BASICS1R3+
     D                                     _f_formatMemSize+
     D                                     ')
     D  i_memSize                    20I 0 const
     D  io_unit                       2A          options(*nopass: *omit)
     D  i_decPos                      3I 0 const  options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      /COPY QBASICS1,PBASICS1R4                   Assert/This/Caller
      /COPY QBASICS1,PBASICS1R7                   Mathematics
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R4  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R4"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Assert/This/Caller  cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R4)
      /DEFINE BASICS1R4
      *
      *  RPG equivalent of the C Assert macro.
     D p_assert...
     D                 PR
     D                                     extproc('BASICS1R4+
     D                                     _p_assert+
     D                                     ')
     D  i_condition                    N   const
     D  i_msgText                   128A   const  options(*nopass)
      *
      *  Returns the procedure, module and program name
      *  of the current procedure.
     D f_this...
     D                 PR           256A          varying
     D                                     extproc('BASICS1R4+
     D                                     _f_this+
     D                                     ')
     D  o_module                     10A          options(*nopass: *omit)
     D  o_program                    10A          options(*nopass: *omit)
     D  o_stmtID                     10A          options(*nopass: *omit)
      *
      *  Returns the procedure, module and program name
      *  that called the current procedure.
     D f_caller...
     D                 PR           256A          varying
     D                                     extproc('BASICS1R4+
     D                                     _f_caller+
     D                                     ')
     D  o_module                     10A          options(*nopass: *omit)
     D  o_program                    10A          options(*nopass: *omit)
     D  o_stmtID                     10A          options(*nopass: *omit)
     D  i_offset                      3I 0 const  options(*nopass: *omit)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      /COPY QBASICS1,PBASICS1R5                   Objects
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R5  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R5"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Objects             cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R5)
      /DEFINE BASICS1R5
      *
      *  Reference fields
      /COPY QBASICS1,FDQFILE
      /COPY QBASICS1,FDQOBJ
      /COPY QBASICS1,FDQQSYSOBJ
      /COPY QBASICS1,FDOBJD0100
      /COPY QBASICS1,FDMBRD0100
      /COPY QBASICS1,FDMBRD0200
      *
     D qProc_t         DS                  qualified      based(pDummy)
     D  name                        256A   varying
     D  module                       10A
     D  qPgm                               likeds(qObj_t)
      *
     D actSrvPgm_t     DS                  qualified      based(pDummy)
     D  procptr                        *   procptr
     D  actMark                      10I 0
     D  name                         10A
     D  lib                          10A
      *
     D actProc_t       DS                  qualified      based(pDummy)
     D  procptr                        *   procptr
     D  actMark                      10I 0
     D  name                        256A   varying
     D  srvPgm                       10A
     D  lib                          10A
      *
      *  Checks object existance.
     D f_exist...
     D                 PR              N
     D                                     extproc('BASICS1R5+
     D                                     _f_exist+
     D                                     ')
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
     D  i_mbr                        10A   const  options(*nopass)
      *
      *  Retrieve object description.
     D f_rtvObjD...
     D                 PR          1024A
     D                                     extproc('BASICS1R5+
     D                                     _f_rtvObjD+
     D                                     ')
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
     D  i_format                      8A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieve member description.
     D f_rtvMbrD...
     D                 PR          1024A
     D                                     extproc('BASICS1R5+
     D                                     _f_rtvMbrD+
     D                                     ')
     D  i_file                       10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_mbr                        10A   const
     D  i_format                      8A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Produces a temporary object name.
     D f_getTmpName...
     D                 PR                         like(qObj_t     )
     D                                     extproc('BASICS1R5+
     D                                     _f_getTmpName+
     D                                     ')
      *
      *  Produces a unique object name.  (experimental)
     D f_getUniqueName...
     D                 PR                         like(qObj_t     )
     D                                     extproc('BASICS1R5+
     D                                     _f_getUniqueName+
     D                                     ')
     D  i_type                       10A   const
     D  i_lib                        10A   const
      *
      *  Creates a user space.
     D f_crtUsrSpc...
     D                 PR              N
     D                                     extproc('BASICS1R5+
     D                                     _f_crtUsrSpc+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const
     D  i_text                       50A   const  options(*omit: *nopass)
     D  i_size                       10U 0 const  options(*omit: *nopass)
     D  i_extAtr                     10A   const  options(*omit: *nopass)
     D  i_pubAuth                    10A   const  options(*omit: *nopass)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Retrieves a pointer to the content of a user space.
     D f_rtvUsrSpcPtr...
     D                 PR              *
     D                                     extproc('BASICS1R5+
     D                                     _f_rtvUsrSpcPtr+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Returns the current size of a given user space.
     D f_getUsrSpcSize...
     D                 PR            10I 0
     D                                     extproc('BASICS1R5+
     D                                     _f_getUsrSpcSize+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Returns cTrue if the user space is extended automatically by the
      *  system when the end of the space is encountered.
     D f_getUsrSpcAutoExt...
     D                 PR              N
     D                                     extproc('BASICS1R5+
     D                                     _f_getUsrSpcAutoExt+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Returns the initial value of a given user space.
     D f_getUsrSpcInitValue...
     D                 PR             1A          varying
     D                                     extproc('BASICS1R5+
     D                                     _f_getUsrSpcInitValue+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Changes the size of a given user space.
     D f_chgUsrSpcSize...
     D                 PR            10I 0
     D                                     extproc('BASICS1R5+
     D                                     _f_chgUsrSpcSize+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_size                       10I 0 const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Changes the automatic extendibility of a given user space.
     D f_chgUsrSpcAutoExt...
     D                 PR              N
     D                                     extproc('BASICS1R5+
     D                                     _f_chgUsrSpcAutoExt+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_isAutoExt                    N   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Changes the initial value of a given user space.
     D f_chgUsrSpcInitValue...
     D                 PR             1A          varying
     D                                     extproc('BASICS1R5+
     D                                     _f_chgUsrSpcInitValue+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_initValue                   1A   const
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Deletes a given user space.
     D f_dltUsrSpc...
     D                 PR              N
     D                                     extproc('BASICS1R5+
     D                                     _f_dltUsrSpc+
     D                                     ')
     D  i_usrSpc                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Activates a service program.
     D f_activateSrvPgm...
     D                 PR                         likeds(actSrvPgm_t )
     D                                     extproc('BASICS1R5+
     D                                     _f_activateSrvPgm+
     D                                     ')
     D  i_srvPgm                     10A   const
     D  i_lib                        10A   const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Gets a procedure pointer by name.
     D f_getProcPtrByName...
     D                 PR                         likeds(actProc_t  )
     D                                     extproc('BASICS1R5+
     D                                     _f_getProcPtrByName+
     D                                     ')
     D  i_proc                      256A   const
     D  i_actSrvPgm                        const  likeds(actSrvPgm_t)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Returns the name of the library that contains a given object.
     D f_getObjLib...
     D                 PR            10A
     D                                     extproc('BASICS1R5+
     D                                     _f_getObjLib+
     D                                     ')
     D  i_obj                        10A   const
     D  i_lib                        10A   const  options(*omit)
     D  i_type                       10A   const
      *
      *  Converts a QSYS object name to a path.
     D f_cvtQSYSObjNameToPath...
     D                 PR          5000A   varying opdesc
     D                                     extproc('BASICS1R5+
     D                                     _f_cvtQSYSObjNameToPath+
     D                                     ')
     D  i_obj                        40A   const  options(*varsize)
     D  i_libOrType                  10A   const  options(*nopass: *omit)
     D  i_mbrOrType                  10A   const  options(*nopass: *omit)
     D  i_objType                    10A   const  options(*nopass: *omit)
      *
      *  Resolve Integrated File System Path Name into
      *  QSYS Object Name
     D f_cvtPathToQSYSObjName...
     D                 PR                  likeds(qQSYSObj_t)
     D                                     extproc('BASICS1R5+
     D                                     _f_cvtPathToQSYSObjName+
     D                                     ')
     D  i_path                     5000A   const  varying options(*varsize)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,MILIB                        MI-Library
      /COPY QBASICS1,PBASICS1R1                   Messages
      /COPY QBASICS1,PBASICS1R7                   Mathematics
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R6  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R6"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Commands/Environmentcpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R6)
      /DEFINE BASICS1R6
      *
      *  Reference fields
      /COPY QBASICS1,FDENVVAR
      *
      *  Constants
      *  f_execute:            Refer to description of QCAPCMD API for details
     D cCMD_PRC_EXC_QCMDEXC...
     D                 C                   const(0)
     D cCMD_PRC_CHK_QCMDCHK...
     D                 C                   const(1)
     D cCMD_PRC_EXC_CMDLINE...
     D                 C                   const(2)
     D cCMD_PRC_CHK_CMDLINE...
     D                 C                   const(3)
     D cCMD_PRC_CHK_CL_STMT...
     D                 C                   const(4)
     D cCMD_PRC_CHK_SEU_CL...
     D                 C                   const(5)
     D cCMD_PRC_CHK_SEU_CMD...
     D                 C                   const(6)
     D cCMD_PRC_CHK_SEU_BND...
     D                 C                   const(7)
     D cCMD_PRC_CHK_UDO...
     D                 C                   const(8)
     D cCMD_PRC_CHK_SEU_CLLE...
     D                 C                   const(9)
      *
     D cCMD_PRC_PROMPT_NEVER...
     D                 C                   const(0)
     D cCMD_PRC_PROMPT_ALWAYS...
     D                 C                   const(x'00010000')                    65536
     D cCMD_PRC_PROMPT_ON_REQUEST...
     D                 C                   const(x'00020000')                   131072
     D cCMD_PRC_PROMPT_HELP...
     D                 C                   const(x'00040000')                   262144
      *
      *  Executes a CL command.
     D f_execute...
     D                 PR              N   opdesc
     D                                     extproc('BASICS1R6+
     D                                     _f_execute+
     D                                     ')
     D  i_cmd                     16384A   const  options(*varsize)
     D  i_typeCmdPrc                 10I 0 const  options(*nopass: *omit)
     D  o_msg                                     likeds(msg_t    )
     D                                            options(*nopass: *omit)
      *
      *  Gets an environment variable.
     D f_getEnvVar...
     D                 PR          1024A          varying
     D                                     extproc('BASICS1R6+
     D                                     _f_getEnvVar+
     D                                     ')
     D  i_pEnvVar                      *   const  options(*string)
      *
      *  Sets an environment variable.
     D f_setEnvVar...
     D                 PR              N
     D                                     extproc('BASICS1R6+
     D                                     _f_setEnvVar+
     D                                     ')
     D  i_envVar                           const  like(envVar_t.name )
     D  i_value                            const  like(envVar_t.value)
      *
      *  Deletes an environment variable.
     D f_delEnvVar...
     D                 PR              N
     D                                     extproc('BASICS1R6+
     D                                     _f_delEnvVar+
     D                                     ')
     D  i_pEnvVar                      *   const  options(*string)
      *
      *  Gets the number of environment variables.
     D f_getNumEnvVar...
     D                 PR            10I 0
     D                                     extproc('BASICS1R6+
     D                                     _f_getNumEnvVar+
     D                                     ')
      *
      *  Gets an environment variable by its index.
     D f_getEnvVarByIndex...
     D                 PR                         likeds(envVar_t )
     D                                     extproc('BASICS1R6+
     D                                     _f_getEnvVarByIndex+
     D                                     ')
     D  i_index                      10I 0 const
      *
      *  Waits for the specified number of seconds.
     D p_wait...
     D                 PR
     D                                     extproc('BASICS1R6+
     D                                     _p_wait+
     D                                     ')
     D  i_seconds                    10I 0 const
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R1                   Messages
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R7  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R7"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Mathematics         cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R7)
      /DEFINE BASICS1R7
      *
      *  Constants
      *
      *  Generate UUID:
     D cUUID_HEX...
     D                 C                   const(1)
     D cUUID_STRING...
     D                 C                   const(2)
      *
     D uuid_t          DS                  qualified
     D  length                        5U 0
     D  value                        32A
      *
      *  Generate MD5:
     D cMD5_HEX...
     D                 C                   const(4352)                           256 + 4096
     D cMD5_STRING...
     D                 C                   const(4608)                           512 + 4096
     D cMD5_ONLY...
     D                 C                   const(17)                               1 +   16
     D cMD5_FIRST...
     D                 C                   const(18)                               2 +   16
     D cMD5_MIDDLE...
     D                 C                   const(20)                               4 +   16
     D cMD5_FINAL...
     D                 C                   const(24)                               8 +   16
      *
     D md5_t           DS                  qualified
     D  length                        5U 0
     D  value                        32A
      *
      *  Generate SHA-1:
     D cSHA1_HEX...
     D                 C                   const(8448)                           256 + 8192
     D cSHA1_STRING...
     D                 C                   const(8704)                           512 + 8192
     D cSHA1_ONLY...
     D                 C                   const(33)                               1 +   32
     D cSHA1_FIRST...
     D                 C                   const(34)                               2 +   32
     D cSHA1_MIDDLE...
     D                 C                   const(36)                               4 +   32
     D cSHA1_FINAL...
     D                 C                   const(40)                               8 +   32
      *
     D sha1_t          DS                  qualified
     D  length                        5U 0
     D  value                        40A
      *
      *  Generate CRC32:
     D cCRC32_ONLY...
     D                 C                   const(33)                               1 +   64
     D cCRC32_FIRST...
     D                 C                   const(34)                               2 +   64
     D cCRC32_MIDDLE...
     D                 C                   const(36)                               4 +   64
     D cCRC32_FINAL...
     D                 C                   const(40)                               8 +   64
      *
     D crc32_t         DS                  qualified
     D  length                        5U 0
     D  value                        40A
      *
      *  Tests for one or more bits.
     D f_isBitOn...
     D                 PR              N
     D                                     extproc('BASICS1R7+
     D                                     _f_isBitOn+
     D                                     ')
     D  i_testBit                    10U 0 value
     D  i_value                      10U 0 value
      *
      *  Computes the logarithm base 10 of a given value.
     D f_log10...
     D                 PR             8F
     D                                     extproc('BASICS1R7+
     D                                     _f_log10+
     D                                     ')
     D  i_value                       8F   value
      *
      *  Computes the length of a RPG integer field from its buffer length
     D f_clcLengthOfRPGIntFieldFromBufSize...
     D                 PR             5U 0
     D                                     extproc('BASICS1R7+
     D                                     _f_clcLengthOfRPGIntFieldFromBufSize+
     D                                     ')
     D  i_buffSize                    5U 0 value
      *
      *  Generates a Universal Unique Identifier (UUID).
     D f_genUUID...
     D                 PR                         likeds(uuid_t  )
     D                                     extproc('BASICS1R7+
     D                                     _f_genUUID+
     D                                     ')
     D  i_option                      5U 0 value  options(*nopass)
      *
      *  Generates a MD5 fingerprint (hash code).
     D f_genMD5...
     D                 PR                         likeds(md5_t   )
     D                                     extproc('BASICS1R7+
     D                                     _f_genMD5+
     D                                     ')
     D  i_pString                      *   const  options(*string)
     D  i_option                      5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      *  Generates a SHA-1 fingerprint (hash code).
     D f_genSHA1...
     D                 PR                         likeds(sha1_t  )
     D                                     extproc('BASICS1R7+
     D                                     _f_genSHA1+
     D                                     ')
     D  i_pString                      *   const  options(*string)
     D  i_option                      5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      *  Generates a CRC32 checksum.
     D f_genCRC32...
     D                 PR                         likeds(crc32_t )
     D                                     extproc('BASICS1R7+
     D                                     _f_genCRC32+
     D                                     ')
     D  i_pString                      *   const  options(*string)
     D  i_option                      5U 0 const  options(*nopass)
     D  i_length                     10U 0 const  options(*nopass)
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R3                   Strings
      /COPY QBASICS1,PBASICS1R4                   Assert/This/Caller
      *
      /if defined(C_COMPILER)
      /COPY QBASICS1,PBASICS1C7                   C-Helpers
      /endif
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R8  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R8"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Handle/Memory       cpybk"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R8)
      /DEFINE BASICS1R8
      *
     D HANDLE_handle_t...
     D                 S             10I 0                         based(pDummy)
     D HANDLE_type_t...
     D                 S             20A                           based(pDummy)
      *
      *  Creates a new handle.
     D HANDLE_new...
     D                 PR                         like(HANDLE_handle_t)
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_new+
     D                                     ')
     D  i_type                             value  like(HANDLE_type_t  )
     D  i_size                       10U 0 value
      *
      *  Creates a NULL handle.
     D HANDLE_null...
     D                 PR                         like(HANDLE_handle_t)
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_null+
     D                                     ')
      *
      *  Checks a handle for a NULL value.
     D HANDLE_isNull...
     D                 PR              N
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_isNull+
     D                                     ')
     D  i_handle                           value  like(HANDLE_handle_t)
      *
      *  Checks the type of a given handle.
     D HANDLE_isTypeOf...
     D                 PR              N
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_isTypeOf+
     D                                     ')
     D  i_handle                           value  like(HANDLE_handle_t)
     D  i_type                             value  like(HANDLE_type_t  )
      *
      *  Gets the pointer of a given handle.
     D HANDLE_getPointer...
     D                 PR              *
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_getPointer+
     D                                     ')
     D  i_handle                           value  like(HANDLE_handle_t)
      *
      *  Deletes a given handle.
     D HANDLE_delete...
     D                 PR
     D                                     extproc('BASICS1R8+
     D                                     _HANDLE_delete+
     D                                     ')
     D  io_handle                                 like(HANDLE_handle_t)
      *
      *  Allocates a memory cell and keeps track of it.
     D MEMORY_allocate...
     D                 PR              *
     D                                     extproc('BASICS1R8+
     D                                     _MEMORY_allocate+
     D                                     ')
     D  io_aMemList                    *
     D  i_size                       10I 0 value
      *
      *  Frees all allocated memory cells.
     D MEMORY_freeAll...
     D                 PR
     D                                     extproc('BASICS1R8+
     D                                     _MEMORY_freeAll+
     D                                     ')
     D  io_aMemList                    *
      *
      *  Frees all given memory cell.
     D MEMORY_free...
     D                 PR
     D                                     extproc('BASICS1R8+
     D                                     _MEMORY_free+
     D                                     ')
     D  io_aMemList                    *
     D  io_pMem                        *
      *
     D MemoryManager_manager_t...
     D                 DS                         qualified   based(pDummy)
     D  pAllocate                      *          procptr
     D  pReallocate                    *          procptr
     D  pFree                          *          procptr
      *
      *  Memory Manager -- Returns the default memory manager
     D MemoryManager_getDefaultManager...
     D                 PR                  likeds(MemoryManager_manager_t)
     D                                     extproc('BASICS1R8+
     D                                     _MemoryManager_getDefaultManager+
     D                                     ')
      *
      *  Memory Manager -- Reserve Storage Block
     D MemoryManager_allocate...
     D                 PR              *   extproc('BASICS1R8+
     D                                     _MemoryManager_allocate+
     D                                     ')
     D  i_size                       10U 0 value
     D  i_heap                       10I 0 value  options(*nopass)
      *
      *  Memory Manager -- Change Reserved Storage Block Size
     D MemoryManager_reallocate...
     D                 PR              *   extproc('BASICS1R8+
     D                                     _MemoryManager_reallocate+
     D                                     ')
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  Memory Manager -- Release Storage Blocks
     D MemoryManager_free...
     D                 PR                  extproc('BASICS1R8+
     D                                     _MemoryManager_free+
     D                                     ')
     D  io_pMem                        *
      *
      *  Memory Manager -- Creates a new heap.
     D MemoryManager_createHeap...
     D                 PR            10I 0
     D                                     extproc('BASICS1R8+
     D                                     _MemoryManager_createHeap+
     D                                     ')
     D  i_initialSize                10I 0 const  options(*nopass: *omit)
     D  i_increment                  10I 0 const  options(*nopass: *omit)
     D  i_allocStrat                 10I 0 const  options(*nopass: *omit)
      *
      *  Memory Manager -- Deletes an existing heap.
     D MemoryManager_deleteHeap...
     D                 PR
     D                                     extproc('BASICS1R8+
     D                                     _MemoryManager_deleteHeap+
     D                                     ')
     D  io_heapID                    10I 0
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R4                   Assert/This
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PBASICS1R9  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PBASICS1R9"
mbrtype =  "RPGLE     "
mbrtext =  "SrvPgm: Basic Routines - Display Information      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(BASICS1R9)
      /DEFINE BASICS1R9
      *
      *  Reference Fields
     D display_mode_t  S              4A   based(pDummy)
      *
      *  Constants
     D cDISPLAY_MODE_DS3...
     D                 C                   const('*DS3')
     D cDISPLAY_MODE_DS4...
     D                 C                   const('*DS4')
      *
      *  Returns the current display mode.
     D Display_getMode...
     D                 PR                         like(display_mode_t)
     D                                     extproc('BASICS1R9+
     D                                     _Display_getMode+
     D                                     ')
      *
      *  Returns cTrue if the display device support 27x132 mode.
     D Display_supportsDS4...
     D                 PR              N
     D                                     extproc('BASICS1R9+
     D                                     _Display_supportsDS4+
     D                                     ')
      *
      *  Returns cTrue if the display device supports GUI characters.
     D Display_supportsGUI...
     D                 PR              N
     D                                     extproc('BASICS1R9+
     D                                     _Display_supportsGUI+
     D                                     ')
      *
      *  Returns the number of rows that can be displayed on the screen.
     D Display_getRows...
     D                 PR             5I 0
     D                                     extproc('BASICS1R9+
     D                                     _Display_getRows+
     D                                     ')
     D  i_dspMode                          const  like(display_mode_t)
     D                                            options(*nopass)
      *
      *  Returns the number of columns that can be displayed on the screen.
     D Display_getColumns...
     D                 PR             5I 0
     D                                     extproc('BASICS1R9+
     D                                     _Display_getColumns+
     D                                     ')
     D  i_dspMode                          const  like(display_mode_t)
     D                                            options(*nopass)
      *
      * -----------------------------------------
      *  Deprecated procedure names
      * -----------------------------------------
      *
      *  Ermittelt den aktuellen Bildschirmmodus: *DS3 oder *DS4
     D f_getDisplayMode...
     D                 PR                         like(display_mode_t)
     D                                     extproc('BASICS1R9+
     D                                     _Display_getMode+
     D                                     ')
      *
      * -----------------------------------------
      *  Imported prototypes
      * -----------------------------------------
      /COPY QBASICS1,PBASICS1R2                   API Error Handling
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QP0LCVTPAT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QP0LCVTPAT"
mbrtype =  "RPGLE     "
mbrtext =  "Qp0lCvtPathToQSYSObjName()--Resolve Path          "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(Qp0lCvtPathToQSYSObjName)
 DEF  /DEFINE Qp0lCvtPathToQSYSObjName
      *
      *  Qp0lCvtPathToQSYSObjName()--Resolve Integrated File System Path Name
      *                              into QSYS Object Name
     D Qp0lCvtPathToQSYSObjName...
     D                 PR            10I 0 extproc('Qp0lCvtPathToQSYSObjName')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
     D  o_qsys_info               65535A          options(*varsize)
     D  i_format                      8A   const
     D  i_bytPrv                     10I 0 value
     D  i_ccsid                      10I 0 value
     D  io_errCode                65535A          options(*varsize)
      *
     D qsys0100_t      DS                  qualified based(pDummy)
     D  bytRet                 1      4i 0
     D  bytAvl                 5      8i 0
     D  ccsid                  9     12i 0
     D  lib_name              13     40a
     D  lib_type              41     60a
     D  obj_name              61     88a
     D  obj_type              89    108a
     D  mbr_name             109    136a
     D  mbr_type             137    156a
     D  asp_name             157    184a
      *
      /if not defined(Qlg_Path_Name)
      /define Qlg_Path_Name
     D Qlg_Path_Name_t...
     D                 DS                  qualified align         based(pDummy)
     D   CCSID                       10I 0
     D   Country_ID                   2A
     D   Language_ID                  3A
     D   Reserved                     3A
     D   Path_Type                   10U 0
     D   Path_Length                 10I 0
     D   Path_Name_Delimiter...
     D                                2A
     D   Reserved2                   10A
     D   Path_Name                  256A
      *
     D QLG_PATH_JOB_CCSID...
     D                 C                   0
     D QLG_PATH_JOB_COUNTRYID...
     D                 C                   x'0000'
     D QLG_PATH_JOB_LANGUAGEID...
     D                 C                   x'000000'
      *
      *  The Path_Name is a character string and the delimiter is one byte long.
     D QLG_CHAR_SINGLE...
     D                 C                   0
      *
      *  The Path_Name is a pointer and the delimiter is one byte long.
     D QLG_PTR_SINGLE...
     D                 C                   1
      *
      *  The Path_Name is a character string and the delimiter is two bytes long.
     D QLG_CHAR_DOUBLE...
     D                 C                   2
      *
      *  The Path_Name is a pointer and the delimiter is two bytes long.
     D QLG_PTR_DOUBLE...
     D                 C                   3
      *
      /endif
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QUSRSPC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QUSRSPC   "
mbrtype =  "RPGLE     "
mbrtext =  "User Space APIs                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(QUSRSPC)
      /DEFINE QUSRSPC
      *
      *  Create User Space (QUSCRTUS) API
     D QUSCRTUS...
     D                 PR                  extpgm('QUSCRTUS')
     D  i_qUsrSpc                    20A   const
     D  i_extAttr                    10A   const
     D  i_initSize                   10I 0 const
     D  i_initValue                   1A   const
     D  i_pubAuth                    10A   const
     D  i_text                       50A   const
     D  i_replace                    10A   const options(*nopass)               | optGrp 1
     D  io_ErrCode                65535A         options(*nopass: *varsize)     |
     D  i_domain                     10A   const options(*nopass)               | optGrp 2
     D  i_tfrSizeReq                 10I 0 const options(*nopass)               | optGrp 3
     D  i_optSpcAlgn                  1A   const options(*nopass)               | optGrp 3
      *
      *  Change User Space (QUSCHGUS) API
     D QUSCHGUS...
     D                 PR                  extpgm('QUSCHGUS')
     D  i_qUsrSpc                    20A   const
     D  i_start                      10I 0 const
     D  i_length                     10I 0 const
     D  i_data                    65535A   const options(*varsize)
     D  i_force                       1A   const
     D  io_ErrCode                65535A         options(*nopass: *varsize)     | optGrp 1
      *
      *  Retrieve User Space (QUSRTVUS) API
     D QUSRTVUS...
     D                 PR                  extpgm('QUSRTVUS')
     D  i_qUsrSpc                    20A   const
     D  i_start                      10I 0 const
     D  i_length                     10I 0 const
     D  o_rcvVar                  65535A   const options(*varsize)
     D  io_ErrCode                65535A         options(*nopass: *varsize)     | optGrp 1
      *
      *  Retrieve Pointer to User Space (QUSPTRUS) API
     D QUSPTRUS...
     D                 PR                  extpgm('QUSPTRUS')
     D  i_qUsrSpc                    20A   const
     D  o_pUsrSpc                      *
     D  io_ErrCode                65535A         options(*nopass: *varsize)     | optGrp 1
      *
      *  Change User Space Attributes (QUSCUSAT) API
     D QUSCUSAT...
     D                 PR                  extpgm('QUSCUSAT')
     D  o_rtnLib                     10A
     D  i_qUsrSpc                    20A   const
     D  i_attrs                   65535A   const options(*varsize)
     D  io_ErrCode                65535A         options(*varsize)
      *
     D QUSRSPC_ATTR_SIZE...
     D                 C                   1                                    BINARY(4)
     D QUSRSPC_ATTR_INITIAL_VALUE...
     D                 C                   2                                    CHAR(1)
     D QUSRSPC_ATTR_AUTO_EXTEND...
     D                 C                   3                                    CHAR(1)
     D QUSRSPC_ATTR_TRANSFER_SIZE_REQ...
     D                 C                   4                                    BINARY(4)
      *
     D QUSRSPC_attr_size_t...
     D                 DS                  qualified               based(pDummy)
     D  key                          10I 0
     D  dataLen                      10I 0
     D  size                         10I 0
      *
     D QUSRSPC_initial_value_t...
     D                 DS                  qualified               based(pDummy)
     D  key                          10I 0
     D  dataLen                      10I 0
     D  value                         1A
      *
     D QUSRSPC_auto_extend_t...
     D                 DS                  qualified               based(pDummy)
     D  key                          10I 0
     D  dataLen                      10I 0
     D  autoExtend                    1A
      *
     D QUSRSPC_ztansfer_size_req_t...
     D                 DS                  qualified               based(pDummy)
     D  key                          10I 0
     D  dataLen                      10I 0
     D  tfrSizeReq                   10I 0
      *
      *  Retrieve User Space Attributes (QUSRUSAT) API
     D QUSRUSAT...
     D                 PR                  extpgm('QUSRUSAT')
     D  o_rcvVar                  65535A         options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qUsrSpc                    20A   const
     D  io_ErrCode                65535A         options(*varsize)
      *
      *  SPCA0100 Format
     D SPCA0100_t      DS                  qualified               based(pDummy)
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  size                   9     12I 0
     D  autoExtend            13     13A
     D  initValue             14     14A
     D  usrSpcLib             15     24A
      *
      *  Delete User Space (QUSDLTUS) API
     D QUSDLTUS...
     D                 PR                  extpgm('QUSDLTUS')
     D  i_qUsrSpc                    20A   const
     D  io_ErrCode                65535A         options(*varsize)
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QWCCVTDT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QWCCVTDT  "
mbrtype =  "RPGLE     "
mbrtext =  "Convert Date and Time Format (QWCCVTDT) API       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(QWCCVTDT)
      /DEFINE QWCCVTDT
      *
      *  Convert Date and Time Format (QWCCVTDT) API
     D QWCCVTDT...
     D                 PR                         extpgm('QWCCVTDT')
     D  i_iFormat                    10A   const
     D  i_iValue                  65535A   const options(*varsize)
     D  i_oFormat                    10A   const
     D  o_oValue                  65535A          options(*varsize)
     D  io_errCode                65535A          options(*varsize)
     D  i_iTimezone                  10A   const  options(*nopass)              | optGrp 1
     D  i_oTimezone                  10A   const  options(*nopass)              |
     D  o_timezone                65535A          options(*nopass: *varsize)    |
     D  i_lenTimezone                10I 0 const  options(*nopass)              |
     D  i_precInd                     1A   const  options(*nopass)              |
     D  i_iTimeInd                    1A   const  options(*nopass)              | optGrp 2
      *
      *  Time Zone Information Value Structure
     D QWCCVTDT_timezone_t...
     D                 DS                  qualified               based(pDummy)
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  desc                   9     18A
     D  reserved_1            19     19A
     D  dayLightInd           20     20A
     D  curOffset             21     24I 0
     D  curFullName           25     74A
     D  curAbbrevName         75     84A
     D  curMsgInd             85     91A
     D  msgFile               92    101A
     D  msgFileLib           102    111A
      *
      *  This table shows the structure used for the input and output variables when
      *  the format is *JOB, *SYSVAL, *YMD, *MDY, *DMY, and *JUL and the precision
      *  indicator specifies milliseconds.
     D QWCCVTDT_dateTime_16_t...
     D                 DS                  qualified               based(pDummy)
     D  century                1      1A
     D  date                   2      7A
     D  time                   8     13A
     D  mSecs                 14     16A
      *
      *  This table shows the structure used for the input and output variables when
      *  the format is *YYMD, *MDYY, *DMYY, and *LONGJUL and the precision indicator
      *  specifies milliseconds.
     D QWCCVTDT_dateTime_17_t...
     D                 DS                  qualified               based(pDummy)
     D  date                   1      8A
     D  time                   9     14A
     D  mSecs                 15     17A
      *
      *  This table shows the structure used for the input and output variables when
      *  the format is *JOB, *SYSVAL, *YMD, *MDY, *DMY, and *JUL and the precision
      *  indicator specifies microseconds.
     D QWCCVTDT_dateTime_19_t...
     D                 DS                  qualified               based(pDummy)
     D  century                1      1A
     D  date                   2      7A
     D  time                   8     13A
     D  mSecs                 14     19A
      *
      *  This table shows the structure used for the input and output variables when
      *  the format is *YYMD, *MDYY, *DMYY, and *LONGJUL and the precision indicator
      *  specifies microseconds.
     D QWCCVTDT_dateTime_20_t...
     D                 DS                  qualified               based(pDummy)
     D  date                   1      8A
     D  time                   9     14A
     D  mSecs                 15     20A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QWCRSVAL  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QWCRSVAL  "
mbrtype =  "RPGLE     "
mbrtext =  "Retrieve System Values (QWCRSVAL) API             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(QWCRSVAL)
      /DEFINE QWCRSVAL
      *
      *  Retrieve System Values (QWCRSVAL) API
     D QWCRSVAL...
     D                 PR                         extpgm('QWCRSVAL')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_numSysVal                  10I 0 const
     D  i_arySysVal                  10A   const  options(*varsize) dim(128)
     D  io_errCode                65535A          options(*varsize)
      *
      *  Return value
     D QWCRSVAL_rtnValue_t...
     D                 DS          4096    qualified               based(pDummy)
     D  numSysValRtn                 10I 0
     D  ofsSysValTbl                 10I 0 dim(128)
      *
     D QWCRSVAL_sysValInfTbl_t...
     D                 DS                  qualified   based(pSysValTbl)
     D  sysVal                       10A
     D  type                          1A
     D  infStatus                     1A
     D  length                       10I 0
     D  data                       4096A
      *
      * --------------------------------------------------
      *  Pre-defined structures for complex system values
      * --------------------------------------------------
      *
      *  QACGLVL:         Accounting level
     D QWCRSVAL_acgLvl_t...
     D                 DS                  qualified
     D  option                       10A   dim(8)
      *
      *  QALWOBJRST:      Allow object restore options
     D QWCRSVAL_alwObjRst_t...
     D                 DS                  qualified
     D  option                       10A   dim(15)
      *
      *  QALWUSRDMN:      Allow user domain
     D QWCRSVAL_alwUsrDmn_t...
     D                 DS                  qualified
     D  lib                          10A   dim(50)
      *
      *  QATNPGM:        Attention program
     D QWCRSVAL_atnPgm_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QAUDCTL:         Auditing control
     D QWCRSVAL_audCtl_t...
     D                 DS                  qualified
     D  option                       10A   dim(5)
      *
      *  QAUDLVL:         Auditing level
     D QWCRSVAL_audLvl_t...
     D                 DS                  qualified
     D  option                       10A   dim(16)
      *
      *  QAUDLVL2:        Auditing level extension
     D QWCRSVAL_audLvl2_t...
     D                 DS                  qualified
     D  option                       10A   dim(99)
      *
      *  QBOOKPATH:      Book and bookshelf search path
     D QWCRSVAL_bookPath_t...
     D                 DS                  qualified
     D  path                         63A   dim(5)
      *
      *  QCFGMSGQ:       Configuration message queue
     D QWCRSVAL_cfgMsgQ_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QCHRID:         Character set and code page
     D QWCRSVAL_chrID_t...
     D                 DS                  qualified
     D  ccsid                        10A
     D  codePage                     10A
      *
      *  QCMNRCYLMT:     Communications recovery limit
     D QWCRSVAL_cmnRcyLmt_t...
     D                 DS                  qualified
     D  count                        10A
     D  interval                     10A
      *
      *  QCTLSBSD:       Controlling subsystem
     D QWCRSVAL_ctlSbsD_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QDATETIME:      System date and time       (YYYYMMDDHHNNSSXXXXXX)
     D QWCRSVAL_dateTime_t...
     D                 DS                  qualified
     D  date                          8A
     D  time                          6A
     D  mSecs                         6A
      *
      *  QIGCCDEFNT:     Double-byte coded font name
     D QWCRSVAL_igcCdeFnt_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QINACTMSGQ:   Inactive message queue
     D QWCRSVAL_inActMsgQ_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QIPLDATTIM:   Automatic IPL date and time  (value = CYYMMDDHHMMSS)
     D QWCRSVAL_iplDatTim_t...
     D                 DS                  qualified
     D  spcVal                 1     10A
     D  value                  1     13A
      *
      *  QPRBFTR:      Problem filter
     D QWCRSVAL_prbFtr_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QPWDVLDPGM:   Password validation program
     D QWCRSVAL_pwdVldPgm_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QRMTSIGN:     Remote sign-on
     D QWCRSVAL_rmtSign_t...
     D                 DS                  qualified
     D  spcVal                       10A
     D  pgm                          10A   overlay(spcVal)
     D  lib                          10A
      *
      *  QSCANFS:      Scan file systems
     D QWCRSVAL_scanFS_t...
     D                 DS                  qualified
     D  option                       10A   dim(20)
      *
      *  QSCANFSCTL:   Scan file systems control
     D QWCRSVAL_scanFSCtl_t...
     D                 DS                  qualified
     D  option                       10A   dim(20)
      *
      *  QSETJOBATR:   Set job attributes from locale
     D QWCRSVAL_setJobAtr_t...
     D                 DS                  qualified
     D  attr                         10A   dim(16)
      *
      *  QSRTSEQ:      Sort sequence table
     D QWCRSVAL_srtSeq_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QSTRUPPGM:    Startup program name
     D QWCRSVAL_strUpPgm_t...
     D                 DS                  qualified
     D  name                         10A
     D  lib                          10A
      *
      *  QSYSLIBL:     System library list
     D QWCRSVAL_sysLibl_t...
     D                 DS                  qualified
     D  lib                          10A   dim(15)
      *
      *  QUSRLIBL:     User library list
     D QWCRSVAL_usrLibl_t...
     D                 DS                  qualified
     D  lib                          10A   dim(25)
      *
      *  QUTCOFFSET:   Coordinated universal time offset
     D QWCRSVAL_utcOffset_t...
     D                 DS                  qualified
     D  timeZoneID                    1A
     D  hours                         2A
     D  minutes                       2A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_F000  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_F000 "
mbrtype =  "RPGLE     "
mbrtext =  "Test: Template fr Testprogramme                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 RAD  *===============================================================*
 RAD  *   >>PRE-COMPILER<<                                            *
      *                                                               *
 RAD  *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
 RAD  *                              SRCFILE(&SL/&SF) +               *
 RAD  *                              SRCMBR(&SM);                     *
 RAD  *                                                               *
 RAD  *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
 RAD  *     >>END-COMPILE<<                                           *
 RAD  *                                                               *
 RAD  *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
 RAD  *                                                               *
 RAD  *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_F000')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RA_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RA_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicList_*                                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RA_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cTYPE_TEST...
     D                 C                   const('*TEST')
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RA_01')
      *
     D main...
     D                 PR
      *
     D sort...
     D                 PR            10I 0
     D                                     extproc('sort')
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                            inz
     D hList           S                   like(BasicList_handle_t )  inz
     D isValid         S               N                              inz
     D isSorted        S               N                              inz
     D listType        S                   like(BasicList_type_t  )   inz
     D entryType       S                   like(BasicList_type_t  )   inz
     D aString         S           4096A   varying                    inz
     D aField          S             20A                        based(paField)
     D numE            S             10I 0                            inz
     D aSize           S             10I 0                            inz
     D anArray         DS                  dim(10)   qualified
     D  size                               like(aSize        )        inz
     D  trimSize                           like(aSize        )        inz
     D  data                               like(aField       )        inz
     D bufferCheck     S            128A
      *
     D aSortedArray    S             20A   dim(10) inz
      *
     D msg             DS                  likeds(msg_t      )        inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize Array
         anArray( 1).data = 'Donald Duck';
         anArray( 2).data = 'Dagobert Duck';
         anArray( 3).data = 'Tick';
         anArray( 4).data = 'Trick';
         anArray( 5).data = 'Track';
         anArray( 6).data = 'Daisy';
         anArray( 7).data = 'Klaas Klever';
         anArray( 8).data = 'Daniel Dsentrieb';
         anArray( 9).data = 'Micky Maus';
         anArray(10).data = 'Goofy';

         // Initialize the sort Array
         for x = 1 to %elem(anArray);
            aSortedArray(x) = anArray(x).data;
         endfor;
         sorta aSortedArray;

         // Set size of trimmed field data
         for x = 1 to %elem(anArray);
            anArray(x).size     = %len(anArray(x).data);
            anArray(x).trimSize = %len(%trimR(anArray(x).data));
            p_assert(anArray(x).size <> anArray(x).trimSize
                     : 'Size and trimmed size must be different');
         endfor;

         // Create BasicList
         hList = BasicList_new(cTYPE_TEST);

         // Add elements to list
         for x = 1 to %elem(anArray);
            BasicList_add(hList: anArray(x).data);
         endfor;

         // Verify elements in list
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            aSize   = BasicList_getSize(hList: x);
            p_assert(aSize = %len(anArray(1).data)
                     : 'Field size does not match expected size of 20');
            p_assert(%subst(aField: 1: aSize) = anArray(x).data
                     : 'Field contents do not match');
         endfor;

         // Trim elements in list
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            BasicList_set(hList: x: %addr(anArray(x).data):anArray(x).trimSize);
         endfor;

         // Verify elements in list
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            aSize   = BasicList_getSize(hList: x);
            p_assert(aSize = anArray(x).trimSize
                     : 'Field size does not match expected size');
            p_assert(%subst(aField: 1: aSize) = anArray(x).data
                     : 'Field contents do not match');
         endfor;

         // Sort list
         isSorted = BasicList_sort(hList: %paddr('sort'));
         isSorted = BasicList_sort(hList: %paddr('sort'));
         p_assert(isSorted = cTrue:
                  'Variable isSorted does not match expected value: cTrue');

         // Verify element order
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            p_assert(%str(paField) = aSortedArray(x)
                     : 'List order does not match expected order');
         endfor;

         // Find a liste entry
         x = BasicList_find(hList: 'Trick');
         p_assert(x > 0
                  : 'List entry ''Trick'' not found');
         paField = BasicList_get(hList: x);
         p_assert(%str(paField) = 'Trick'
                  : 'List entry ''Trick'' contains invalid data');

         // Change elements to new size 3
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            BasicList_set(hList: x: %addr(anArray(x).data): 3);
         endfor;

         // Verify elements in list
         for x = 1 to %elem(anArray);
            paField = BasicList_get(hList: x);
            aSize   = BasicList_getSize(hList: x);
            p_assert(aSize = 3
                     : 'Field size does not match expected size');
            p_assert(%subst(aField: 1: aSize) = %subst(anArray(x).data: 1: 3)
                     : 'Field contents do not match');
            p_assert(%subst(aField: 4: 13) = *ALLx'00'
                     : 'Field has not been properly cleared');
         endfor;

         // Verify number of elements in list
         p_assert(BasicList_getNumE(hList) = 10
                  : 'Number of elements in list does not match +
                     expected number of 10');

         // Add a string to the list
         x = BasicList_addString(hList: 'Hello World');

         isValid = BasicList_isTypeOf(hList: x: cBASICLIST_TYPE_VSTRING);
         p_assert(isValid
                  : '''Hello World'' is not of type VARYING');

         entryType = BasicList_getType(hList: x);
         p_assert(entryType = cBASICLIST_TYPE_VSTRING
                  : '''Hello World'' is not of type STRING (varying)');

         // Get a string from the list
         aString = BasicList_getString(hList: x);

         p_assert(aString = 'Hello World'
                  : 'String contains wrong value');

         // Search the list for a string
         x = BasicList_findString(hList: 'Hello World');
         p_assert(x > 0
                  : 'List entry ''Hello World'' not found');
         aString = BasicList_getString(hList: x);
         p_assert(aString = 'Hello World'
                  : 'List entry ''Hello World'' contains invalid data');

         // Remove the string from the list
         BasicList_remove(hList: x);

         // Check invalid values
         paField = BasicList_get(hList: 99);
         p_assert(paField = *NULL
                  : 'paField should be NULL');

         aString = BasicList_getString(hList: 99);
         p_assert(aString = ''
                  : 'aString should be empty');

         aSize = BasicList_getSize(hList: 99);
         p_assert(aSize = -1
                  : 'aSize should be -1');

         // Check list type
         isValid = BasicList_isListTypeOf(hList: '*TEST');
         p_assert(isValid
                  : 'List type does not match expected value of ' + cTYPE_TEST);
         listType = BasicList_getListType(hList);
         p_assert(listType = cTYPE_TEST
                  : 'List type does not match expected value of ' + cTYPE_TEST);

         // Set auto-sort option
         BasicList_setAutoSort(hList: %paddr('sort'));

         // Add some more entries
         x = BasicList_add(hList: 'aaa');
         x = BasicList_add(hList: 'bbb');
         x = BasicList_add(hList: 'ccc');

         // These entries should be the first entries in the list.
         paField = BasicList_get(hList: 3);
         p_assert(%str(paField) = 'ccc'
                  : 'ccc is not at the expected position in the list');

         paField = BasicList_get(hList: 2);
         p_assert(%str(paField) = 'bbb'
                  : 'bbb is not at the expected position in the list');

         paField = BasicList_get(hList: 1);
         p_assert(%str(paField) = 'aaa'
                  : 'aaa is not at the expected position in the list');

         // Buffer resize check
         bufferCheck = *ALL'*';
         x = BasicList_add(hList: %addr(bufferCheck): 32);
         BasicList_get(hList: x:  %addr(bufferCheck): %size(bufferCheck) - 1);
         p_assert(%subst(bufferCheck:  1: 32) = *ALL'*');
         p_assert(%subst(bufferCheck: 33: %size(bufferCheck) - 33)= *ALLx'00');
         p_assert(%subst(bufferCheck: %size(bufferCheck): 1) = *ALL'*');

         // Add element and increase its size
         BasicList_setAutoSort(hList: *NULL);

         x = BasicList_add(hList: 'HelloWorld');
         aSize   = BasicList_getSize(hList: x);
         p_assert(aSize = 10
                  : 'Field size does not match expected size of 10');

         BasicList_set(hList: x: 'Hello World!');
         aSize   = BasicList_getSize(hList: x);
         p_assert(aSize = 12
                  : 'Field size does not match expected size of 12');

         BasicList_set(hList: x: 'Hello World! I love you.');
         aSize   = BasicList_getSize(hList: x);
         p_assert(aSize = 24
                  : 'Field size does not match expected size of 24');

         // Delete list
         BasicList_delete(hList);

         p_assert(hList = BasicList_null()
                  : 'List handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
      *===============================================================*
      *  Sort procedure
      *===============================================================*
     P sort...
     P                 B
      *
     D sort...
     D                 PI            10I 0
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Helper fields
     D key             S            128A   based(i_pKeyData )
     D elem            S            128A   based(i_pElemData)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         select;
         when %subst(key: 1: i_keySize) > %subst(elem: 1: i_elemSize);
            rc = 1;
         when %subst(key: 1: i_keySize) < %subst(elem: 1: i_elemSize);
            rc = -1;
         other;
            rc = 0;
         endsl;

         return rc;

      /END-FREE
      *
     P sort...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RA_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RA_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicList_*  (NULL)                         "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RA_02)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cTYPE_TEST...
     D                 C                   const('*TEST')
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RA_02')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                            inz
     D numE            S             10I 0                            inz
     D hList           S                   like(BasicList_handle_t )  inz
     D anArray         DS                  dim(10)   qualified
     D  data                               like(aString      )        inz
     D aString         S             32A   varying                    inz
      *
     D elem            DS                  qualified
     D  isNull                       10I 0 inz
     D  isNotNull                    10I 0 inz
      *
     D msg             DS                  likeds(msg_t      )        inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize Array
         anArray( 1).data = 'Donald Duck';
         anArray( 2).data = 'Dagobert Duck';
         anArray( 3).data = 'Tick';
         anArray( 4).data = 'Trick';
         anArray( 5).data = 'Track';
         anArray( 6).data = 'Daisy';
         anArray( 7).data = 'Klaas Klever';
         anArray( 8).data = 'Daniel Dsentrieb';
         anArray( 9).data = 'Micky Maus';
         anArray(10).data = 'Goofy';

         // Create BasicList
         hList = BasicList_new(cTYPE_TEST);

         // Add elements to list
         for x = 1 to %elem(anArray);
            BasicList_addString(hList: anArray(x).data);
         endfor;

         // Verify elements in list
         for x = 1 to %elem(anArray);
            aString = BasicList_getString(hList: x);
            p_assert(aString = anArray(x).data
                     : 'Field contents do not match');
         endfor;

         // Add a NULL values
         x = BasicList_addNull(hList);
         p_assert(x = %elem(anArray) + 1
                  : 'Unexpected number of elements in BasicList');

         x = BasicList_getNumE(hList);
         p_assert(x = %elem(anArray) + 1
                  : 'Unexpected number of elements in BasicList');

         // Test the latest element for a NULL value
         p_assert(BasicList_isNullValue(hList: x)
                  : 'BasicList_isNullValue returned invalid value');

         // Test the last string element for a NULL value
         p_assert(not BasicList_isNullValue(hList: %elem(anArray))
                  : 'BasicList_isNullValue returned invalid value');

         // Set some element to NULL
         numE = BasicList_getNumE(hList);
         BasicList_setNull(hList: 3);
         BasicList_setNull(hList: 6);
         BasicList_setNull(hList: 8);

         // Verify number of elements
         p_assert(BasicList_getNumE(hList) = numE
                  : 'List contains invalid number of elements');

         // Count NULL and non-NULL values
         for x = 1 to BasicList_getNumE(hList);
            if (BasicList_isNullValue(hList: x));
               elem.isNull = elem.isNull + 1;
               p_assert(x = 3 or x = 6 or x = 8 or x = 11
                        : 'Found element that should not be NULL');
            else;
               elem.isNotNull = elem.isNotNull + 1;
            endif;
         endfor;

         p_assert(elem.isNull = 4
                  : 'List contains invalid number of NULL elements');
         p_assert(elem.isNotNull = 7
                  : 'List contains invalid number of non-NULL elements');

         // Delete list
         BasicList_delete(hList);

         p_assert(hList = BasicList_null()
                  : 'List handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RA_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RA_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicList_clone                             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RA_03)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
     D hList_t         DS                  qualified   based(pDummy)   align
     D  intType                      20U 0
     D  intSize                      10U 0
     D  extType                            like(BasicList_type_t  )
     D  memSize                      10U 0
     D  numE                         10U 0
     D  maxNumE                      10U 0
     D  totalMemSize                 10U 0
     D  increment                    10U 0
      /IF NOT DEFINED(*V5R2M0)
     D  signature                          like(signature_t)
     D  sortSignature                      like(signature_t)
      /ELSE
     D  signature                          likeds(signature_t)
     D  sortSignature                      likeds(signature_t)
      /ENDIF
     D  pBase                          *
     D  pAutoSortFnc                   *   procptr
      *
    * *signature_t     DS                  qualified   based(pDummy)   align
    * * tmStmp                         Z
    * * counter                      10U 0
      *
     D signature_t     DS                  qualified   based(pDummy)
     D  time                         10U 0
     D  millitm                      10U 0
     D  counter                      10U 0
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cTYPE_TEST...
     D                 C                   const('*TEST')
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RA_03')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                            inz
     D numE            S             10I 0                            inz
     D hList           S                   like(BasicList_handle_t )  inz
     D hClonedList     S                   like(BasicList_handle_t )  inz
     D anArray         DS                  dim(10)   qualified
     D  data                               like(aString      )        inz
     D aString         S             32A   varying                    inz
     D aString2        S             32A   varying                    inz
      *
     D handle1         DS                  likeds(hList_t ) based(hList       )
     D handle2         DS                  likeds(hList_t ) based(hClonedList )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize Array
         anArray( 1).data = 'Donald Duck';
         anArray( 2).data = 'Dagobert Duck';
         anArray( 3).data = 'Tick';
         anArray( 4).data = 'Trick';
         anArray( 5).data = 'Track';
         anArray( 6).data = 'Daisy';
         anArray( 7).data = 'Klaas Klever';
         anArray( 8).data = 'Daniel Dsentrieb';
         anArray( 9).data = 'Micky Maus';
         anArray(10).data = 'Goofy';

         // Create BasicList
         hList = BasicList_new(cTYPE_TEST);

         // Add elements to list
         for x = 1 to %elem(anArray);
            BasicList_addString(hList: anArray(x).data);
         endfor;

         // Verify elements in list
         for x = 1 to %elem(anArray);
            aString = BasicList_getString(hList: x);
            p_assert(aString = anArray(x).data
                     : 'Field contents do not match');
         endfor;

         // Add a NULL values
         x = BasicList_addNull(hList);
         p_assert(x = %elem(anArray) + 1
                  : 'Unexpected number of elements in BasicList');

         x = BasicList_getNumE(hList);
         p_assert(x = %elem(anArray) + 1
                  : 'Unexpected number of elements in BasicList');

         // Test the latest element for a NULL value
         p_assert(BasicList_isNullValue(hList: x)
                  : 'BasicList_isNullValue returned invalid value');

         // Clone the list
         hClonedList = BasicList_clone(hList);

         // Compare handles
         p_assert(handle1.intType        = handle2.intType        );
         p_assert(handle1.intSize        = handle2.intSize        );
         p_assert(handle1.extType        = handle2.extType        );
         p_assert(handle1.memSize        = handle2.memSize        );
         p_assert(handle1.numE           = handle2.numE           );
         p_assert(handle1.maxNumE        = handle2.maxNumE        );
         p_assert(handle1.totalMemSize   = handle2.totalMemSize   );
         p_assert(handle1.increment      = handle2.increment      );
         p_assert(handle1.signature     <> handle2.signature      );
         p_assert(handle1.sortSignature <> handle2.sortSignature  );
         p_assert(handle1.pBase         <> handle2.pBase          );
         p_assert(handle1.pAutoSortFnc   = handle2.pAutoSortFnc   );

         // Check entries of cloned list
         for x = 1 to BasicList_getNumE(hList);
            aString  = BasicList_getString(hList: x);
            aString2 = BasicList_getString(hClonedList: x);
            p_assert(aString = aString2
                     : 'List entries do not match');
            p_assert(BasicList_isNullValue(hList: x) =
                     BasicList_isNullValue(hClonedList: x)
                     : 'NULL values do not match');
         endfor;

         // Delete list
         BasicList_delete(hList);

         p_assert(hList = BasicList_null()
                  : 'List handle not set to NULL');

         // Delete cloned list
         BasicList_delete(hClonedList);

         p_assert(hClonedList = BasicList_null()
                  : 'Cloned list handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RB_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RB_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicStack_*                                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RB_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RB_01')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                           inz
     D hStack          S                   like(BasicStack_handle_t) inz
     D nbrOfElm        S             10I 0                      inz
     D aSize           S             10I 0                      inz
     D aField          S             20A                             inz
     D aField1         S             20A                             inz
     D aField2         S                   like(aField1      )  based(paField2)
     D aPointer        S               *                             inz
     D anArray         DS                  dim(10)   qualified
     D  size                               like(aSize        )       inz
     D  trimSize                           like(aSize        )       inz
     D  data                               like(aField1      )       inz
      *
     D msg             DS                  likeds(msg_t      )  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize Array
         anArray( 1).data = 'Donald Duck';
         anArray( 2).data = 'Dagobert Duck';
         anArray( 3).data = 'Tick';
         anArray( 4).data = 'Trick';
         anArray( 5).data = 'Track';
         anArray( 6).data = 'Daisy';
         anArray( 7).data = 'Klaas Klever';
         anArray( 8).data = 'Daniel Dsentrieb';
         anArray( 9).data = 'Micky Maus';
         anArray(10).data = 'Goofy';

         // Set size of trimmed field data
         for x = 1 to %elem(anArray);
            anArray(x).size     = %len(anArray(x).data);
            anArray(x).trimSize = %len(%trimR(anArray(x).data));
            p_assert(anArray(x).size <> anArray(x).trimSize
                     : 'Size and trimmed size must be different');
         endfor;

         // Create BasicStack
         hStack = BasicStack_new();

         // Add elements to stack
         for x = 1 to %elem(anArray);
            BasicStack_push(hStack: anArray(x).data);
         endfor;

         // Verify number of elements on stack
         nbrOfElm = BasicStack_getNumE(hStack);
         p_assert(nbrOfElm = %elem(anArray)
                  : 'Number of elements on stack does not match expected +
                     number of ' + %char(%elem(anArray)));

         // Remove elements from stack and verify element data
         for x = %elem(anArray) downto 1;
            aPointer = BasicStack_pop(hStack: %addr(aField1): %size(aField1));
            p_assert(%subst(aField1: 1: anArray(x).size) =
                     %subst(anArray(x).data : 1: anArray(x).trimSize)
                     : 'Entry data does not match');
         endfor;

         // Add elements to stack
         for x = 1 to %elem(anArray);
            BasicStack_push(hStack: anArray(x).data);
         endfor;

         // Remove elements from stack and verify element data
         // (reallocate memory for aField2)
         for x = %elem(anArray) downto 1;
            paField2 = %alloc(%size(aField2));
            aField2  = *all'=';
            aSize    = BasicStack_getSize(hStack);
            aPointer = BasicStack_pop(hStack: paField2: aSize);
            p_assert(%subst(aField2: 1: anArray(x).size) =
                     %subst(anArray(x).data : 1: anArray(x).trimSize)
                     : 'Entry data does not match');
         endfor;

         // Verify number of elements on stack
         nbrOfElm = BasicStack_getNumE(hStack);
         p_assert(nbrOfElm = 0
                  : 'Number of elements on stack does not match expected +
                     number of ' + %char(%elem(anArray)));

         // Delete stack
         BasicStack_delete(hStack);

         // Create a fresh BasicStack
         hStack = BasicStack_new();

         // Check auto-extension of stack
         aField = 'auto-extension check';
         for x = 1 to 1000;
            BasicStack_push(hStack: %addr(aField): %size(aField));
         endfor;

         x = 0;
         dow (BasicStack_getNumE(hStack) > 0);
            BasicStack_pop(hStack: %addr(aField): %size(aField));
            x = x + 1;
         enddo;

         p_assert(x = 1000
                  : 'Did not remove expected number of elements from stack');
         p_assert(BasicStack_getNumE(hStack) = 0
                  : 'Stack should have been empty');

         // Delete stack
         BasicStack_delete(hStack);

         p_assert(hStack = BasicStack_null()
                  : 'Stack handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RC_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RC_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicMap_*                                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RC_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RC_01')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                           inz
     D y               S             10I 0                           inz
     D hMap            S                   like(BasicMap_handle_t  ) inz
     D nbrOfElm        S             10I 0                      inz
     D aSize           S             10I 0                      inz
     D aField          S           3000A                             inz
     D aPointer        S               *                             inz
     D isFound         S               N                             inz
     D anArray         DS                  dim(10)   qualified
     D  size                               like(aSize        )       inz
     D  trimSize                           like(aSize        )       inz
     D  data                               like(aField       )       inz
      *
     D msg             DS                  likeds(msg_t      )  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Initialize Array
         anArray( 1).data = 'Donald Duck';
         anArray( 2).data = 'Dagobert Duck';
         anArray( 3).data = 'Tick';
         anArray( 4).data = 'Trick';
         anArray( 5).data = 'Track';
         anArray( 6).data = 'Daisy';
         anArray( 7).data = 'Klaas Klever';
         anArray( 8).data = 'Daniel Dsentrieb';
         anArray( 9).data = 'Micky Maus';
         anArray(10).data = 'Goofy';

         // Set size of trimmed field data
         for x = 1 to %elem(anArray);
            anArray(x).size     = %len(anArray(x).data);
            anArray(x).trimSize = %len(%trimR(anArray(x).data));
            p_assert(anArray(x).size <> anArray(x).trimSize                                 //RADDAT
                     : 'Size and trimmed size must be different');
         endfor;

         // Create BasicMap
         hMap = BasicMap_new();

         // Add elements to map
         for x = 1 to %elem(anArray);
            y = %elem(anArray) - x + 1;
            BasicMap_put(hMap: 'Element_' + %editc(y: 'X')
                             : %addr(anArray(x).data)
                             : anArray(x).trimSize   );
         endfor;

         // Verify number of elements on stack
         nbrOfElm = BasicMap_getNumE(hMap);
         p_assert(nbrOfElm = %elem(anArray)
                  : 'Number of elements on stack does not match expected +
                     number of ' + %char(%elem(anArray)));

         // Search map for key 'Element_0000000003'
         x = 3;
         aPointer = BasicMap_get(hMap: 'Element_' + %editc(x: 'X')
                                     : %addr(aField)
                                     : %size(aField));

         p_assert(aPointer <> *NULL
                  : 'Entry not found: ' + 'Element_3');

         // Check map for key 'Element_0000000007'
         x = 7;
         isFound = BasicMap_containsKey(hMap: 'Element_' + %editc(x: 'X'));

         p_assert(isFound
                  : 'Entry not found: ' + 'Element_7');

         // Check map for key 'Element_99'
         x = 99;
         isFound = BasicMap_containsKey(hMap: 'Element_' + %editc(x: 'X'));

         p_assert(not isFound
                  : 'Entry found: ' + 'Element_99');

         // Get element by index
         for x = 1 to %elem(anArray);
            y = %elem(anArray) - x + 1;
            aPointer = BasicMap_getValueByIndex(hMap: x
                                                    : %addr(aField)
                                                    : %size(aField));
            p_assert(aPointer <> *NULL
                     : 'Entry not found: ' + 'index=4');
            p_assert(%str(aPointer) = anArray(y).data
                     : 'Element contains invalid data');
         endfor;

         // Change size of data
         BasicMap_put(hMap: 'ChangeSize': 'HelloWorld');
         p_assert(BasicMap_getSize(hMap: 'ChangeSize') = 10);

         BasicMap_put(hMap: 'ChangeSize': 'Hello World!');
         p_assert(BasicMap_getSize(hMap: 'ChangeSize') = 12);

         // Delete map
         BasicMap_delete(hMap);

         p_assert(hMap = BasicMap_null()
                  : 'Map handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RC_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RC_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicMap - Memory Leaks                     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RC_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RC_01')
      *
     D main...
     D                 PR
      *
     D getOutstandingHeapAllocations...
     D                 PR            20I 0
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Returns the number of outstanding heap allocations.
      *===============================================================*
     P getOutstandingHeapAllocations...
     P                 B
      *
     D getOutstandingHeapAllocations...
     D                 PI            20I 0
      *
      *  Return value
     D outAllocs       S             20I 0 inz
      *
      *  Helper fields
     D x               S             10I 0 inz
     D tplSize         S             10I 0 inz
     D MAGP_AG_Attr    DS                  likeds(MAGP_Template_t  ) inz
     D heapIdTpl       DS                  likeds(heapIdTpl_t     ) inz
     D MAGP_AG_Heap_List...
     D                 DS                  likeds(MAGP_Template_t )
     D                                     based(pMAGP_AG_Heap_List)
     D Heap_List_Buffer...
     D                 S           1024A   inz(*ALLx'00')
     D MAGP_Heap_Space_Attr...
     D                 DS                  likeds(MAGP_Heap_Space_Attr_t) inz
     D Heap_List_Entry...
     D                 S                   like(MAGP_Template_t.Heap_List_1)
     D                                     based(pHeap_List_Entry)
      *
      *  Reference fields
     D MAGP_Template_t...
     D                 DS                  qualified               based(pDummy)
     D  bytPrv                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     16A
      *  union:
     D  Basic_Attr                         likeds(MAGP_AG_Attr_t)
     D  Heap_List_1                  10I 0 overlay(Basic_Attr)
     D  Act_List_1                   20U 0 overlay(Basic_Attr)
      *
     D MAGP_actGrpMark_t...
     D                 S             20U 0                         based(pDummy)
      *
     D MAGP_AG_Attr_t...
     D                 DS                  qualified               based(pDummy)
     D  rootProgram            1     16*
     D  reserved_1            17     32A
     D  stgAdrRclKey          33     48*
     D  actGrpName            49     78A
     D  reserved_2            79     80A
     D  actGrpMark            81     84U 0
     D  reserved_3            85     88A
     D  heapSpcCnt            89     92U 0
     D  actCnt                93     96U 0
     D  staticStgSize         97    100U 0
     D  autoStgSize          101    104U 0
     D  attrs                105    105A
     D  pagMbrShpAdvA        106    106A
     D  reserved_7           107    112A
     D  actGrpMark2          113    120U 0
      *
     D cMATAGPAT_ATTR_BASIC_ACTGRP_ATTR...
     D                 C                   x'00'
     D cMATAGPAT_ATTR_BASIC_ACTGRP_HEAP_LIST...
     D                 C                   x'01'
      *
      *  Materialize Activation Group Attributes (MATAGPAT)
     D matagpat2...
     D                 PR                  extproc('_MATAGPAT2')
     D  o_rcvVar                       *   value
     D  i_actGrpMark                       const  like(MAGP_actGrpMark_t)
     D  i_attrSlc                     3U 0 const
      *
     D heapIdTpl_t     DS                  qualified   align       based(pDummy)
     D  actGrpMark                         like(MAGP_actGrpMark_t)
     D  reserved_1                    4A
     D  heapID                       10U 0
      *
     D MAGP_Heap_Space_Attr_t...
     D                 DS                  qualified   align       based(pDummy)
     D  bytPrv                 1      4I 0
     D  bytAvl                 5      8I 0
     D  maxSnglAlc             9     12U 0
     D  minBndryReq           13     16U 0
     D  crtSize               17     20U 0
     D  extSize               21     24U 0
     D  domain                25     26I 0
     D  heapCrtOpts           27     32A
     D  reserved_1            33     96A
     D  curNbrOutAlc          97    100U 0
     D  totNbrRealloc        101    104U 0
     D  totNbrFrees          105    108U 0
     D  totNbrAllocs         109    112U 0
     D  maxNbrOutAlc         113    116U 0
     D  sizeHeapSpace        117    120U 0
     D  nbrOutMarks          121    124U 0
     D  totNbrExt            125    128U 0
      *
     D cMATHSAT_ATTR...
     D                 C                   x'00'
      *
      *  Materialize Activation Group-Based Heap Space Attributes (MATHSAT)
     D mathsat2...
     D                 PR                  EXTPROC('_MATHSAT2')
     D  o_rcvVar                       *   value
     D  i_heapIdTpl                        const  likeds(heapIdTpl_t)
     D  i_attrSlc                     3U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         MAGP_AG_Attr.bytPrv = %size(MAGP_AG_Attr);
         matagpat2(%addr(MAGP_AG_Attr)
                   : 0
                   : cMATAGPAT_ATTR_BASIC_ACTGRP_ATTR);

         // ... materialize activation group heap list
         tplSize = 16 + MAGP_AG_Attr.Basic_Attr.heapSpcCnt *
                        %size(MAGP_AG_Heap_List.Heap_List_1);
         pMAGP_AG_Heap_List = %addr(Heap_List_Buffer);
         MAGP_AG_Heap_List.bytPrv = tplSize;

         p_assert(tplSize <= %size(Heap_List_Buffer));

         matagpat2(%addr(MAGP_AG_Heap_List)
                   : MAGP_AG_Attr.Basic_Attr.actGrpMark2
                   : cMATAGPAT_ATTR_BASIC_ACTGRP_HEAP_LIST);

         for x = 1 to MAGP_AG_Attr.Basic_Attr.heapSpcCnt;
            pHeap_List_Entry = %addr(MAGP_AG_Heap_List.Heap_List_1) +
                                (x-1) * %size(MAGP_AG_Heap_List.Heap_List_1);
            clear MAGP_Heap_Space_Attr;
            MAGP_Heap_Space_Attr.bytPrv = %size(MAGP_Heap_Space_Attr);
            clear heapIdTpl;
            heapIdTpl.actGrpMark = MAGP_AG_Attr.Basic_Attr.actGrpMark2;
            heapIdTpl.heapID     = Heap_List_Entry;
            mathsat2(%addr(MAGP_Heap_Space_Attr)
                     : heapIdTpl
                     : cMATHSAT_ATTR);
            outAllocs = outAllocs + MAGP_Heap_Space_Attr.curNbrOutAlc;
         endfor;

         return outAllocs;

      /END-FREE
      *
     P getOutstandingHeapAllocations...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                           inz
     D hMap            S                   like(BasicMap_handle_t  ) inz
     D startAllocs     S             20I 0 inz
     D endAllocs       S             20I 0 inz
      *
     D msg             DS                  likeds(msg_t      )  inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         startAllocs = getOutstandingHeapAllocations();

         hMap = BasicMap_new();

         for x = 1 to 20000;
            BasicMap_put(hMap: %char(x): 'Hello World!');
            BasicMap_remove(hMap: %char(x));
         endfor;

         BasicMap_delete(hMap);

         endAllocs = getOutstandingHeapAllocations();

         p_assert(startAllocs = endAllocs
                  : 'Out of expected memory utilization');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RC_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RC_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicMap - KeySet                           "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RC_03)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RC_03')
      *
     D main...
     D                 PR
      *
     D getOutstandingHeapAllocations...
     D                 PR            20I 0
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Returns the number of outstanding heap allocations.
      *===============================================================*
     P getOutstandingHeapAllocations...
     P                 B
      *
     D getOutstandingHeapAllocations...
     D                 PI            20I 0
      *
      *  Return value
     D outAllocs       S             20I 0 inz
      *
      *  Helper fields
     D x               S             10I 0 inz
     D tplSize         S             10I 0 inz
     D MAGP_AG_Attr    DS                  likeds(MAGP_Template_t  ) inz
     D heapIdTpl       DS                  likeds(heapIdTpl_t     ) inz
     D MAGP_AG_Heap_List...
     D                 DS                  likeds(MAGP_Template_t )
     D                                     based(pMAGP_AG_Heap_List)
     D Heap_List_Buffer...
     D                 S           1024A   inz(*ALLx'00')
     D MAGP_Heap_Space_Attr...
     D                 DS                  likeds(MAGP_Heap_Space_Attr_t) inz
     D Heap_List_Entry...
     D                 S                   like(MAGP_Template_t.Heap_List_1)
     D                                     based(pHeap_List_Entry)
      *
      *  Reference fields
     D MAGP_Template_t...
     D                 DS                  qualified               based(pDummy)
     D  bytPrv                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     16A
      *  union:
     D  Basic_Attr                         likeds(MAGP_AG_Attr_t)
     D  Heap_List_1                  10I 0 overlay(Basic_Attr)
     D  Act_List_1                   20U 0 overlay(Basic_Attr)
      *
     D MAGP_actGrpMark_t...
     D                 S             20U 0                         based(pDummy)
      *
     D MAGP_AG_Attr_t...
     D                 DS                  qualified               based(pDummy)
     D  rootProgram            1     16*
     D  reserved_1            17     32A
     D  stgAdrRclKey          33     48*
     D  actGrpName            49     78A
     D  reserved_2            79     80A
     D  actGrpMark            81     84U 0
     D  reserved_3            85     88A
     D  heapSpcCnt            89     92U 0
     D  actCnt                93     96U 0
     D  staticStgSize         97    100U 0
     D  autoStgSize          101    104U 0
     D  attrs                105    105A
     D  pagMbrShpAdvA        106    106A
     D  reserved_7           107    112A
     D  actGrpMark2          113    120U 0
      *
     D cMATAGPAT_ATTR_BASIC_ACTGRP_ATTR...
     D                 C                   x'00'
     D cMATAGPAT_ATTR_BASIC_ACTGRP_HEAP_LIST...
     D                 C                   x'01'
      *
      *  Materialize Activation Group Attributes (MATAGPAT)
     D matagpat2...
     D                 PR                  extproc('_MATAGPAT2')
     D  o_rcvVar                       *   value
     D  i_actGrpMark                       const  like(MAGP_actGrpMark_t)
     D  i_attrSlc                     3U 0 const
      *
     D heapIdTpl_t     DS                  qualified   align       based(pDummy)
     D  actGrpMark                         like(MAGP_actGrpMark_t)
     D  reserved_1                    4A
     D  heapID                       10U 0
      *
     D MAGP_Heap_Space_Attr_t...
     D                 DS                  qualified   align       based(pDummy)
     D  bytPrv                 1      4I 0
     D  bytAvl                 5      8I 0
     D  maxSnglAlc             9     12U 0
     D  minBndryReq           13     16U 0
     D  crtSize               17     20U 0
     D  extSize               21     24U 0
     D  domain                25     26I 0
     D  heapCrtOpts           27     32A
     D  reserved_1            33     96A
     D  curNbrOutAlc          97    100U 0
     D  totNbrRealloc        101    104U 0
     D  totNbrFrees          105    108U 0
     D  totNbrAllocs         109    112U 0
     D  maxNbrOutAlc         113    116U 0
     D  sizeHeapSpace        117    120U 0
     D  nbrOutMarks          121    124U 0
     D  totNbrExt            125    128U 0
      *
     D cMATHSAT_ATTR...
     D                 C                   x'00'
      *
      *  Materialize Activation Group-Based Heap Space Attributes (MATHSAT)
     D mathsat2...
     D                 PR                  EXTPROC('_MATHSAT2')
     D  o_rcvVar                       *   value
     D  i_heapIdTpl                        const  likeds(heapIdTpl_t)
     D  i_attrSlc                     3U 0 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         MAGP_AG_Attr.bytPrv = %size(MAGP_AG_Attr);
         matagpat2(%addr(MAGP_AG_Attr)
                   : 0
                   : cMATAGPAT_ATTR_BASIC_ACTGRP_ATTR);

         // ... materialize activation group heap list
         tplSize = 16 + MAGP_AG_Attr.Basic_Attr.heapSpcCnt *
                        %size(MAGP_AG_Heap_List.Heap_List_1);
         pMAGP_AG_Heap_List = %addr(Heap_List_Buffer);
         MAGP_AG_Heap_List.bytPrv = tplSize;

         p_assert(tplSize <= %size(Heap_List_Buffer));

         matagpat2(%addr(MAGP_AG_Heap_List)
                   : MAGP_AG_Attr.Basic_Attr.actGrpMark2
                   : cMATAGPAT_ATTR_BASIC_ACTGRP_HEAP_LIST);

         for x = 1 to MAGP_AG_Attr.Basic_Attr.heapSpcCnt;
            pHeap_List_Entry = %addr(MAGP_AG_Heap_List.Heap_List_1) +
                                (x-1) * %size(MAGP_AG_Heap_List.Heap_List_1);
            clear MAGP_Heap_Space_Attr;
            MAGP_Heap_Space_Attr.bytPrv = %size(MAGP_Heap_Space_Attr);
            clear heapIdTpl;
            heapIdTpl.actGrpMark = MAGP_AG_Attr.Basic_Attr.actGrpMark2;
            heapIdTpl.heapID     = Heap_List_Entry;
            mathsat2(%addr(MAGP_Heap_Space_Attr)
                     : heapIdTpl
                     : cMATHSAT_ATTR);
            outAllocs = outAllocs + MAGP_Heap_Space_Attr.curNbrOutAlc;
         endfor;

         return outAllocs;

      /END-FREE
      *
     P getOutstandingHeapAllocations...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                           inz
     D hMap            S                   like(BasicMap_handle_t  ) inz
     D startAllocs     S             20I 0 inz
     D endAllocs       S             20I 0 inz
     D tmpAllocs       S             20I 0 inz
      *
     D hKeySet1        S                   like(BasicKeySet_handle_t) inz
     D hKeySet2        S                   like(BasicKeySet_handle_t) inz
      *
     D msg             DS                  likeds(msg_t      )  inz
      *
     D refArray        S             20A   varying dim(32)  ascend
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         startAllocs = getOutstandingHeapAllocations();

         hMap = BasicMap_new();

         for x = 1 to 32;
            BasicMap_put(hMap: %char(x): 'Hello World!');
            refArray(x) = %char(x);
         endfor;

         sorta refArray;

         hKeySet1 = BasicMap_newKeySet(hMap);
         hKeySet2 = BasicMap_newKeySet(hMap);

         for x = 1 to 5;
            if (x = 1);
               p_assert(refArray(x) = BasicKeySet_getFirst(hKeySet1)
                        : 'Invalid return value from +
                           BasicKeySet_getFirst()');
            else;
               p_assert(refArray(x) = BasicKeySet_getNext(hKeySet1)
                        : 'Invalid return value from +
                           BasicKeySet_getNext()');
            endif;
         endfor;

         for x = 1 to 20;
            if (x = 1);
               p_assert(refArray(x) = BasicKeySet_getFirst(hKeySet2)
                        : 'Invalid return value from +
                           BasicKeySet_getFirst()');
            else;
               p_assert(refArray(x) = BasicKeySet_getNext(hKeySet2)
                        : 'Invalid return value from +
                           BasicKeySet_getNext()');
            endif;
         endfor;

         for x = 6 to 32;
            p_assert(refArray(x) = BasicKeySet_getNext(hKeySet1)
                     : 'Invalid return value from +
                        BasicKeySet_getNext()');
         endfor;

         for x = 21 to 32;
            p_assert(refArray(x) = BasicKeySet_getNext(hKeySet2)
                     : 'Invalid return value from +
                        BasicKeySet_getNext()');
         endfor;

         BasicKeySet_delete(hKeySet1);

         tmpAllocs = getOutstandingHeapAllocations();

         BasicKeySet_delete(hKeySet2);

         BasicMap_delete(hMap);

         endAllocs = getOutstandingHeapAllocations();

         p_assert(startAllocs = endAllocs
                  : 'Out of expected memory utilization');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RC_04  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RC_04"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicMap_clone                              "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RC_04)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RC_04')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0                           inz
     D hMap            S                   like(BasicMap_handle_t  ) inz
     D hClonedMap      S                   like(BasicMap_handle_t  ) inz
      *
     D value1          DS                  qualified
     D  key                                like(BasicMap_key_t ) inz
     D  size                         10I 0 inz
     D  pData                          *   inz
     D  string                       32A   inz
      *
     D value2          DS                  likeds(value1 ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create a BasicMap
         hMap = BasicMap_new();

         // Add some entries to it
         for x = 1 to 32;
            BasicMap_putString(hMap: %char(x): %char(x) + '. Hello World!');
         endfor;

         // Add a NULL entry
         BasicMap_put(hMap: %char(x): *NULL);

         // Clone the BasicMap
         hClonedMap = BasicMap_clone(hMap);

         // Check entries of cloned map
         for x = 1 to BasicMap_getNumE(hMap);
            value1.key    = BasicMap_getKeyByIndex(hMap: x);
            value1.pData  = BasicMap_getValueByIndex(hMap: x);
            value1.size   = BasicMap_getSizeByIndex(hMap: x);
            value1.string = BasicMap_getString(hMap: value1.key);

            value2.key    = BasicMap_getKeyByIndex(hClonedMap: x);
            value2.pData  = BasicMap_getValueByIndex(hClonedMap: x);
            value2.size   = BasicMap_getSizeByIndex(hClonedMap: x);
            value2.string = BasicMap_getString(hClonedMap: value2.key);

            p_assert(value1.string = value2.string
                     : 'Map entries do not match');

            if (value1.pData = *NULL);
               p_assert(value1.pData  = value2.pData
                        : 'Map NULL entries do not match');
            endif;
         endfor;

         // Delete the BasicMap
         BasicMap_delete(hMap);
         p_assert(hMap = BasicMap_null()
                  : 'Map handle not set to NULL');

         // Delete the cloned BasicMap
         BasicMap_delete(hClonedMap);
         p_assert(hClonedMap = BasicMap_null()
                  : 'Cloned map handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RC_05  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RC_05"
mbrtype =  "RPGLE     "
mbrtext =  "Test: BasicMap_getKeys/getValues                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RC_05)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
     D key_t           S            256A   varying                 based(pDummy)
     D value_t...
     D                 DS                  qualified               based(pDummy)
     D  seq                          10I 0
     D  data                         32A   varying
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RC_05')
      *
     D main...
     D                 PR
      *
      *  Comparator for comparing to 'key' values.
     D compareKeys...
     D                 PR            10I 0 extproc('compareKeys')
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *  Comparator for comparing to 'value' structures.
     D compareValues...
     D                 PR            10I 0 extproc('compareValues')
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Comparator for comparing to 'key' values.
      *===============================================================*
     P compareKeys...
     P                 B
      *
     D compareKeys...
     D                 PI            10I 0
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
     D rc              S             10I 0 inz
     D key             S                   like(key_t     ) based(i_pKeyData )
     D elem            S                   like(key_t     ) based(i_pElemData)
     D null            S                   like(key_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pElemData = *NULL);
            i_pElemData = %addr(null);
         endif;

         if (i_pKeyData = *NULL);
            i_pKeyData = %addr(null);
         endif;

         select;
         when (key < elem);
            rc = -1;
         when (key > elem);
            rc = 1;
         other;
            rc = 0;
         endsl;

         return rc * -1;   // Sort descending

      /END-FREE
      *
     P compareKeys...
     P                 E
      *
      *===============================================================*
      *  Comparator for comparing to 'value' structures.
      *===============================================================*
     P compareValues...
     P                 B
      *
     D compareValues...
     D                 PI            10I 0
     D  i_pKeyData                     *   value
     D  i_keySize                    10I 0 value
     D  i_pElemData                    *   value
     D  i_elemSize                   10I 0 value
      *
     D rc              S             10I 0 inz
     D key             DS                  likeds(value_t ) based(i_pKeyData )
     D elem            DS                  likeds(value_t ) based(i_pElemData)
     D null            DS                  likeds(value_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (i_pElemData = *NULL);
            i_pElemData = %addr(null);
         endif;

         if (i_pKeyData = *NULL);
            i_pKeyData = %addr(null);
         endif;

         select;
         when (key.seq < elem.seq);
            rc = -1;
         when (key.seq > elem.seq);
            rc = 1;
         other;
            rc = 0;
         endsl;

         return rc * -1;   // Sort descending

      /END-FREE
      *
     P compareValues...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D x               S             10I 0 inz
     D lastKey         S             10I 0 inz
     D lastSeq         S             10I 0 inz
     D hMap            S                   like(BasicMap_handle_t  ) inz
     D key             S                   like(key_t     ) inz
     D value           DS                  likeds(value_t ) inz
     D hKeys           S                   like(BasicList_handle_t ) inz
     D hValues         S                   like(BasicList_handle_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create a BasicMap
         hMap = BasicMap_new();

         // Add some entries to it
         for x = 1 to 32;
            clear value;
            value.seq  = x;
            value.data = %char(x) + '. Hello World!';
            key = %editc(x: 'X');
            BasicMap_put(hMap: key: %addr(value): %size(value));
         endfor;

         // Add a NULL entry
         key = %editc(x: 'X');
         BasicMap_put(hMap: key: *NULL);

         // Get all keys that are in the map
         hKeys = BasicMap_getKeys(hMap: %paddr('compareKeys'));

         // Check keys
         x = BasicList_getNumE(hKeys);
         lastKey = *HIVAL;
         for x = 1 to BasicList_getNumE(hKeys);
            key = BasicList_getString(hKeys: x);
            p_assert(lastKey > f_val(key)
                     : 'lastKey must be greater than key');
            lastKey = f_val(key);
         endfor;

         // Delete the list of keys
         BasicList_delete(hKeys);

         // Get all values that are in the map
         hValues = BasicMap_getValues(hMap: %paddr('compareValues'));

         // Check values
         x = BasicList_getNumE(hValues);
         lastSeq = *HIVAL;
         for x = 1 to BasicList_getNumE(hValues);
            BasicList_get(hValues: x: %addr(value): %size(value));
            p_assert(lastSeq > value.seq
                     : 'lastSeq must be greater than value.seq');
            lastSeq = value.seq;
         endfor;

         // Delete the list of values
         BasicList_delete(hValues);

         // Delete the BasicMap
         BasicMap_delete(hMap);
         p_assert(hMap = BasicMap_null()
                  : 'Map handle not set to NULL');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RD_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RD_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: Url_*                                       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RD_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RD_01')
      *
     D main...
     D                 PR
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR
     D  i_text                      128A   value  varying
     D  i_doSendToExt                  N   VALUE  options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
      *
     D sndMsg...
     D                 PI
     D  i_text                      128A   value  varying
     D  i_doSendToExt                  N   VALUE  options(*nopass)
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )            | optGrp 1
     D   i_callStkEQ                 20A   const  options(*nopass  )            |
     D   i_wait                      10I 0 const  options(*nopass  )            |
     D   i_callStkEDT                10A   const  options(*nopass  )            | optGrp 2
     D   i_ccsid                     10I 0 const  options(*nopass  )            |
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      *
      /FREE

         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';

         clear errCode;
         errCode.bytPrv = %size(errCode);

         if %parms() >= 2 and i_doSendToExt;
            QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                     : '*CTLBDY': 1
                     : msgKey: errCode);
         else;
            QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                     : '*CTLBDY': 0
                     : msgKey: errCode);
         endif;

         return;

      /END-FREE
      *
     P sndMsg...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      *
     D isSet           S               N   inz(cFalse)
     D isOK            S               N   inz(cFalse)
     D rc              S             10I 0 inz
     D url             S                   like(url_t )
     D stringUrl       S                   like(url_t )
     D integer         S             10I 0 inz
     D string          S            512A   varying inz
     D file            S             10A   inz
     D lib             S             10A   inz
     D mbr             S             10A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create URL
         stringUrl =
            'http://www.tools400.de:80/downloads/basics1.zip?fast=y;secure=n';

         url = Url_new(stringUrl);

         // Check string representation
         string = Url_toString(url);
         p_assert(string = stringUrl:
                  'Invalid string representation: ' + string);
         sndMsg('Url_toString(): ' + string: cTrue);

         // Check protocol
         string = Url_getProtocol(url);
         p_assert(string = 'http':
                  'Invalid protocol: ' + string + ' Expected ''http''');
         sndMsg('Url_getProtocol(): ' + string: cTrue);

         // Check host
         string = Url_getHost(url);
         p_assert(string = 'www.tools400.de':
                  'Invalid host: ' + string + ' Expected ''www.tools400.de''');
         sndMsg('Url_getHost(): ' + string: cTrue);

         // Check port
         integer = Url_getPort(url);
         p_assert(integer = 80:
                  'Invalid port: ' + %char(integer) + ' Expected ''80''');
         sndMsg('Url_getPort(): ' + %char(integer): cTrue);

         // Check path
         string = Url_getPath(url);
         p_assert(string = '/downloads/basics1.zip':
                  'Invalid path: ' + string +
                  ' Expected ''/downloads/basics1.zip''');
         sndMsg('Url_getPath(): ' + string: cTrue);

         // Check file
         string = Url_getFile(url);
         p_assert(string = '/downloads/basics1.zip?fast=y;secure=n':
                  'Invalid path: ' + string +
                  ' Expected ''/downloads/basics1.zip?fast=y;secure=n''');
         sndMsg('Url_getFile(): ' + string: cTrue);

         // Check query
         string = Url_getQuery(url);
         p_assert(string = 'fast=y;secure=n':
                  'Invalid path: ' + string +
                  ' Expected ''fast=y;secure=n''');
         sndMsg('Url_getQuery(): ' + string: cTrue);

         // Now change the URL
         // ... protocol
         isSet = Url_setProtocol(url: 'https': rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         string = Url_getProtocol(url);
         p_assert(string = 'https':
                  'Invalid protocol: ' + string + ' Expected ''https''');

         // ... host
         isSet = Url_setHost(url: 'www.tools400.com': rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         string = Url_getHost(url);
         p_assert(string = 'www.tools400.com':
                  'Invalid host: ' + string + ' Expected ''www.tools400.com''');

         // ... port
         isSet = Url_setPort(url: 8080: rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         integer = Url_getPort(url);
         p_assert(integer = 8080:
                  'Invalid port: ' + %char(integer) + ' Expected ''8080''');

         // ... path
         isSet = Url_setPath(url: '/HelloWorld.zip': rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         string = Url_getPath(url);
         p_assert(string = '/HelloWorld.zip':
                  'Invalid path: ' + string +
                  ' Expected ''/HelloWorld.zip''');
         string = Url_getQuery(url);   // Query must have remained unchanged!
         p_assert(string = 'fast=y;secure=n':
                  'Invalid path: ' + string +
                  ' Expected ''fast=y;secure=n''');

         // ... query
         isSet = Url_setQuery(url: '?blueSky=sure': rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         string = Url_getQuery(url);
         p_assert(string = 'blueSky=sure':
                  'Invalid path: ' + string +
                  ' Expected ''blueSky=sure''');

         // ... file
         isSet = Url_setFile(url: '/Holiday.zip?forever=n': rc);
         p_assert(isSet = cTrue: 'Invalid return value: ' + isSet);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         string = Url_getFile(url);
         p_assert(string = '/Holiday.zip?forever=n':
                  'Invalid path: ' + string +
                  ' Expected ''/Holiday.zip?forever=n''');

         // Test a special 'mbr' URL (FTP syntax)
         stringUrl = 'mbr:QUSRSYS/QBASICS1.A_README';

         url = Url_new(stringUrl);
         isOK = Url_getMbr(url: file: lib:mbr: rc);
         p_assert(isOK = cTrue: 'Invalid return value: ' + isOK);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         p_assert(file = 'QBASICS1':
                  'Invalid return parameter ''file'': ' + file);
         p_assert(lib  = 'QUSRSYS':
                  'Invalid return parameter ''lib'': ' + lib);
         p_assert(mbr  = 'A_README':
                  'Invalid return parameter ''mbr'': ' + mbr);

         // Test a special 'mbr' URL (Client Access syntax)
         stringUrl = 'mbr:QUSRSYS/QBASICS1(BASICS1C7)';

         url = Url_new(stringUrl);
         isOK = Url_getMbr(url: file: lib:mbr: rc);
         p_assert(isOK = cTrue: 'Invalid return value: ' + isOK);
         p_assert(rc = 0: 'Invalid return parameter: ' + %char(rc));
         p_assert(file = 'QBASICS1':
                  'Invalid return parameter ''file'': ' + file);
         p_assert(lib  = 'QUSRSYS':
                  'Invalid return parameter ''lib'': ' + lib);
         p_assert(mbr  = 'BASICS1C7':
                  'Invalid return parameter ''mbr'': ' + mbr);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RE_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RE_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: dateSerial()                                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RE_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RE_01')
     D  gi_year                      15P 5 const  options(*nopass)
     D  gi_month                     15P 5 const  options(*nopass)
     D  gi_day                       15P 5 const  options(*nopass)
      *
     D main...
     D                 PR
     D  i_year                       10I 0 const
     D  i_month                      10I 0 const
     D  i_day                        10I 0 const
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR
     D  i_text                      128A   value  varying
     D  i_doSendToExt                  N   VALUE  options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_year                      15P 5 const  options(*nopass)
     D  gi_month                     15P 5 const  options(*nopass)
     D  gi_day                       15P 5 const  options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= 3);
            main(gi_year: gi_month: gi_day);
         else;
            main(1900: 1: 1);
         endif;

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
      *
     D sndMsg...
     D                 PI
     D  i_text                      128A   value  varying
     D  i_doSendToExt                  N   VALUE  options(*nopass)
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )            | optGrp 1
     D   i_callStkEQ                 20A   const  options(*nopass  )            |
     D   i_wait                      10I 0 const  options(*nopass  )            |
     D   i_callStkEDT                10A   const  options(*nopass  )            | optGrp 2
     D   i_ccsid                     10I 0 const  options(*nopass  )            |
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      *
      /FREE

         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';

         clear errCode;
         errCode.bytPrv = %size(errCode);

         if %parms() >= 2 and i_doSendToExt;
            QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                     : '*CTLBDY': 1
                     : msgKey: errCode);
         else;
            QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                     : '*CTLBDY': 0
                     : msgKey: errCode);
         endif;

         return;

      /END-FREE
      *
     P sndMsg...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_year                       10I 0 const
     D  i_month                      10I 0 const
     D  i_day                        10I 0 const
      *
      *  Helper fields
     D days            S             10I 0 inz
     D months          S             10I 0 inz
     D years           S             10I 0 inz
     D today           S               D   inz
     D date            S               D   inz
     D inpDate         S               D   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         today = %date();

         // Produce todays's date
         date = f_dateSerial(%subdt(today: *YEARS)
                             : %subdt(today: *MONTHS)
                             : %subdt(today: *DAYS));
         p_assert(date = today
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date - 10 days
         days = -10;
         months = 0;
         years  = 0;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date - 5 months
         months = -5;
         months = 0;
         years  = 0;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date + 10 days
         days = 10;
         months = 0;
         years  = 0;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date + 5 months
         months = 5;
         months = 0;
         years  = 0;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date + 7 days - 4 months
         days   = 7;
         months = -4;
         years  = 0;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date + 7 days - 4 months + 10 years
         days   = 7;
         months = -4;
         years  = 10;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce todays's date - 7 days + 4 months - 10 years
         days   = -7;
         months = 4;
         years  = -10;
         date = f_dateSerial(%subdt(today: *YEARS)    + years
                             : %subdt(today: *MONTHS) + months
                             : %subdt(today: *DAYS)   + days);
         p_assert(date = today + %years(years) + %months(months) + %days(days)
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(today) + '''');

         // Produce date from passed values
         date = f_dateSerial(i_year: i_month: i_day);
         inpDate = %date(%editc(%dec(i_year : 4: 0): 'X') + '-' +
                         %editc(%dec(i_month: 2: 0): 'X') + '-' +
                         %editc(%dec(i_day  : 2: 0): 'X'));
         p_assert(date = inpDate
                  : 'Returned value ''' + %char(date) + ''' does not match +
                     expected value ''' + %char(inpDate) + '''');
         sndMsg('The specified date was: ' + %char(date): cTrue);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_RH_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_RH_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: MemoryReader / MemoryWriter                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_RH_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *     >>EXECUTE<<                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_RH_01')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D hReader         S                   like(memRdr_handle_t) inz
     D hWriter         S                   like(memWtr_handle_t) inz
     D fromBuffer      S           1024A   inz
     D toBuffer        S           1024A   inz
     D tBuffer         S              3A   inz
     D nRead           S             10I 0 inz
     D nWrite          S             10I 0 inz
     D errno           S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         fromBuffer = 'The quick brown fox jumps over the lazy dog.';
         toBuffer   = '';

         hReader = MemoryReader_new(%addr(fromBuffer):%len(%trimR(fromBuffer)));
         hWriter = MemoryWriter_new(%addr(toBuffer  ):%size(toBuffer  ));

         dou (nRead = 0 or nRead = RC_ERROR);
            nRead = MemoryReader_read(hReader: %addr(tBuffer): %size(tBuffer));
            if (nRead > 0);
               nWrite = MemoryWriter_write(hWriter: %addr(tBuffer): nRead);
               p_assert(nRead = nWrite
                        : 'nRead (' + %char(nRead) +
                          ') does not match nWrite (' + %char(nWrite) + ')');
            endif;
         enddo;

         MemoryReader_delete(hReader);
         MemoryWriter_delete(hWriter);

         p_assert(hReader = 0: 'hReader must be 0');
         p_assert(hWriter = 0: 'hWriter must be 0');

         p_assert(%trimR(fromBuffer) = %trimR(toBuffer)
                  : 'fromBuffer is not equal to toBuffer');

         // ------------------------------------------------
         // Test: toBuffer is too small.
         // ------------------------------------------------

         fromBuffer = 'The quick brown fox jumps over the lazy dog.';
         toBuffer   = '';

         hReader = MemoryReader_new(%addr(fromBuffer):%len(%trimR(fromBuffer)));
         hWriter = MemoryWriter_new(%addr(toBuffer  ): 17);

         dou (nRead = 0 or nRead = RC_ERROR);
            nRead = MemoryReader_read(hReader: %addr(tBuffer): %size(tBuffer));
            if (nRead > 0);
               nWrite = MemoryWriter_write(hWriter: %addr(tBuffer): nRead);
               select;
               when (nWrite = RC_ERROR);
                  errno = f_errno();
                  p_assert(errno = ENOBUFS_C
                           : 'errno does not match expected value: ENOBUFS');
                  leave;
               when (nWrite > 0);
                  p_assert(nRead = nWrite
                           : 'nRead (' + %char(nRead) +
                             ') does not match nWrite (' + %char(nWrite) + ')');
               endsl;
            endif;
         enddo;

         MemoryReader_delete(hReader);
         MemoryWriter_delete(hWriter);

         // ------------------------------------------------
         // Test: Bad handle: MemoryWriter
         // ------------------------------------------------
         f_clrErrno();
         nWrite = MemoryWriter_write(hWriter: %addr(tBuffer): nRead);
         p_assert(nWrite = RC_ERROR
                  : 'nWrite does not match expected value: RC_ERROR');
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');
         f_clrErrno();
         MemoryWriter_delete(hWriter);
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');

         f_clrErrno();
         hReader = MemoryReader_new(%addr(fromBuffer):%len(%trimR(fromBuffer)));
         f_clrErrno();
         nWrite = MemoryWriter_write(hReader: %addr(tBuffer): nRead);
         p_assert(nWrite = RC_ERROR
                  : 'nWrite does not match expected value: RC_ERROR');
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');
         f_clrErrno();
         MemoryReader_delete(hReader);

         // ------------------------------------------------
         // Test: Bad handle: MemoryReader
         // ------------------------------------------------
         f_clrErrno();
         nRead = MemoryReader_read(hReader: %addr(tBuffer): nRead);
         p_assert(nWrite = RC_ERROR
                  : 'nWrite does not match expected value: RC_ERROR');
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');
         f_clrErrno();
         MemoryReader_delete(hReader);
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');

         f_clrErrno();
         hWriter = MemoryWriter_new(%addr(fromBuffer):%len(%trimR(fromBuffer)));
         f_clrErrno();
         nRead = MemoryReader_read(hWriter: %addr(tBuffer): 10);
         p_assert(nRead = RC_ERROR
                  : 'nRead does not match expected value: RC_ERROR');
         p_assert(f_errno() = EBADF_C
                  : 'errno does not match expected value: EBADF');
         f_clrErrno();
         MemoryWriter_delete(hWriter);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R1_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R1_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_rtvMsgText/f_rtvMsgHelpText/f_newMsg      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R1_01) PARM('CPF9897' 'Hello World!' '0')    *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R1_01')
     D  gi_msgID                      7A   const
     D  gi_msgData                   32A   const
     D  gi_isMsgHelp                  1A   const
      *
     D main...
     D                 PR
     D  i_msgID                       7A   const
     D  i_msgData                    32A   const
     D  i_isMsgHelp                    N   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_msgID                      7A   const
     D  gi_msgData                   32A   const
     D  gi_isMsgHelp                  1A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_msgID: gi_msgData: gi_isMsgHelp);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_msgID                       7A   const
     D  i_msgData                    32A   const
     D  i_isMsgHelp                    N   const
      *
      *  Helper fields
     D msgText         S           1024A   varying            inz
     D rtvMsg          DS                  likeds(msg_t     ) inz
     D infoMsg         DS                  likeds(msg_t     ) inz
     D errMsg          DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create message to retrieve the text from
         rtvMsg = f_newMsg(i_msgID: i_msgData);

         // Retrieve message text, Ignore Errors
         infoMsg = f_newMsg('CPF9897': '*** Ignore Errors ***');
         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         msgText = f_rtvMsgText(rtvMsg: *omit);
         if   msgText <> '';
            infoMsg = f_newMsg('': 'MsgText: ' + msgText);
         else;
            infoMsg = f_newMsg(
                         '': 'Error occured on retrieveing message text!');
         endif;

         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         // Retrieve message help text, Ignore Errors
         msgText = f_rtvMsgHelpText(rtvMsg: '*NO': *omit);
         if   msgText <> '';
            infoMsg = f_newMsg('': 'MsgHelp: ' + msgText);
         else;
            infoMsg = f_newMsg(
                         '': 'Error occured on retrieveing message help text!');
         endif;

         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         // Retrieve message text, Return error information
         infoMsg = f_newMsg('CPF9897': '*** Return error information ***');
         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         msgText = f_rtvMsgText(rtvMsg: errMsg);
         if   msgText <> '';
            infoMsg = f_newMsg('': 'MsgText: ' + msgText);
         else;
            infoMsg = errMsg;
            infoMsg.type = cMsg_Info;
         endif;

         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         // Retrieve message help text, Return error information
         msgText = f_rtvMsgHelpText(rtvMsg: '*NO': errMsg);
         if   msgText <> '';
            infoMsg = f_newMsg('': 'MsgHelp: ' + msgText);
         else;
            infoMsg = errMsg;
            infoMsg.type = cMsg_Info;
         endif;

         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         // Send *ESCAPE message to signal error
         infoMsg = f_newMsg('CPF9897': '*** Send *ESCAPE message ***');
         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         if   not i_isMsgHelp;
            msgText = f_rtvMsgText(rtvMsg);
            infoMsg = f_newMsg('': 'MsgText: ' + msgText);
         else;
            msgText = f_rtvMsgHelpText(rtvMsg: '*NO');
            infoMsg = f_newMsg('': 'MsgHelp: ' + msgText);
         endif;

         f_sndPgmMsg(infoMsg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R1_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R1_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_newMsg/f_sndPgmMsg/f_rcvPgmMsg/f_rmvPgmMsg"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R1_02)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cFILE_CREATE    C                   const(1)
     D cFILE_REPLACE   C                   const(2)
     D cFILE_APPEND    C                   const(4)
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R1_02')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
     D rcvm0200        DS                  likeds(rcvm0200_t) inz
     D sndInf          DS                  likeds(sndInf_t  ) inz
      *
     D snd             DS                  qualified
     D  pgm                         256A   inz
     D  prc                         256A   inz
      *
     D msgKey          S              4A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create a message with no message ID, only message text
         msg = f_newMsg(cMSG_ID_NONE: '*** Using cMSG_ID_NONE ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         msg = f_newMsg(cMSG_ID_NONE: 'A message w/o a message ID');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Create a NULL message (which can not be sent)
         msg = f_newMsg(cMSG_ID_NONE: '*** Using cMSG_ID_NULL ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         msg = f_newMsg(cMSG_ID_NULL);
         monitor;
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         on-error;
            msg = f_newMsg(cMSG_ID_NONE:
                           'Error: A NULL message can not be sent.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endmon;

         // Create a OK message (which can not be sent)
         msg = f_newMsg(cMSG_ID_NONE: '*** Using cMSG_ID_OK ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         msg = f_newMsg(cMSG_ID_OK);
         monitor;
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         on-error;
            msg = f_newMsg(cMSG_ID_NONE:
                           'Error: A OK message can not be sent.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endmon;

         // Change the application message file to QTCPMSG
         // and send a test message TCP1A0A: &1 ended abnormally.
         msg = f_newMsg(cMSG_ID_NONE: '*** Changing message file ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         p_setAppMsgFile('QTCPMSG': 'QSYS');
         msg = f_newMsg('TCP1A0A': '*TEST_MSG *N  *N        ');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Now send a QCPFMSG
         msg = f_newMsg('CPF9897': 'Hello World! (QCPFMSG)': cMsg_Info:
                        'QCPFMSG': '*LIBL');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Set the application message file back to the default values
         p_setAppMsgFile();

         // Try to use the default message file
         msg = f_newMsg('CPF9897': 'Default message file is QCPFMSG.');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Send a message to the most previous call stack entry
         msg = f_newMsg(cMSG_ID_NONE: '*** Sending & receiving messages ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         msg = f_newMsg(cMSG_ID_NONE: 'Hi, how are you?');
         msgKey = f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToMyself);

         rcvm0200 = f_rcvPgmMsg(cMsg_Any: msgKey: cMsg_Act_Same: 0:
                                cMsg_Prv: cMsg_ToMyself);

         sndInf = f_getSndInfOfRcvMsg(rcvm0200: snd.pgm: snd.prc);

         msg = f_newMsg(cMSG_ID_NONE: 'Received: ' + %trimR(rcvm0200.value) +
                                      ' Answer: Thanks''s I am fine.');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Finally remove the message
         p_rmvPgmMsg(cMsg_Rmv_ByKey: msgKey: cMsg_Prv: cMsg_ToMyself);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R1_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R1_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_rcvPgmMsgObj                              "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R1_03)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R1_03')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D lib             S             10A   inz
     D msg             DS                  likeds(msg_t     ) inz
     D msgRcv          DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         lib = f_getObjLib('QCPFMSG': '*LIBL': '*MSGF');

         // Create a message, send it to myself and then receive it
         msg = f_newMsg('CPF9897': 'Hello World: ' + %char(%timestamp())
                        : cMsg_Info: 'QCPFMSG': lib);
         f_sndPgmMsg(msg: cMsg_Same: cMsg_ToMyself);
         msgRcv = f_rcvPgmMsgObj(cMsg_Last: *omit: cMsg_Act_Same: 0
                                 : cMsg_Same: cMsg_ToMyself);
         p_assert(msg.ID = msgRcv.ID
                  : 'msgRcv.ID und msg.ID drfen nicht voneinander abweichen');
         p_assert(msg.data = msgRcv.data
                  : 'msgRcv.data und msg.data drfen +
                     nicht voneinander abweichen');
         p_assert(msg.type = msgRcv.type
                  : 'msgRcv.type und msg.type drfen +
                     nicht voneinander abweichen');
         p_assert(msg.file = msgRcv.file
                  : 'msgRcv.file und msg.file drfen +
                     nicht voneinander abweichen');
         p_assert(msg.lib = msgRcv.lib
                  : 'msgRcv.lib und msg.lib drfen +
                     nicht voneinander abweichen');

         // Create a message, send it to 'previous' and then receive it
         msg = f_newMsg('CPF9897': 'Hello World: ' + %char(%timestamp())
                        : cMsg_Info: 'QCPFMSG': lib);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToMyself);
         msgRcv = f_rcvPgmMsgObj(cMsg_Last: *omit: cMsg_Act_Same: 0
                                 : cMsg_Prv: cMsg_ToMyself);
         p_assert(msg.ID = msgRcv.ID
                  : 'msgRcv.ID und msg.ID drfen nicht voneinander abweichen');
         p_assert(msg.data = msgRcv.data
                  : 'msgRcv.data und msg.data drfen +
                     nicht voneinander abweichen');
         p_assert(msg.type = msgRcv.type
                  : 'msgRcv.type und msg.type drfen +
                     nicht voneinander abweichen');
         p_assert(msg.file = msgRcv.file
                  : 'msgRcv.file und msg.file drfen +
                     nicht voneinander abweichen');
         p_assert(msg.lib = msgRcv.lib
                  : 'msgRcv.lib und msg.lib drfen +
                     nicht voneinander abweichen');

         // Create a message, send it to 'extern' and then receive it
         msg = f_newMsg('CPF9897': 'Hello World: ' + %char(%timestamp())
                        : cMsg_Info: 'QCPFMSG': lib);
         f_sndPgmMsg(msg: cMsg_Ext);
         msgRcv = f_rcvPgmMsgObj(cMsg_Last: *omit: cMsg_Act_Same: 0
                                 : cMsg_Ext);
         p_assert(msg.ID = msgRcv.ID
                  : 'msgRcv.ID und msg.ID drfen nicht voneinander abweichen');
         p_assert(msg.data = msgRcv.data
                  : 'msgRcv.data und msg.data drfen +
                     nicht voneinander abweichen');
         p_assert(msg.type = msgRcv.type
                  : 'msgRcv.type und msg.type drfen +
                     nicht voneinander abweichen');
         p_assert(msg.file = msgRcv.file
                  : 'msgRcv.file und msg.file drfen +
                     nicht voneinander abweichen');
         p_assert(msg.lib = msgRcv.lib
                  : 'msgRcv.lib und msg.lib drfen +
                     nicht voneinander abweichen');

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R2_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R2_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_errno/f_strerror/f_cvtErrnoToMsg          "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R2_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
     H BNDDIR('QC2LE')
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R2_01')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
     D fclose...
     D                 PR            10I 0        extproc('fclose')
     D  i_pStreamF                     *   value
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         fClose(*NULL);
         if   f_errno <> 0;
            msg = f_newMsg('CPF9897': f_strerror(f_errno));
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            msg = f_cvtErrnoToMsg(f_errno);
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_val                                       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_01) PARM('-123.456,789')                  *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_01')
     D  gi_strVal                    32A   const
      *
     D main...
     D                 PR
     D  i_strVal                     32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_strVal                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_strVal);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_strVal                     32A   const
      *
      *  Helper fields
     D numVal          S              8F                      inz
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         numVal = f_val('  $   1.605,25  ');
         msg = f_newMsg('': %editc(%dec(numVal: 20: 5): 'N'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numVal = f_val('-123,5');
         msg = f_newMsg('': %editc(%dec(numVal: 20: 5): 'N'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numVal = f_val('123,5-');
         msg = f_newMsg('': %editc(%dec(numVal: 20: 5): 'N'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numVal = f_val(i_strVal);
         msg = f_newMsg('': %editc(%dec(numVal: 30: 9): 'N'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_wordWrap                                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_02) PARM(65)                              *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_02')
     D  gi_width                     15P 5 const
      *
     D main...
     D                 PR
     D  i_width                      10I 0 const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_width                     15P 5 const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_width);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_width                      10I 0 const
      *
      *  Helper fields
     D theText         S            512A   varying inz('Test wordWrap():&N+
     D                                     ''The quick brown fox -
     D                                     jumps over the lazy dog.'' is a -
     D                                     sentence that includes every letter -
     D                                     of the alphabet.&PThat is why it is -
     D                                     often found as a sample sentence -
     D                                     within font managing software. Of -
     D                                     course I know that the text I am -
     D                                     writing is somewhat silly.&BHowever -
     D                                     the only purpose of the text is to -
     D                                     show how the wordWrap-function -
     D                                     works.')
     D aLine           S             80A   inz
     D startPos        S             10U 0 inz
     D numLine         S              3I 0 inz
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_width >= 1 and i_width <= 80:
                  'i_width is out of range. It must be between 1 and 80');

         // Perform word wrap without respect to end-of-paragraph markers:
         msg = f_newMsg('': '*** No EOP charcater: ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numLine  = 0;
         startPos = 1;
         dow   startPos > 0;
            numLine = numLine + 1;
            aLine = f_wordWrap(theText: i_width: startPos) + '<';
            msg = f_newMsg('': 'Line ' + %char(numLine) + ': ' + aLine);
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         enddo;

         // Perform word wrap with respect to end-of-paragraph markers
         // of message descriptions:
         msg = f_newMsg('': '*** EOP charcater of message description: ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numLine  = 0;
         startPos = 1;
         dow   startPos > 0;
            numLine = numLine + 1;
            aLine = f_wordWrap(theText: i_width: startPos:
                               cWORDWRAP_PARAGRAPH_MSGD) + '<';
            msg = f_newMsg('': 'Line ' + %char(numLine) + ': ' + aLine);
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         enddo;

         // Perform word wrap with respect to standard text
         // end-of-paragraph markers:
         theText = f_replace('&N': '\n': theText);
         theText = f_replace('&B': '\N': theText);
         theText = f_replace('&P': '\n': theText);

         msg = f_newMsg('': '*** Standard text EOP charcaters: ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         numLine  = 0;
         startPos = 1;
         dow   startPos > 0;
            numLine = numLine + 1;
            aLine = f_wordWrap(theText: i_width: startPos:
                               cWORDWRAP_PARAGRAPH_TEXT) + '<';
            msg = f_newMsg('': 'Line ' + %char(numLine) + ': ' + aLine);
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         enddo;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_left/f_right/f_space                      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_03) PARM('Hello World!')                  *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_03')
     D  gi_text                      32A   const
      *
     D main...
     D                 PR
     D  i_text                       32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_text                      32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_text);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_text                       32A   const
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t      ) inz
     D aString         S            128A   inz varying
     D leftLen         S             10I 0 inz
     D rightLen        S             10I 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         aString = f_space(5) + %trim(i_text) + f_space(5);
         msg = f_newMsg('': aString + '<');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         aString = f_space(5: '*') + %trim(i_text) + f_space(5: '*');
         msg = f_newMsg('': aString + '<');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         aString = f_space(5: '%') + %trim(i_text) + f_space(5: '%');
         msg = f_newMsg('': aString + '<');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         aString = f_space(5: '-') + %trim(i_text) + f_space(5: '-');
         leftLen  = %int(%len(aString) / 2);
         rightLen = %len(aString) - leftLen;

         msg = f_newMsg('': f_left(aString: leftLen) + '<');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         msg = f_newMsg('': f_right(aString: rightLen) + '<');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_04  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_04"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_replace                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_04) PARM('CR+LF')                         *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_04')
     D  gi_rplStr                    32A   const
      *
     D main...
     D                 PR
     D  i_rplStr                     32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_rplStr                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_rplStr);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_rplStr                     32A   const
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t      ) inz
     D msgText         S           1024A   varying            inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Retrieve a message and replace &N with i_rplStr.
         msg = f_newMsg('CAE0009');
         msgText = f_rtvMsgHelpText(msg: cMsg_RtnCtrlChar_Yes: *omit);

         msgText = f_replace('&N': %trimR(i_rplStr): msgText);

         // Show the text with the replacements.
         msg = f_newMsg(cMSG_ID_NONE: msgText);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_05  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_05"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_lcase/f_ucase                             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_05) PARM('Hello World! ')           *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_05')
     D  gi_string                    32A   const
      *
     D main...
     D                 PR
     D  i_string                     32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_string                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_string);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_string                     32A   const
      *
      *  Helper fields
     D string          S             32A   varying inz
     D msg             DS                  likeds(msg_t      ) inz
     D msgText         S           1024A   varying            inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Convert i_string to lower case.
         msg = f_newMsg('CPF9897': 'Lower string is: ' + f_lcase(i_string));

         // Show converted string
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Convert i_string to upper case.
         msg = f_newMsg('CPF9897': 'Upper string is: ' + f_ucase(i_string));

         // Show converted string
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_06  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_06"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_getLengthEditCode/f_getLengthEditWord     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_06)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_06')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D digits          S              5U 0 inz
     D fraction        S              5U 0 inz
     D length          S              5U 0 inz
     D editCode        S              1A   inz
     D editWord        S             32A   inz varying
     D fmtString       S             64A   inz varying
     D num64           S              6S 4 inz(*LOVAL)
     D num74           S              7S 4 inz(*LOVAL)
     D num84           S              8S 4 inz(*LOVAL)
     D num94           S              9S 4 inz(*HIVAL)
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Test a numeric 6,4 variable with edit code 'B'
         digits    = %len(num64);
         fraction  = %decpos(num64);
         editCode  = 'B';
         length    = f_getLengthEditCode(digits: fraction: editCode);
         fmtString = %editc(num64: 'B');

         p_assert(length = %len(fmtString));

         msg = f_newMsg(cMSG_ID_NONE: 'Length of edit code ''' + editCode +
                        ''' is: ' + %editc(length: 'Z') +
                        ' (' + fmtString + ')');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Test a numeric 7,4 variable with edit code 'L'
         digits    = %len(num74);
         fraction  = %decpos(num74);
         editCode  = 'L';
         length    = f_getLengthEditCode(digits: fraction: editCode);
         fmtString = %editc(num74: 'L');

         p_assert(length = %len(fmtString));

         msg = f_newMsg(cMSG_ID_NONE: 'Length of edit code ''' + editCode +
                        ''' is: ' + %editc(length: 'Z') +
                        ' (' + fmtString + ')');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Test a numeric 8,4 variable with edit code 'X' (negative value)
         digits    = %len(num84);
         fraction  = %decpos(num84);
         editCode  = 'X';
         length    = f_getLengthEditCode(digits: fraction: editCode);
         fmtString = %editc(num84: 'X');

         p_assert(length = %len(fmtString));

         msg = f_newMsg(cMSG_ID_NONE: 'Length of edit code ''' + editCode +
                        ''' is: ' + %editc(length: 'Z') +
                        ' (' + fmtString + ')');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Test a numeric 9,4 variable with edit code 'X' (positive value)
         digits    = %len(num94);
         fraction  = %decpos(num94);
         editCode  = 'X';
         length    = f_getLengthEditCode(digits: fraction: editCode);
         fmtString = %editc(num94: 'X');

         p_assert(length = %len(fmtString));

         msg = f_newMsg(cMSG_ID_NONE: 'Length of edit code ''' + editCode +
                        ''' is: ' + %editc(length: 'Z') +
                        ' (' + fmtString + ')');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Test a numeric 7,4 variable with edit word ' -  /    '
         digits    = %len(num74);
         fraction  = 0;
         editWord  = ' -  /    ';
         length    = f_getLengthEditWord(digits: editWord);
         fmtString = %editw(num74: ' -  /    ');

         p_assert(length = %len(fmtString));

         msg = f_newMsg(cMSG_ID_NONE: 'Length of edit word ''' + editWord +
                        ''' is: ' + %editc(length: 'Z') +
                        ' (' + fmtString + ')');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_07  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_07"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_rmvKeyword                                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_07)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_07')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D string          S            128A   inz   varying
     D kwdValue        S            128A   inz   varying
     D cCMD            C                   const('PGM(*LIBL/QCMDEXC')
     D cKEYWORD_PGM    C                   const('PGM')
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         string   = cCMD;
         kwdValue = f_rmvKeyword(cKEYWORD_PGM: string);

         msg = f_newMsg(cMSG_ID_NONE: 'The value of ' + cKEYWORD_PGM +
                        ' is: ' + kwdValue);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_08  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_08"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_center/f_alignR                           "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_08)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_08')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D string          S            128A   inz   varying
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Center a literal into a string
         string = f_space(40);
         string = '>' + f_center('Hello World': %len(string)) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Centered (literal)  : ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Center a given string
         string = 'Hello World' + f_space(29);   // = 40 characters
         string = '>' + f_center(string) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Centered (string)   : ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Center a given string, target too small
         string = f_space(5);
         string = '>' + f_center('Hello World': %len(string)) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Centered (too small): ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Right align a literal into a string
         string = f_space(40);
         string = '>' + f_alignR('Hello World': %len(string)) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Aligned  (literal)  : ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Right align a given string
         string = 'Hello World' + f_space(29);   // = 40 characters
         string = '>' + f_alignR(string) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Aligned  (string)   : ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Right align a given string, target too small
         string = f_space(5);
         string = '>' + f_alignR('Hello World': %len(string)) + '<';
         msg = f_newMsg(cMSG_ID_NONE: 'Aligned  (too small): ' + string);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_09  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_09"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genStrCmp/f_genStrCmpIgnCase              "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_09)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_09')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D isEqual         S               N   inz
     D string          S            128A   inz   varying
     D mask            S            128A   inz   varying
     D wildcard        S              2A   inz
     D procedure       S             20A   inz   varying
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // ------------------------------------------------
         // Compare strings without using wildcards
         // ------------------------------------------------
         string = 'Hello World';
         mask   = 'hello world';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         string = 'Hello World';
         mask   = 'hello world';
         isEqual = f_genStrCmpIgnCase(string: mask);
         procedure = 'f_genStrCmpIgnCase';
         exsr sndMsg;
         p_assert(isEqual);

         // ------------------------------------------------
         // Compare strings, using asterisk
         // ------------------------------------------------
         string = 'Hello World';
         mask   = 'Hello*';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = '*World';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = '*llo Worl*';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = 'He*ld';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         // ------------------------------------------------
         // Compare strings using question mark
         // ------------------------------------------------
         string = 'Hello World';
         mask   = 'Hello ?o?ld';   // That is equal to 'Hello World' ...
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = 'Hello ?o?ld?';  // ... but that is not equal to 'Hello World'
                                   //     since the mask expects another character
                                   //     right after 'World'.
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         string = 'Hello World';
         mask   = '?Hello ?o?ld';  // ... That is also not equal to 'Hello World'
                                   //     since the mask expects a character just
                                   //     before 'Hello'.
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         string = 'Hello World';
         mask   = '*Hello ?o?ld';  // ... However that is equal to 'Hello World'
                                   //     since the asterisk stands for any or
                                   //     none character.
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = 'Hello ?o?ld*';  // ... However that is also equal to 'Hello World'
                                   //     since the asterisk stands for any or
                                   //     none character.
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         // ------------------------------------------------
         // Compare strings: mask is longer than string
         // ------------------------------------------------
         string = 'Hello World';
         mask   = 'Hello World!';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         // ------------------------------------------------
         // Compare strings: string is longer than mask
         // ------------------------------------------------
         string = 'Hello World!';
         mask   = 'Hello World';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         // ------------------------------------------------
         // Now using different wildcard characters
         // Use % instead of *
         // Use _ instead of ?
         // ------------------------------------------------
         string = 'Hello World';
         mask   = '%ello Worl%';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         string = 'Hello World';
         mask   = 'Hello _or_d';
         isEqual = f_genStrCmp(string: mask);
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(not isEqual);

         // Once the different wildcard characters are passed
         // to f_genStrCmp, the strings are equal:
         string = 'Hello World';
         mask   = '%ello Worl%';
         isEqual = f_genStrCmp(string: mask: '%_');
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         string = 'Hello World';
         mask   = 'Hello _or_d';
         isEqual = f_genStrCmp(string: mask: '%_');
         procedure = 'f_genStrCmp';
         exsr sndMsg;
         p_assert(isEqual);

         // ------------------------------------------------
         // Test cases added with v1.12
         // ------------------------------------------------
         // Generic mask with asterisks and
         // multiple 'a' (first char in mask) in i_string.
         string = 'tagesAbgangSchnittstelle200904161547580098.xml';
         mask   = '*abg*';
         isEqual = f_genStrCmpIgnCase(string: mask);
         procedure = 'f_genStrCmpIgnCase';
         exsr sndMsg;
         p_assert(isEqual);

         // Multiple dots
         string = '2009-06-24-13.54.25.112000__urn_uuid_+
                   C9187B2F662BE0D2881245844464833__.png';
         mask   = '*.png';
         isEqual = f_genStrCmpIgnCase(string: mask);
         procedure = 'f_genStrCmpIgnCase';
         exsr sndMsg;
         p_assert(isEqual);

         return;

         begsr sndMsg;

         if isEqual;
            msg = f_newMsg(cMsg_ID_NONE: procedure + ': ' +
                     '''' + string + ''' and ''' + mask + ''' are equal.');
         else;
            msg = f_newMsg(cMsg_ID_NONE: procedure + ': ' +
                     '''' + string + ''' and ''' + mask + ''' are not equal.');
         endif;

         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         endsr;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_10  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_10"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_scanR                                     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_09)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_09')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D isEqual         S               N   inz
     D text            C                   const('+
     D                                     A spaceman came travelling on his +
     D                                     ship from afar, +
     D                                     ''twas light years of time since +
     D                                     his mission did start, +
     D                                     And over a village he halted his +
     D                                     craft, +
     D                                     And it hung in the sky like a +
     D                                     star, just like a star...')
     D searchArg       S            256A   inz   varying
     D searchText      S             32A   inz   varying
     D startPos        S             10I 0 inz
     D position        S             10I 0 inz
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg(cMsg_ID_NONE: text);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         startPos  = %len(text);
         searchArg = 'star';
         position  = f_scanR(searchArg: text);
         exsr sndMsg;

         startPos  = 190;
         searchArg = 'star';
         position  = f_scanR(searchArg: text: startPos);
         exsr sndMsg;

         startPos  = 170;
         searchArg = 'star';
         position  = f_scanR(searchArg: text: startPos);
         exsr sndMsg;

         startPos  = 90;
         searchArg = 'star';
         position  = f_scanR(searchArg: text: startPos);
         exsr sndMsg;

         startPos  = %len(text);
         searchArg = text;
         position  = f_scanR(searchArg: text: startPos);
         exsr sndMsg;

         msg = f_newMsg(cMsg_ID_NONE: '- Search argument longer than text: -');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         startPos  = %len(text);
         searchArg = text + ' an extension';
         position  = f_scanR(searchArg: text: startPos);
         exsr sndMsg;

         return;

         begsr sndMsg;

         if %len(searchArg) > 10;
            searchText = %subst(searchArg: 1: 10) + ' ...';
         else;
            searchText = searchArg;
         endif;

         if position = 0;
            msg = f_newMsg(cMsg_ID_NONE: 'Search argument ''' +
                           searchText +
                           ''' was not found before position ' +
                           %char(startPos) + '.');
         else;
            msg = f_newMsg(cMsg_ID_NONE: 'Search argument ''' +
                                         searchText +
                                         ''' found at position ' +
                                         %char(position) + '. ' +
                                         'Start position: ' + %char(startPos));
         endif;

         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         endsr;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_11  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_11"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_cvtBufferToHexString/f_cvtHexStringToBuffe"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_11) PARM(x'C88593939640E696999384')       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_11')
     D  gi_buffer                    32A   const
      *
     D main...
     D                 PR
     D  i_buffer                     32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_buffer                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_buffer);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_buffer                     32A   const
      *
      *  Helper fields
     D size            S              5I 0                inz
     D buffer          S                   like(i_buffer) inz
     D string          S             64A   varying        inz
     D msgText         S            128A                  inz
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Convert a buffer to a hex string.
         buffer = i_buffer;
         size   = %len(%trimR(buffer));
         string = f_cvtBufferToHexString(%addr(buffer): size);

         msgText = 'Buffer: ''' + %trimR(buffer) + '''' +
                   ' ==> Hex-String: ''' + string + '''';
         msg = f_newMsg(cMsg_ID_NONE: msgText);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Convert a string of hex values to a buffer
         string = 'C140A297818385948195408381948540A39981A5859393899587';
         size = f_cvtHexStringToBuffer(string: %addr(buffer): %size(buffer));

         msgText = 'Hex-String: ''' + string + '''' +
                   ' ==> Buffer: ''' + %subst(buffer: 1: size) + '''';
         msg = f_newMsg(cMsg_ID_NONE: msgText);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_12  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_12"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_objName                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_12) PARM('SYSPROCS' 'QSYS2')              *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_12')
     D  gi_name                      10A   const  options(*nopass)
     D  gi_lib                       10A   const  options(*nopass)
      *
     D main...
     D                 PR
     D  i_name                       10A   const
     D  i_lib                        10A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_name                      10A   const  options(*nopass)
     D  gi_lib                       10A   const  options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= 2);
            main(gi_name: gi_lib);
         else;
            main('SYSPROCS': 'QSYS2');
         endif;

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_name                       10A   const
     D  i_lib                        10A   const
      *
      *  Helper fields
     D objName         S             21A   inz
     D qObj            DS                  likeds(qObj_t) inz
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         qObj.name = i_name;
         qObj.lib  = i_lib;
         objName = f_objname(qObj);

         p_assert(objName = %trimR(i_lib) + '/' + %trimR(i_name)
                  : 'Fehler in Funktion f_objName()');

         msg = f_newMsg(cMsg_ID_NONE: 'Qualified object name 1 is: ' + objName);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         objName = f_objname(i_name: i_lib);

         p_assert(objName = %trimR(i_lib) + '/' + %trimR(i_name)
                  : 'Fehler in Funktion f_objName()');

         msg = f_newMsg(cMsg_ID_NONE: 'Qualified object name 2 is: ' + objName);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_13  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_13"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_parseDate / f_formatDate                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_13)                                       *
      *         PARM('2009-01-23' 'YYYY-MM-DD' 'ZD Mmmmmmmmmz YYYY')  *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_13')
     D  gi_date_str                  32A   const  options(*nopass)
     D  gi_pic_str                   32A   const  options(*nopass)
     D  gi_fmt_str                   32A   const  options(*nopass)
      *
     D main...
     D                 PR
     D  i_date_str                   32A   const  varying
     D  i_pic_str                    32A   const  varying
     D  i_fmt_str                    32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_date_str                  32A   const  options(*nopass)
     D  gi_pic_str                   32A   const  options(*nopass)
     D  gi_fmt_str                   32A   const  options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= 3);
            main(%trim(gi_date_str): %trim(gi_pic_str): %trim(gi_fmt_str));
         else;
            main(%char(%date(): *ISO): 'YYYY-MM-DD': 'ZD. Mmmmmmmmmz YYYY');
         endif;

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_date_str                   32A   const  varying
     D  i_pic_str                    32A   const  varying
     D  i_fmt_str                    32A   const  varying
      *
      *  Helper fields
     D date            S               D   inz
     D date_str        S             64A   inz varying
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         date = f_parseDate(i_date_str: i_pic_str);

         date_str = f_formatDate(date: i_fmt_str);

         msg = f_newMsg(cMsg_ID_NONE: 'Converted ' + f_addQuotes(i_date_str) +
                        ' to date ' + %char(date: *EUR) + ' and string: ' +
                        date_str);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R3_14  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R3_14"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_formatMemSize                             "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R3_14)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R3_14')
      *
     D main...
     D                 PR
      *
     D displayMemSize...
     D                 PR
     D  i_memSize                    20I 0 value
     D  i_unit                        2A   value  options(*nopass)
     D  i_decPos                     10I 0 value  options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Display result.
      *===============================================================*
     P displayMemSize...
     P                 B
      *
     D displayMemSize...
     D                 PI
     D  i_memSize                    20I 0 value
     D  i_unit                        2A   value  options(*nopass)
     D  i_decPos                     10I 0 value  options(*nopass)
      *
      *  Helper fields
     D memSize         S                   like(i_memSize) inz
     D unit            S                   like(i_unit   ) inz
     D decPos          S                   like(i_decPos ) inz
     D msgText         S            128A   varying inz
     D formatted       S             64A   varying inz
     D msg             DS                  likeds(msg_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= 2);
            unit = i_unit;
         else;
            unit = '';
         endif;

         if (%parms() >= 3);
            decPos = i_decPos;
         else;
            decPos = 7;
         endif;

         if (%rem(i_memSize: 1024) <> 0);
            memSize = i_memSize * 1.3;
         else;
            memSize = i_memSize;
         endif;

         msgText = %editc(memSize: 'Z') + ' Bytes = ' +
                   f_formatMemSize(memSize: unit: decPos) + ' ' + unit;

         msg = f_newMsg(cMsg_ID_NONE: msgText);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P displayMemSize...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         displayMemSize(1024);
         displayMemSize((1024**1) + 1);

         displayMemSize(1024**2);
         displayMemSize((1024**2) + 1);

         displayMemSize(600: '': 7);
         displayMemSize(600: cMEM_SIZE_KILO_BYTE: 7);

         displayMemSize(60000000: '': 7);
         displayMemSize(60000000: cMEM_SIZE_KILO_BYTE: 7);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R4_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R4_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: p_assert/f_this/f_caller                    "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R4_01) PARM('1')                             *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R4_01')
     D  gi_boolean                    1A   const
      *
     D main...
     D                 PR
     D  i_boolean                      N   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_boolean                    1A   const
      *
      *  Local helper fields
     D msg             DS                  likeds(msg_t     ) inz
     D procedure       S            256A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         procedure = f_this();
         msg = f_newMsg(cMSG_ID_NONE: '=> ' + '*N/'
                                            + '*N' + '.'
                                            + %trimR(procedure));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         main(gi_boolean);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_boolean                      N   const
      *
      *  Local helper fields
     D msg             DS                  likeds(msg_t     ) inz
     D procedure       S            256A   inz
     D module          S             10A   inz
     D program         S             10A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         procedure = f_this();
         msg = f_newMsg(cMSG_ID_NONE: '=> ' + '*N/'
                                            + '*N' + '.'
                                            + %trimR(procedure));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         procedure = f_this(module);
         msg = f_newMsg(cMSG_ID_NONE: '=> ' + '*N/'
                                            + %trimR(module) + '.'
                                            + %trimR(procedure));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         procedure = f_this(module: program);
         msg = f_newMsg(cMSG_ID_NONE: '=> ' + %trimR(program) + '/'
                                            + %trimR(module) + '.'
                                            + %trimR(procedure));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         procedure = f_caller(module: program);
         msg = f_newMsg(cMSG_ID_NONE: '=> ' + %trimR(program) + '/'
                                            + %trimR(module) + '.'
                                            + %trimR(procedure));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         p_assert(i_boolean                        :                                        //RADDAT
                  'Error detected by p_assert()'   );

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R5_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R5_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_exist  (object)                           "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R5_01) PARM('CHKOB' 'QSYS' '*CMD')           *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R5_01')
     D  gi_obj                       10A   const
     D  gi_lib                       10A   const
     D  gi_type                      10A   const
      *
     D main...
     D                 PR
     D  i_obj                              const  like(gi_obj    )
     D  i_lib                              const  like(gi_lib    )
     D  i_type                             const  like(gi_type   )
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_obj                       10A   const
     D  gi_lib                       10A   const
     D  gi_type                      10A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_obj: gi_lib: gi_type);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_obj                              const  like(gi_obj    )
     D  i_lib                              const  like(gi_lib    )
     D  i_type                             const  like(gi_type   )
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   not f_exist(i_lib: *omit: '*LIB');
            msg = f_newMsg('CPF9898': 'Library ' + %trim(i_lib)
                                      + ' does not exist');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         else;
            if   not f_exist(i_obj: i_lib: i_type);
               msg = f_newMsg('CPF9898': 'Object ' + %trim(i_lib) + '/'
                                         + %trim(i_obj) + ' (' + %trim(i_type)
                                         + ') does not exist');
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            else;
               msg = f_newMsg('CPF9897': 'Done');
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            endif;
         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R5_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R5_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_exist  (member)                           "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *  CALL PGM(TEST_R5_02) PARM('QRPGSRC' 'QGPL' '*FILE' '*FIRST') *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R5_02')
     D  gi_file                      10A   const
     D  gi_lib                       10A   const
     D  gi_mbr                       10A   const
      *
     D main...
     D                 PR
     D  i_file                             const  like(gi_file   )
     D  i_lib                              const  like(gi_lib    )
     D  i_mbr                              const  like(gi_mbr    )
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_file                      10A   const
     D  gi_lib                       10A   const
     D  gi_mbr                       10A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_file: gi_lib: gi_mbr);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_file                             const  like(gi_file   )
     D  i_lib                              const  like(gi_lib    )
     D  i_mbr                              const  like(gi_mbr    )
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if   not f_exist(i_lib: *omit: '*LIB');
            msg = f_newMsg('CPF9898': 'Library ' + %trim(i_lib)
                                      + ' does not exist');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         else;
            if   not f_exist(i_file: i_lib: '*FILE': i_mbr);
               msg = f_newMsg('CPF9898': 'Member ' + %trim(i_lib) + '/'
                                         + %trim(i_file) + ' (' + %trim(i_mbr)
                                         + ') does not exist');
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            else;
               msg = f_newMsg('CPF9897': 'Done');
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            endif;
         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R5_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R5_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_getTmpName/f_getUniqueName                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *  CALL PGM(TEST_R5_03)                                         *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R5_03')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D qTmpObj         DS                  likeds(qObj_t    ) inz
     D qUnqObj         DS                  likeds(qObj_t    ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         qTmpObj = f_getTmpName();
         msg = f_newMsg('CPF9898': 'Temporary object name is: ' +
                         %trim(qTmpObj.lib) + '/' + %trim(qTmpObj.name));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         qUnqObj = f_getUniqueName('*FILE': 'QGPL');
         msg = f_newMsg('CPF9898': 'Unique object name is: ' +
                         %trim(qUnqObj.lib) + '/' + %trim(qUnqObj.name));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R5_04  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R5_04"
mbrtype =  "RPGLE     "
mbrtext =  "Test: user space procedures                       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *  CALL PGM(TEST_R5_04)                                         *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R5_04')
      *
     D main...
     D                 PR
      *
      *  Returns the user space size choosen by the i5/OS based on
      *  an given size.
     D OS_getUsrSpcSize...
     D                 PR            10I 0
     D i_size                        10I 0 const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Returns the user space size choosen by the i5/OS based on
      *  an given size.
      *===============================================================*
     P OS_getUsrSpcSize...
     P                 B
      *
     D OS_getUsrSpcSize...
     D                 PI            10I 0
     D i_size                        10I 0 const
      *
      *  Return value
     D size            S             10I 0 inz
      *
      *  Disk page size
     D cPAGE_SIZE      C                   4096
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         size = %int(i_size / cPAGE_SIZE) * cPAGE_SIZE;

         if (size <> i_size);
            size = size + cPAGE_SIZE;
         endif;

         size = size - 512;   // User space administration attributes

         return size;

      /END-FREE
      *
     P OS_getUsrSpcSize...
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D size            S             10I 0 inz
     D isAutoExt       S               N   inz
     D initValue       S              1A   inz
     D qUsrSpc         DS                  likeds(qObj_t    ) inz
     D msg             DS                  likeds(msg_t     ) inz
     D tmpMsg          DS                  likeds(msg_t     ) inz
      *
     D cDEFAULT_SIZE   C                   512
     D cBIG_SIZE       C                   7200
     D cDEFAULT_AUTO_EXT...
     D                 C                   '0'
     D cDEFAULT_INIT_VALUE...
     D                 S              1A   inz(x'00')
     D cNEW_INIT_VALUE...
     D                 S              1A   inz('X')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         msg = f_newMsg(cMSG_ID_OK);

         qUsrSpc = f_getTmpName();

         dou '1';

            // create user space
            if (not f_crtUsrSpc(qUsrSpc.name: qUsrSpc.lib
                                : 'Test BASICS1: user space'
                                : cDEFAULT_SIZE
                                : 'TEST'
                                : '*USE'
                                : msg));
               leave;
            endif;

            // check user space size
            size = f_getUsrSpcSize(qUsrSpc.name: qUsrSpc.lib: msg);
            if (size < 0);
               leave;
            endif;

            if (size <> OS_getUsrSpcSize(cDEFAULT_SIZE));
               msg = f_newMsg('CPF9898': 'User space size ' + %char(size) +
                              ' does not match expected value ' +
                              %char(OS_getUsrSpcSize(cDEFAULT_SIZE)));
               leave;
            endif;

            // change user space size
            size = f_chgUsrSpcSize(qUsrSpc.name: qUsrSpc.lib: cBIG_SIZE: msg);
            if (size < 0);
               leave;
            endif;

            // check new user space size which was returned by f_chgUsrSpcSize()
            if (size <> OS_getUsrSpcSize(cBIG_SIZE));
               msg = f_newMsg('CPF9898': 'User space size ' + %char(size) +
                              ' does not match expected value ' +
                              %char(OS_getUsrSpcSize(cDEFAULT_SIZE)));
               leave;
            endif;

            // check user space automatic extendibility attribute
            isAutoExt = f_getUsrSpcAutoExt(qUsrSpc.name: qUsrSpc.lib: msg);
            if (msg.ID <> cMSG_ID_OK);
               leave;
            endif;

            if (isAutoExt <> cDEFAULT_AUTO_EXT);
               msg = f_newMsg('CPF9898'
                              : 'User space automatic extendibility ''' +
                                isAutoExt +
                                ''' does not match expected value ' +
                                cDEFAULT_AUTO_EXT);
               leave;
            endif;

            // change user space automatic extendibility
            isAutoExt = f_chgUsrSpcAutoExt(qUsrSpc.name: qUsrSpc.lib
                                           : not cDEFAULT_AUTO_EXT: msg);

            // check new user space automatic extendibility which
            // was returned by f_chgUsrSpcAutoExt()
            if (isAutoExt <> not cDEFAULT_AUTO_EXT);
               msg = f_newMsg('CPF9898'
                              : 'User space automatic extendibility ''' +
                                 isAutoExt +
                                 ''' does not match expected value ''' +
                                 not cDEFAULT_AUTO_EXT + '''');
               leave;
            endif;

            // check user space initial value
            initValue = f_getUsrSpcInitValue(qUsrSpc.name: qUsrSpc.lib: msg);
            if (msg.ID <> cMSG_ID_OK);
               leave;
            endif;

            if (initValue <> cDEFAULT_INIT_VALUE);
               msg = f_newMsg('CPF9898'
                    : 'User space initial value x''' +
                      f_cvtBufferToHexString(%addr(initValue): 1) +
                      ''' does not match expected value x''' +
                      f_cvtBufferToHexString(%addr(cDEFAULT_INIT_VALUE): 1) +
                      '''');
               leave;
            endif;

            // change user space initial value
            initValue = f_chgUsrSpcInitValue(qUsrSpc.name: qUsrSpc.lib
                                             : cNEW_INIT_VALUE: msg);

            // check new user space initual value which
            // was returned by f_chgUsrSpcInitValue()
            if (initValue <> cNEW_INIT_VALUE);
               msg = f_newMsg('CPF9898'
                        : 'User space initial value x''' +
                          f_cvtBufferToHexString(%addr(initValue): 1) +
                          ''' does not match expected value x''' +
                          f_cvtBufferToHexString(%addr(cNEW_INIT_VALUE): 1) +
                          '''');
               leave;
            endif;

         enddo;

            // delete user space
         if (f_exist(qUsrSpc.name: qUsrSpc.lib: '*USRSPC'));
            if (not f_dltUsrSpc(qUsrSpc.name: qUsrSpc.lib: tmpMsg));
               tmpMsg.ID = cMSG_DIAG;
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            endif;
         endif;

         if (msg.ID <> cMSG_ID_OK);
            msg.type = cMSG_ESCAPE;
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R5_05  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R5_05"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_cvtQSYSObjNameToPath/f_cvtPathToQSYSObjNam"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *  CALL PGM(TEST_R5_05)                                         *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R5_05')
      *
     D main...
     D                 PR
      *
     D kill...
     D                 PR                         extproc('kill')
     D  i_text                      128A   value  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Kills the program.
      *===============================================================*
     P kill...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';

         clear errCode;
         errCode.bytPrv = %size(errCode);

         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*ESCAPE'
                  : '*CTLBDY': 1
                  : msgKey: errCode);

         return;

      /END-FREE
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D qQSYSObj        ds                  likeds(qQSYSObj_t) inz
     D qFile           ds                  likeds(qFile_t) inz
     D qObj            ds                  likeds(qObj_t) inz
     D qQSYSObj2       ds                  likeds(qQSYSObj_t) inz
     D library         s             10a
     D object          s             10a
     D member          s             10a
     D path            s           5000a   varying
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         qQSYSObj.name = 'QBASICS1';
         qQSYSObj.lib = 'QGPL';
         qQSYSObj.mbr = 'PBASICS1';
         qQSYSObj.type = '*FILE';

         path = f_cvtQSYSObjNameToPath(qQSYSObj);
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.FILE/PBASICS1.MBR');
            kill('Error with qQSYSObj (*FILE)');
         endif;

         qQSYSObj.name = 'QMHSNDPM';
         qQSYSObj.lib = 'QSYS';
         qQSYSObj.mbr = '';
         qQSYSObj.type = '*PGM';

         path = f_cvtQSYSObjNameToPath(qQSYSObj);
         if (path <> '/QSYS.LIB/QMHSNDPM.PGM');
            kill('Error with qQSYSObj (*PGM)');
         endif;

         qQSYSObj.name = 'BASICS1';
         qQSYSObj.lib = 'UBMSYS';
         qQSYSObj.mbr = '';
         qQSYSObj.type = '*SRVPGM';

         path = f_cvtQSYSObjNameToPath(qQSYSObj);
         if (path <> '/QSYS.LIB/UBMSYS.LIB/BASICS1.SRVPGM');
            kill('Error with qQSYSObj (*SRVPGM)');
         endif;

         qFile.name = 'QBASICS1';
         qFile.lib = 'QGPL';
         qFile.mbr = 'PBASICS1';

         qObj.name = 'QBASICS1';
         qObj.lib = 'QGPL';

         object = 'QBASICS1';
         library = 'QGPL';
         member = 'PBASICS1';

         path = f_cvtQSYSObjNameToPath(qFile);
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.FILE/PBASICS1.MBR');
            kill('Error with qFile');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> object or
             qQSYSObj2.lib <> library or
             qQSYSObj2.mbr <> member or
             qQSYSObj2.type <> '*FILE');
            kill('Error with qQSYSObj2 from qFile');
         endif;

         path = f_cvtQSYSObjNameToPath(qFile: '*FILE');
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.FILE/PBASICS1.MBR');
            kill('Error with qFile and object type *FILE');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> object or
             qQSYSObj2.lib <> library or
             qQSYSObj2.mbr <> member or
             qQSYSObj2.type <> '*FILE');
            kill('Error with qQSYSObj2 from qFile');
         endif;

         monitor;
            path = f_cvtQSYSObjNameToPath(qFile: '*PGM');
            kill('Error with qFile and object type *PGM');
         on-error;
            // Exception seen
         endmon;

         path = f_cvtQSYSObjNameToPath(qObj: '*DTAARA');
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.DTAARA');
            kill('Error with qObj and object type *DTAARA');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> object or
             qQSYSObj2.lib <> library or
             qQSYSObj2.mbr <> '' or
             qQSYSObj2.type <> '*DTAARA');
            kill('Error with qQSYSObj2 from qObj and object type *DTAARA');
         endif;

         path = f_cvtQSYSObjNameToPath(library: '*LIB');
         if (path <> '/QSYS.LIB/QGPL.LIB');
            kill('Error with library and object type *LIB');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> library or
             qQSYSObj2.lib <> '' or
             qQSYSObj2.mbr <> '' or
             qQSYSObj2.type <> '*LIB');
            kill('Error with qQSYSObj2 from library and object type *LIB');
         endif;

         path = f_cvtQSYSObjNameToPath(object: '*OUTQ');
         if (path <> '/QSYS.LIB/%LIBL%.LIB/QBASICS1.OUTQ');
            kill('Error with object and object type *OUTQ');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> object or
             qQSYSObj2.lib <> '*LIBL' or
             qQSYSObj2.mbr <> '' or
             qQSYSObj2.type <> '*OUTQ');
            kill('Error with qQSYSObj2 from object and object type *OUTQ');
         endif;

         path = f_cvtQSYSObjNameToPath(object: library: '*MSGQ');
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.MSGQ');
            kill('Error with object/library and object type *MSGQ');
         endif;

         qQSYSObj2 = f_cvtPathToQSYSObjName(path);
         if (qQSYSObj2.name <> object or
             qQSYSObj2.lib <> library or
             qQSYSObj2.mbr <> '' or
             qQSYSObj2.type <> '*MSGQ');
            kill('Error with qQSYSObj2 from object, library and +
                  object type *MSGQ');
         endif;

         path = f_cvtQSYSObjNameToPath(object: library: member: '*FILE');
         if (path <> '/QSYS.LIB/QGPL.LIB/QBASICS1.FILE/PBASICS1.MBR');
            kill('Error with object/library/member and object type *FILE');
         endif;

         monitor;
            path = f_cvtQSYSObjNameToPath(object: library: member: '*PGM');
            kill('Error with qFile and object type *PGM');
         on-error;
            // Exception seen
         endmon;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R6_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R6_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_execute                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R6_01) PARM('CHKOBJ QSY *LIB')               *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R6_01')
     D  gi_cmd                       32A   const
      *
     D main...
     D                 PR
     D  i_cmd                        32A   const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_cmd                       32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(gi_cmd);

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_cmd                        32A   const
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Ignore Errors
         msg = f_newMsg('CPF9897': '*** Ignore Errors ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         if   not f_execute(i_cmd: *omit: *omit);
            msg = f_newMsg('CPF9898': 'Error on: ' + %trim(i_cmd));
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         // Return error information
         msg = f_newMsg('CPF9897': '*** Return error information ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         if   not f_execute(i_cmd: *omit: msg);
            // Do not let the program crash here
            msg.type = cMsg_Diag;
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         // Send *ESCAPE message to signal error
         msg = f_newMsg('CPF9897': '*** Send *ESCAPE message ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         f_execute(i_cmd: *omit);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R6_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R6_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_getNumEnvVar, f_getEnvVarByIndex ...      "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R6_02) PARM('de.tools400.test_r6_02.')       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R6_02')
     D  gi_prefix                    32A   const
      *
     D main...
     D                 PR
     D  i_prefix                     32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_prefix                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trim(gi_prefix));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_prefix                     32A   const varying
      *
      *  Helper fields
     D isError         S               N                     inz(cFalse)
     D x               S             10I 0                   inz
     D numEnvVar       S             10I 0                   inz
     D envVar          DS                  likeds(envVar_t ) inz
     D msg             DS                  likeds(msg_t    ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Get number of environment variables
         numEnvVar = f_getNumEnvVar();

         // Check environment variables for prefix
         for x = 1 to numEnvVar;
            envVar = f_getEnvVarByIndex(x);

            // If an existing variable starts with the
            // given prefix ...
            if %len(envVar.name) >= %len(i_prefix);
               if f_left(envVar.name: %len(i_prefix)) =
                                               f_left(i_prefix: %len(i_prefix));
                  // ... then tell the user that we can't proceed.
                  msg = f_newMsg('CPF9897':
                                 'ERROR - Found variable starting with: ' +
                                 envVar.name + '. Can''t proceed!');
                  f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
                  isError = cTrue;
               endif;
            endif;
         endfor;

         // If there is no variable that starts with the
         // given prefix ...
         if not isError;

            // ... add some variables to the environment
            f_setEnvVar(i_prefix + 'var1': 'Hello World');
            f_setEnvVar(i_prefix + 'var2': 'A Spaceman came travelling ...');

            // ... spinn through all of the variables
            numEnvVar = f_getNumEnvVar();

            for x = 1 to numEnvVar;
               envVar = f_getEnvVarByIndex(x);
               // ... and show them
               msg = f_newMsg('CPF9897': 'Found variable: ' + envVar.name +
                                                      ' = ' + envVar.value);
               f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            endfor;

            // ... finally remove the environment variables we
            //     just added before.
            f_delEnvVar(i_prefix + 'var1');
            f_delEnvVar(i_prefix + 'var2');

         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_isBitOn                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cFILE_CREATE    C                   const(1)
     D cFILE_REPLACE   C                   const(2)
     D cFILE_APPEND    C                   const(4)
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_01')
      *
     D main...
     D                 PR
      *
     D lf_openFile...
     D                 PR
     D  i_openFlags                  10U 0 const
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create file and replace data
         msg = f_newMsg(cMSG_ID_NONE: '*** CREATE + REPLACE ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         lf_openFile(cFILE_CREATE + cFILE_REPLACE);

         // Append data
         msg = f_newMsg(cMSG_ID_NONE: '*** APPEND ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         lf_openFile(cFILE_APPEND);

         // Append and replace data
         msg = f_newMsg(cMSG_ID_NONE: '*** APPEND + REPLACE ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         lf_openFile(cFILE_APPEND + cFILE_REPLACE);

         // Bits are zero. ==> Error
         msg = f_newMsg(cMSG_ID_NONE: '*** Bits are zero ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         monitor;
            f_isBitOn(0: 5);
         on-error;
            msg = f_newMsg(cMSG_ID_NONE: 'Error monitored.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endmon;

         // End message
         msg = f_newMsg(cMSG_ID_NONE: '*** END OF TEST ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
      *===============================================================*
      *  Dummy: Open a file.
      *===============================================================*
     P lf_openFile...
     P                 B
      *
     D lf_openFile...
     D                 PI
     D  i_openFlags                  10U 0 const
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Check CREATE flag
         if   f_isBitOn(cFILE_CREATE: i_openFlags);
            msg = f_newMsg(cMSG_ID_NONE: 'If the file being opened does not +
                                          exist, it is created.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         // Check APPEND + REPLACE flag
         if   f_isBitOn(cFILE_APPEND + cFILE_REPLACE: i_openFlags);
            msg = f_newMsg(cMSG_ID_NONE: 'APPEND + REPLACE must not be +
                                          specified together.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
            return;
         endif;

         // Check REPLACE flag
         if   f_isBitOn(cFILE_REPLACE: i_openFlags);
            msg = f_newMsg(cMSG_ID_NONE: 'Replace existing data +
                                          if the file exists.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         // Check APPEND flag
         if   f_isBitOn(cFILE_APPEND: i_openFlags);
            msg = f_newMsg(cMSG_ID_NONE: 'Append new data to the end of the +
                                          file.');
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         endif;

         return;

      /END-FREE
      *
     P lf_openFile...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_log10, f_clcLengthOfRPGIntFieldFromBufSize"
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_02)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
     D cFILE_CREATE    C                   const(1)
     D cFILE_REPLACE   C                   const(2)
     D cFILE_APPEND    C                   const(4)
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_02')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D msg             DS                  likeds(msg_t     ) inz
      *
     D rpgLEngth       S              5U 0 inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Compute length of a 1-byte integer field ( 3 I 0)
         rpgLength = f_clcLengthOfRPGIntFieldFromBufSize(1);

         msg = f_newMsg(cMSG_ID_NONE: 'Length of 1-byte integer is: ' +
                        %editc(rpgLength: 'Z'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Compute length of a 2-byte integer field ( 5 I 0)
         rpgLength = f_clcLengthOfRPGIntFieldFromBufSize(2);

         msg = f_newMsg(cMSG_ID_NONE: 'Length of 2-byte integer is: ' +
                        %editc(rpgLength: 'Z'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Compute length of a 4-byte integer field (10 I 0)
         rpgLength = f_clcLengthOfRPGIntFieldFromBufSize(4);

         msg = f_newMsg(cMSG_ID_NONE: 'Length of 4-byte integer is: ' +
                        %editc(rpgLength: 'Z'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Compute length of a 8-byte integer field (20 I 0)
         rpgLength = f_clcLengthOfRPGIntFieldFromBufSize(8);

         msg = f_newMsg(cMSG_ID_NONE: 'Length of 8-byte integer is: ' +
                        %editc(rpgLength: 'Z'));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_03  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_03"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genUUID                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_03)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_03')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D uuidAsHex       DS                  likeds(uuid_t    ) inz
     D uuidAsString    DS                  likeds(uuid_t    ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a hexadecimal UUID.
         // Note: Parameter 'cUUID_HEX' is
         //       are optional. Default is 'cUUID_HEX'.
         uuidAsHex = f_genUUID(cUUID_HEX);

         msg = f_newMsg(cMSG_ID_NONE:
                        'UUID as ' + %char(uuidAsHex.length) +
                        '-byte hex value: ' + uuidAsHex.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Generate a string UUID.
         uuidAsString = f_genUUID(cUUID_STRING);

         msg = f_newMsg(cMSG_ID_NONE:
                        'UUID as ' + %char(uuidAsString.length) +
                        '-byte string value: ' + uuidAsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_04  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_04"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genMD5                                    "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_04) PARM('Hello World')                   *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_04')
     D  gi_string                    32A   const
      *
     D main...
     D                 PR
     D  i_string                     32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_string                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_string));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_string                     32A   const  varying
      *
      *  Helper fields
     D buffer          S             64A                      inz
     D md5AsHex        DS                  likeds(md5_t     ) inz
     D md5AsString     DS                  likeds(md5_t     ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a hexadecimal MD5.
         // Note: Parameters 'cMD5_HEX' and 'length'
         //       are optional. Default is 'cMD5_HEX'.
         md5AsHex = f_genMD5(i_string: cMD5_HEX);

         msg = f_newMsg(cMSG_ID_NONE:
                        'MD5 as ' + %char(md5AsHex.length) +
                        '-byte hex value: ' + md5AsHex.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Generate a string MD5.
         md5AsString = f_genMD5(i_string: cMD5_STRING);

         msg = f_newMsg(cMSG_ID_NONE:
                        'MD5 as ' + %char(md5AsString.length) +
                        '-byte string value: ' + md5AsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Generate a string MD5 from a buffer.
         buffer      = i_string;
         md5AsString = f_genMD5(%addr(buffer): cMD5_STRING: %size(buffer));

         msg = f_newMsg(cMSG_ID_NONE:
                        'MD5 as ' + %char(md5AsString.length) +
                        '-byte string value: ' + md5AsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_05  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_05"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genSHA1                                   "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_05) PARM('Hello World')                   *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_05')
     D  gi_string                    32A   const
      *
     D main...
     D                 PR
     D  i_string                     32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_string                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_string));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_string                     32A   const  varying
      *
      *  Helper fields
     D buffer          S             64A                      inz
     D sha1AsHex       DS                  likeds(sha1_t    ) inz
     D sha1AsString    DS                  likeds(sha1_t    ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a hexadecimal SHA-1.
         // Note: Parameters 'cSHA1_HEX' and 'length'
         //       are optional. Default is 'cSHA1_HEX'.
         sha1AsHex = f_genSHA1(i_string: cSHA1_HEX);

         msg = f_newMsg(cMSG_ID_NONE:
                        'SHA-1 as ' + %char(sha1AsHex.length) +
                        '-byte hex value: ' + sha1AsHex.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Generate a string SHA-1.
         sha1AsString = f_genSHA1(i_string: cSHA1_STRING);

         msg = f_newMsg(cMSG_ID_NONE:
                        'SHA-1 as ' + %char(sha1AsString.length) +
                        '-byte string value: ' + sha1AsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         // Generate a string SHA-1 from a buffer.
         buffer      = i_string;
         sha1AsString = f_genSHA1(%addr(buffer): cSHA1_STRING: %len(i_string));

         msg = f_newMsg(cMSG_ID_NONE:
                        'SHA-1 as ' + %char(sha1AsString.length) +
                        '-byte string value: ' + sha1AsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_06  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_06"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genMD5 of IFS stream file                 "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_06) PARM('Hello World.txt')               *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,CLIB
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_06')
     D  gi_path                      32A   const
      *
     D main...
     D                 PR
     D  i_path                       32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_path                      32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_path));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_path                       32A   const  varying
      *
      *  Helper fields
     D is1Call         S               N                      inz(cFalse)
     D md5Options      S              5U 0                    inz
     D hFile           S             10I 0                    inz
     D inBuff          DS                  qualified
     D  size                         10U 0                    inz
     D  value                        64A                      inz
     D bytesLeft       S             10U 0                    inz
     D md5AsString     DS                  likeds(md5_t     ) inz
     D st_stat         DS                  likeds(st_stat_t ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a string MD5 of a given stream file:

         // Open stream file
         hFile = open(i_path: O_RDONLY);
         if hFile = RC_ERROR;
            return;
         endif;

         // Get size of stream file
         if stat(i_path: %addr(st_stat)) = RC_ERROR;
            callp close(hFile);
            return;
         else;
            bytesLeft = st_stat.size;
         endif;

         // Read 1. chunk of data
         inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));

         is1Call = cTrue;   // First call to f_genMD5

         dow inBuff.size > 0;

            // Set MD5 options
            if is1Call;
               if inBuff.size < bytesLeft;
                  md5Options = cMD5_FIRST;
               else;
                  md5Options = cMD5_ONLY;
               endif;
               is1Call = cFalse;
            else;
               if inBuff.size < bytesLeft;
                  md5Options = cMD5_MIDDLE;
               else;
                  md5Options = cMD5_FINAL;
               endif;
            endif;

            md5Options = md5Options + cMD5_STRING;

            // Call MD5 generation
            md5AsString = f_genMD5(%addr(inBuff.value):md5Options:inBuff.size);

            // Decrease number of bytes left
            bytesLeft = bytesLeft - inBuff.size;

            // Read next chunk of data
            inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));
         enddo;

         // Close stream file
         callp close(hFile);

         msg = f_newMsg(cMSG_ID_NONE:
                        'MD5 as ' + %char(md5AsString.length) +
                        '-byte string value: ' + md5AsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_07  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_07"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genSHA1 of IFS stream file                "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_07) PARM('Hello World.txt')               *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,CLIB
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_07')
     D  gi_path                      32A   const
      *
     D main...
     D                 PR
     D  i_path                       32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_path                      32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_path));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_path                       32A   const  varying
      *
      *  Helper fields
     D is1Call         S               N                      inz(cFalse)
     D shaOptions      S              5U 0                    inz
     D hFile           S             10I 0                    inz
     D inBuff          DS                  qualified
     D  size                         10U 0                    inz
     D  value                        64A                      inz
     D bytesLeft       S             10U 0                    inz
     D shaAsString     DS                  likeds(sha1_t    ) inz
     D st_stat         DS                  likeds(st_stat_t ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a string SHA-1 of a given stream file:

         // Open stream file
         hFile = open(i_path: O_RDONLY);
         if hFile = RC_ERROR;
            return;
         endif;

         // Get size of stream file
         if stat(i_path: %addr(st_stat)) = RC_ERROR;
            callp close(hFile);
            return;
         else;
            bytesLeft = st_stat.size;
         endif;

         // Read 1. chunk of data
         inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));

         is1Call = cTrue;   // First call to f_genSHA1

         dow inBuff.size > 0;

            // Set SHA-1 options
            if is1Call;
               if inBuff.size < bytesLeft;
                  shaOptions = cSHA1_FIRST;
               else;
                  shaOptions = cSHA1_ONLY;
               endif;
               is1Call = cFalse;
            else;
               if inBuff.size < bytesLeft;
                  shaOptions = cSHA1_MIDDLE;
               else;
                  shaOptions = cSHA1_FINAL;
               endif;
            endif;

            shaOptions = shaOptions + cSHA1_STRING;

            // Call SHA generation
            shaAsString = f_genSHA1(%addr(inBuff.value):shaOptions:inBuff.size);

            // Decrease number of bytes left
            bytesLeft = bytesLeft - inBuff.size;

            // Read next chunk of data
            inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));
         enddo;

         // Close stream file
         callp close(hFile);

         msg = f_newMsg(cMSG_ID_NONE:
                        'SHA-1 as ' + %char(shaAsString.length) +
                        '-byte string value: ' + shaAsString.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_08  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_08"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genCRC32                                  "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_08) PARM('Hello World!')                  *
      *    CALL PGM(TEST_R7_08) PARM(x'48656C6C6F20576F726C6421')     *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_08')
     D  gi_string                    32A   const
      *
     D main...
     D                 PR
     D  i_string                     32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_string                    32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_string));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_string                     32A   const  varying
      *
      *  Helper fields
     D crc32           DS                  likeds(crc32_t   ) inz
     D msg             DS                  likeds(msg_t     ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a CRC32 checksum.
         crc32 = f_genCRC32(i_string);

         msg = f_newMsg(cMSG_ID_NONE:
                        'CRC32 as ' + %char(crc32.length) +
                        '-byte hex value: ' + crc32.value);
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R7_09  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R7_09"
mbrtype =  "RPGLE     "
mbrtext =  "Test: f_genCRC32 of IFS stream file               "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R7_09) PARM('Hello World.txt')               *
      *    CALL PGM(TEST_R7_09) PARM('20050731-019-i32.exe')          *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,CLIB
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R7_09')
     D  gi_path                      32A   const
      *
     D main...
     D                 PR
     D  i_path                       32A   const  varying
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_path                      32A   const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main(%trimR(gi_path));

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_path                       32A   const  varying
      *
      *  Helper fields
     D is1Call         S               N                      inz(cFalse)
     D crc32Options    S              5U 0                    inz
     D hFile           S             10I 0                    inz
     D inBuff          DS                  qualified
     D  size                         10U 0                    inz
     D  value                      8192A                      inz
     D bytesLeft       S             10U 0                    inz
     D crc32           DS                  likeds(crc32_t   ) inz
     D st_stat         DS                  likeds(st_stat_t ) inz
     D msg             DS                  likeds(msg_t     ) inz
     D elapsedTime     DS                  qualified
     D  start                          Z   inz
     D  end                            Z   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Generate a CRC32 checksum of a given stream file:

         // Open stream file
         hFile = open(i_path: O_RDONLY);
         if hFile = RC_ERROR;
            return;
         endif;

         // Get size of stream file
         if stat(i_path: %addr(st_stat)) = RC_ERROR;
            callp close(hFile);
            return;
         else;
            bytesLeft = st_stat.size;
         endif;

         elapsedTime.start = %timestamp();

         // Read 1. chunk of data
         inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));

         is1Call = cTrue;   // First call to f_genCRC32

         dow inBuff.size > 0;

            // Set CRC32 options
            if is1Call;
               if inBuff.size < bytesLeft;
                  crc32Options = cCRC32_FIRST;
               else;
                  crc32Options = cCRC32_ONLY;
               endif;
               is1Call = cFalse;
            else;
               if inBuff.size < bytesLeft;
                  crc32Options = cCRC32_MIDDLE;
               else;
                  crc32Options = cCRC32_FINAL;
               endif;
            endif;

            // Call CRC32 generation
            crc32 = f_genCRC32(%addr(inBuff.value): crc32Options: inBuff.size);

            // Decrease number of bytes left
            bytesLeft = bytesLeft - inBuff.size;

            // Read next chunk of data
            inBuff.size = read(hFile: %addr(inBuff.value): %size(inBuff.value));
         enddo;

         // Close stream file
         callp close(hFile);

         elapsedTime.end   = %timestamp();

         msg = f_newMsg(cMSG_ID_NONE:
                        'CRC32 as ' + %char(crc32.length) +
                        '-byte string value: ' + %trimR(crc32.value) +
                        ' Elapsed time: ' +
                            %char(%diff(elapsedTime.end:
                                        elapsedTime.start: *mseconds)));
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R8_01  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R8_01"
mbrtype =  "RPGLE     "
mbrtext =  "Test: HANDLE_*                                    "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R8_01)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
     D handle1_t       DS                  qualified   based(pDummy)
     D  numE                         10I 0
     D  type                         20A
      *
     D handle2_t       DS                  qualified   based(pDummy)
     D  type                         20A
     D  numE                         10I 0
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,CLIB
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R8_01')
      *
     D main...
     D                 PR
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D aHandle1        S                   like(HANDLE_handle_t) inz
     D aHandle2        S                   like(HANDLE_handle_t) inz
     D handle1         DS                  likeds(handle1_t    ) based(pHandle1)
     D handle2         DS                  likeds(handle2_t    ) based(pHandle2)
     D msg             DS                  likeds(msg_t        ) inz
      *
      *  Constants
     D cTYPE1          C                   const('*HANDLE1')
     D cTYPE2          C                   const('*HANDLE2')
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create handles
         aHandle1 = HANDLE_new(cTYPE1: %size(handle1_t));
         aHandle2 = HANDLE_new(cTYPE2: %size(handle2_t));

         // Check handle types
         if not HANDLE_isTypeOf(aHandle1: cTYPE1);
            dsply 'Invalid type of handle 1' '*EXT';
         endif;

         if not HANDLE_isTypeOf(aHandle2: cTYPE2);
            dsply 'Invalid type of handle 2' '*EXT';
         endif;

         // Change data of handle 1
         pHandle1 = HANDLE_getPointer(aHandle1);
         handle1.numE = 4;
         handle1.type = cTYPE1;

         // Change data of handle 2
         pHandle2 = HANDLE_getPointer(aHandle2);
         handle2.numE = 8;
         handle2.type = cTYPE2;

         // Change data of handle 1
         pHandle1 = HANDLE_getPointer(aHandle1);
         handle1.numE = handle1.numE * 2;
         handle1.type = cTYPE1 + cType1;

         // Change data of handle 2
         pHandle2 = HANDLE_getPointer(aHandle2);
         handle2.numE = handle2.numE * 2;
         handle2.type = cTYPE2 + cTYPE2;

         // Verify handle data
         if handle1.numE <> 8 or handle1.type <> cTYPE1 + cType1;
            dsply 'Invalid data of handle 1' '*EXT';
         endif;

         if handle2.numE <> 16 or handle2.type <> cTYPE2 + cType2;
            dsply 'Invalid data of handle 2' '*EXT';
         endif;

         // Delete handles
         HANDLE_delete(aHandle1);
         HANDLE_delete(aHandle2);

         // Create a NULL Handle
         aHandle1 = HANDLE_null();

         // Check for a NULL Handle
         if not HANDLE_isNull(aHandle1);
            dsply 'Handle is not a NULL handle' '*EXT';
         endif;

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing TEST_R8_02  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "TEST_R8_02"
mbrtype =  "RPGLE     "
mbrtext =  "Test: MEMORY_*                                    "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *    CALL PGM(TEST_R8_02)                                       *
      *===============================================================*
      *   >>PRE-COMPILER<<                                            *
      *                                                               *
      *     >>CRTCMD<<  CRTRPGMOD    MODULE(&LI/&OB) +                *
      *                              SRCFILE(&SL/&SF) +               *
      *                              SRCMBR(&SM);                     *
      *                                                               *
      *     >>COMPILE<<                                               *
      *       >>PARM<< TRUNCNBR(*NO);                                 *
      *       >>PARM<< DBGVIEW(*LIST);                                *
      *       >>PARM<< TGTRLS(*CURRENT);                              *
      *     >>END-COMPILE<<                                           *
      *                                                               *
      *     >>EXECUTE<<                                               *
      *                                                               *
      *     >>CMD<<     CRTPGM       PGM(&LI/&OB) +                   *
      *                              MODULE(&LI/&OB) +                *
      *                              ACTGRP(*NEW) +                   *
      *                              BNDSRVPGM(&LI/BASICS1) +         *
      *                              BNDDIR(QC2LE) +                  *
      *                              TGTRLS(*CURRENT) +               *
      *                              DETAIL(*BASIC);                  *
      *                                                               *
      *   >>END-PRE-COMPILER<<                                        *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Global Constants
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                         extpgm('TEST_R8_02')
      *
     D main...
     D                 PR
      *
      *  Show cells
     D showCells...
     D                 PR
     D  i_aMemList                     *   value
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
      *
     D PGM_ENTRY_POINT...
     D                 PI
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         main();

         *inlr = *on;

         return;

      /END-FREE
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
      *
      *  Helper fields
     D aMemList        S               *   inz
     D pTheMemCell     S               *   inz   dim(5)
     D aCellPayload    S             20A   based(pACellPayload)
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Create first memory cell
         pTheMemCell(1) = MEMORY_allocate(aMemList: %size(aCellPayload));
         pACellPayload = pTheMemCell(1);
         aCellPayload  = 'first cell';

         // Create second memory cell
         pTheMemCell(2) = MEMORY_allocate(aMemList: %size(aCellPayload));
         pACellPayload = pTheMemCell(2);
         aCellPayload  = 'second cell';

         // Create third memory cell
         pTheMemCell(3) = MEMORY_allocate(aMemList: %size(aCellPayload));
         pACellPayload = pTheMemCell(3);
         aCellPayload  = 'third cell';

         // Create fourth memory cell
         pTheMemCell(4) = MEMORY_allocate(aMemList: %size(aCellPayload));
         pACellPayload = pTheMemCell(4);
         aCellPayload  = 'fourth cell';

         // Create fifth memory cell
         pTheMemCell(5) = MEMORY_allocate(aMemList: %size(aCellPayload));
         pACellPayload = pTheMemCell(5);
         aCellPayload  = 'fifth cell';

         // Show cells:
         msg = f_newMsg(cMSG_ID_NONE: '*** Start list of memory cells ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         showCells(aMemList);

         // Free third cell
         msg = f_newMsg(cMSG_ID_NONE: '--> Free third cell');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         MEMORY_free(aMemList: pTheMemCell(3));

         // Show cells:
         msg = f_newMsg(cMSG_ID_NONE: '*** Start list of memory cells (4) ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         showCells(aMemList);

         // Free fith cell
         msg = f_newMsg(cMSG_ID_NONE: '--> Free fifth cell');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         MEMORY_free(aMemList: pTheMemCell(5));

         // Show cells:
         msg = f_newMsg(cMSG_ID_NONE: '*** Start list of memory cells (3) ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         showCells(aMemList);

         // Free first cell
         msg = f_newMsg(cMSG_ID_NONE: '--> Free first cell');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         MEMORY_free(aMemList: pTheMemCell(1));

         // Show cells:
         msg = f_newMsg(cMSG_ID_NONE: '*** Start list of memory cells (2) ***');
         f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);
         showCells(aMemList);

         // Free memory
         MEMORY_freeAll(aMemList);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
      *===============================================================*
      *  Show cells
      *===============================================================*
     P showCells...
     P                 B
      *
     D showCells...
     D                 PI
     D  i_aMemList                     *   value
      *
      *  Helper fields
     D cellPayload     S             20A   based(pCellPayload)
      *
     D cell            DS                  qualified   based(pCell)
     D  pPrvCell                       *
     D  size                         10I 0
      *
     D msg             DS                  likeds(msg_t      ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pCell = i_aMemList;

         dou pCell = *NULL;
            pCellPayload = pCell - cell.size;

            msg = f_newMsg(cMSG_ID_NONE: cellPayload);
            f_sndPgmMsg(msg: cMsg_Prv: cMsg_ToCtlBdy);

            pCell = cell.pPrvCell;
         enddo;

         return;

      /END-FREE
      *
     P showCells...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing ZCONF  type H - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "ZCONF     "
mbrtype =  "H         "
mbrtext =  "Configuration of the zlib compression library     "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2003 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id: zconf.h,v 1.1 2004/01/27 13:39:46 re7 Exp $ */

#ifndef ZCONF_H
#define ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_  z_deflateInit_
#  define deflate       z_deflate
#  define deflateEnd    z_deflateEnd
#  define inflateInit_  z_inflateInit_
#  define inflate       z_inflate
#  define inflateEnd    z_inflateEnd
#  define deflateInit2_ z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy   z_deflateCopy
#  define deflateReset  z_deflateReset
#  define deflatePrime  z_deflatePrime
#  define deflateParams z_deflateParams
#  define deflateBound  z_deflateBound
#  define inflateInit2_ z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync   z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateCopy   z_inflateCopy
#  define inflateReset  z_inflateReset
#  define compress      z_compress
#  define compress2     z_compress2
#  define compressBound z_compressBound
#  define uncompress    z_uncompress
#  define adler32       z_adler32
#  define crc32         z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte          z_Byte
#  define uInt          z_uInt
#  define uLong         z_uLong
#  define Bytef         z_Bytef
#  define charf         z_charf
#  define intf          z_intf
#  define uIntf         z_uIntf
#  define uLongf        z_uLongf
#  define voidpf        z_voidpf
#  define voidp         z_voidp
#endif

#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif
#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
#  define OS2
#endif
#if defined(_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
#    ifndef SYS16BIT
#      define SYS16BIT
#    endif
#  endif
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#ifdef SYS16BIT
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#ifdef __STDC_VERSION__
#  ifndef STDC
#    define STDC
#  endif
#  if __STDC_VERSION__ >= 199901L
#    ifndef STDC99
#      define STDC99
#    endif
#  endif
#endif
#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
#  define STDC
#endif
#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
#  define STDC
#endif
#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
#  define STDC
#endif
#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
#  define STDC
#endif

#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const       /* note: need a more gentle solution here */
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#ifdef SYS16BIT
#  if defined(M_I86SM) || defined(M_I86MM)
     /* MSC small or medium model */
#    define SMALL_MEDIUM
#    ifdef _MSC_VER
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#  if (defined(__SMALL__) || defined(__MEDIUM__))
     /* Turbo C small or medium model */
#    define SMALL_MEDIUM
#    ifdef __BORLANDC__
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#endif

#if defined(WINDOWS) || defined(WIN32)
   /* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    */
#  ifdef ZLIB_DLL
#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
#      ifdef ZLIB_INTERNAL
#        define ZEXTERN extern __declspec(dllexport)
#      else
#        define ZEXTERN extern __declspec(dllimport)
#      endif
#    endif
#  endif  /* ZLIB_DLL */
   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    */
#  ifdef ZLIB_WINAPI
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
     /* No need for _export, use ZLIB.DEF instead. */
     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
#    define ZEXPORT WINAPI
#    ifdef WIN32
#      define ZEXPORTVA WINAPIV
#    else
#      define ZEXPORTVA FAR CDECL
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  ifdef ZLIB_DLL
#    ifdef ZLIB_INTERNAL
#      define ZEXPORT   __declspec(dllexport)
#      define ZEXPORTVA __declspec(dllexport)
#    else
#      define ZEXPORT   __declspec(dllimport)
#      define ZEXPORTVA __declspec(dllimport)
#    endif
#  endif
#endif

#ifndef ZEXTERN
#  define ZEXTERN extern
#endif
#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif

#ifndef FAR
#  define FAR
#endif

#if !defined(__MACTYPES__)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void const *voidpc;
   typedef void FAR   *voidpf;
   typedef void       *voidp;
#else
   typedef Byte const *voidpc;
   typedef Byte FAR   *voidpf;
   typedef Byte       *voidp;
#endif

#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  ifdef VMS
#    include <unixio.h>   /* for off_t */
#  endif
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

#if defined(__OS400__)
#define NO_vsnprintf
#endif

#if defined(__MVS__)
#  define NO_vsnprintf
#  ifdef FAR
#    undef FAR
#  endif
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(deflateBound,"DEBND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(compressBound,"CMBND")
#   pragma map(inflate_table,"INTABL")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_copyright,"INCOPY")
#endif

#endif /* ZCONF_H */

]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing ZLIB  type H - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "ZLIB      "
mbrtype =  "H         "
mbrtext =  "Interface of the  zlib  compression library       "
srcfile =  "QBASICS1  "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.1, November 17th, 2003

  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef ZLIB_H
#define ZLIB_H

#include "zconf"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.2.1"
#define ZLIB_VERNUM 0x1210

/*
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The compressed data format used by the in-memory functions is the zlib
  format, which is a zlib wrapper documented in RFC 1950, wrapped around a
  deflate stream, which is itself documented in RFC 1951.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

     The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

     This library does not provide any functions to write gzip files in memory.
  However such functions could be easily written using zlib's deflate function,
  the documentation in the gzip RFC, and the examples in gzio.c.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
/* Allowed flush values; see deflate() and inflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_RLE                 3
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field (though see inflate()) */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/*
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six to avoid repeated flush markers due to
  avail_out == 0 on return.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.

    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  the value returned by deflateBound (see below). If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
  fatal, and deflate() can be called again with more input and more output
  space to continue compressing.
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/*
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
  if and when it get to the next deflate block boundary. When decoding the zlib
  or gzip format, this will cause inflate() to return immediately after the
  header and before the first block. When doing a raw inflate, inflate() will
  go ahead and process the first block, and will return when it gets to the end
  of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  Also to assist in this, on return inflate() will set strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64
  if inflate() is currently decoding the last block in the deflate stream,
  plus 128 if inflate() returned immediately after decoding an end-of-block
  code or decoding the complete header up to just before the first byte of the
  deflate stream. The end-of-block will not be indicated until all of the
  uncompressed data from that block has been written to strm->next_out.  The
  number of unused bits may in general be greater than seven, except when
  bit 7 of data_type is set, in which case the number of unused bits will be
  less than eight.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster approach
  may be used for the single inflate() call.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call. So the only effect of the flush parameter in this implementation
  is on the return value of inflate(), as noted below, or when it returns early
  because Z_BLOCK is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the adler32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below. At the end of the stream, inflate() checks that its computed adler32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically.  Any information
  contained in the gzip header is not retained, so applications that need that
  information should instead use raw inflate, see inflateInit2() below, or
  inflateBack() and perform their own processing of the gzip header and
  trailer.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing. If Z_DATA_ERROR is returned, the application may then
  call inflateSync() to look for a good compression block if a partial recovery
  of the data is desired.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer). It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
   determines the window size. deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute an adler32 check value.

     windowBits can also be greater than 15 for optional gzip encoding. Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper. The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero),
   no header crc, and the operating system will be set to 255 (unknown).

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding). Filtered data consists mostly of small values with a somewhat
   random distribution. In this case, the compression algorithm is tuned to
   compress them better. The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
   parameter only affects the compression ratio but not the correctness of the
   compressed output even if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   adler32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                      int level,
                                      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                       uLong sourceLen));
/*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit()
   or deflateInit2().  This would be used to allocate an output buffer
   for deflation in a single pass, and so would be called before deflate().
*/

ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     deflatePrime() inserts bits in the deflate output stream.  The intent
  is that this function is used to start off the deflate output with the
  bits leftover from a previous deflate stream when appending to it.  As such,
  this function can only be used for raw deflate, and must be used before the
  first deflate() call after a deflateInit2() or deflateReset().  bits must be
  less than or equal to 16, and that many of the least significant bits of
  value will be inserted in the output.

      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used. If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
   determines the window size. inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream. This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values. If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an adler32 or a crc32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is. Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding. Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/*
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

/*
ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,
                                        unsigned char FAR *window));

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
   be allocated, or Z_VERSION_ERROR if the version of the library does not
   match the version of the header file.
*/

typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR *strm,
                                    in_func in, void FAR *in_desc,
                                    out_func out, void FAR *out_desc));
/*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is more efficient than inflate() for
   file i/o applications in that it avoids copying between the output and the
   sliding window by simply making the window itself the output buffer.  This
   function trusts the application to not change the output buffer passed by
   the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free
   the allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects
   only the raw deflate stream to decompress.  This is different from the
   normal behavior of inflate(), which expects either a zlib or gzip header and
   trailer around the deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero--buf is ignored in that
   case--and inflateBack() will return a buffer error.  inflateBack() will call
   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
   should return zero on success, or non-zero on failure.  If out() returns
   non-zero, inflateBack() will return with an error.  Neither in() nor out()
   are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 .. strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format
   error in the deflate stream (in which case strm->msg is set to indicate the
   nature of the error), or Z_STREAM_ERROR if the stream was not properly
   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
   distinguished using strm->next_in which will be Z_NULL only if in() returned
   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
   out() returning non-zero.  (in() will always be called before out(), so
   strm->next_in is assured to be defined if out() returns non-zero.)  Note
   that inflateBack() cannot return Z_OK.
*/

ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR *strm));
/*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*/

ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
/* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 */


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least the value returned
   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen). Upon exit, destLen is the actual size of the
   compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
/*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before
   a compress() or compress2() call to allocate the destination buffer.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h", or 'R' for run-length encoding
   as in "wb1R". (See the description of deflateInit2 for more information
   about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
                                   voidpc buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).  The number of
   uncompressed bytes written is limited to 4095. The caller should assure that
   this limit is not exceeded. If it is exceeded, then gzprintf() will return
   return an error (0) with nothing written. In this case, there may also be a
   buffer overflow with unpredictable consequences, which is possible only if
   zlib was compiled with the insecure functions sprintf() or vsprintf()
   because the secure snprintf() or vsnprintf() functions were not available.
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
/*
      Push one character back onto the stream to be read again later.
   Only one character of push-back is allowed.  gzungetc() returns the
   character pushed, or -1 on failure.  gzungetc() will fail if a
   character has been pushed but not read yet, or if c is -1. The pushed
   character will be discarded if the stream is repositioned with gzseek()
   or gzrewind().
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
                                      z_off_t offset, int whence));
/*
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
/*
     Clears the error and end-of-file flags for file. This is analogous to the
   clearerr() function in stdio. This is useful for continuing to read a gzip
   file that is being written concurrently.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR *strm, int windowBits,
                                         unsigned char FAR *window,
                                         const char *version,
                                         int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
#define inflateBackInit(strm, windowBits, window) \
        inflateBackInit_((strm), (windowBits), (window), \
        ZLIB_VERSION, sizeof(z_stream))


#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus

#endif

#endif /* ZLIB_H */

]]>  </copysrc>
</mbr>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="A_INSTALL"><![CDATA[
CRTBNDCL PGM(&tolib/A_INSTALL) SRCFILE(&tolib/&SRCFILE) SRCMBR(*PGM) DFTACTGRP(*NO) ACTGRP(*NEW) DBG
VIEW(*LIST)
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
CALL PGM(&tolib/A_INSTALL) PARM('&TGTRLS' '&SRCFILE' '&tolib' '&CRTTSTPGM' 'C_COMP')
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
DLTPGM PGM(&tolib/A_INSTALL)
]]>  </qcmdexc>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*COMP     "><![CDATA[
Application BASICS1 successfully installed.
]]>  </sendmsg>
</upload>
