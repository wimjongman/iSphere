<?xml version="1.0" encoding="ISO-8859-1"?>
     <!-- Embedded DTD for validation -->
     <!DOCTYPE upload [
     <!ELEMENT compile (#PCDATA)>
     <!ATTLIST compile
      condition CDATA #REQUIRED
     >
     <!ELEMENT copysrc (#PCDATA)>
     <!ELEMENT install_instructions (#PCDATA)>
     <!ELEMENT install_program (#PCDATA)>
     <!ELEMENT mbr (copysrc)>
     <!ATTLIST mbr
      mbrname CDATA #REQUIRED
      mbrtype CDATA #REQUIRED
      mbrtext CDATA #REQUIRED
      srcfile CDATA #REQUIRED
      srclib CDATA #REQUIRED
      srclen CDATA #REQUIRED
      srccssid CDATA #REQUIRED
     >
     <!ELEMENT qcmdexc (#PCDATA)>
     <!ATTLIST qcmdexc
      condition CDATA #REQUIRED
      release CDATA #REQUIRED
      dltsplf CDATA #REQUIRED
     >
     <!ELEMENT qrycond (#PCDATA)>
     <!ATTLIST qrycond
      msg CDATA #REQUIRED
      values CDATA #REQUIRED
      var CDATA #REQUIRED
     >
     <!ELEMENT sendmsg (#PCDATA)>
     <!ATTLIST sendmsg
      sendmsgid CDATA #REQUIRED
      sendmsgtype CDATA #REQUIRED
     >
     <!ELEMENT rtvobjd (#PCDATA)>
     <!ATTLIST rtvobjd
      condition CDATA #REQUIRED
      obj CDATA #REQUIRED
      lib CDATA #REQUIRED
      objtype CDATA #REQUIRED
      rtnlib CDATA #IMPLIED
     >
     <!ELEMENT upload (install_instructions | install_program | qrycond |
                       qcmdexc | sendmsg | mbr | compile | rtvobjd | chgvar)+>
     <!ATTLIST upload
      appname CDATA #REQUIRED
      appauthor CDATA #REQUIRED
      appblddate CDATA #REQUIRED
     >
     ]>
<upload  appname="WHOAMI"  appauthor="Thomas Raddatz"  appblddate=" 1/16/2019">
<install_instructions><![CDATA[
     *----------------------------------------------------------------      ------
     *  1. Upload entire XML to your AS/400 to a source file 112 long, into any mbr
     *     name not in this XML (suggest member name like ABCX or XYZX). The source
     *     file must be in the library where source and objects are to be installed.
     *
     *  2. If you have XMLPREVIEW installed, skip to step 3.
     *
     *     Copy the text between the start tag <install_program> and the end
     *     tag </install_program> into any member name (your choice)
     *     in file QRPGLESRC member type RPGLE.   CRTBNDRPG to compile.
     *     NOTE: You need extract the install program only once, this same program
     *           will install any upload on this page.
     *
     *  3. Call the install program (or execute XmlPrevew) passing these 3 parms.
     *       'your-member-name you uploaded this text into'
     *       'your-source-file-name the member is in'
     *       'your-library-name the source file is in'
     *
     *  The various source members will be extracted and the objects required
     *   for the application will be created in your-library-name.
     *----------------------------------------------------------------      ------
]]>  </install_instructions>
<install_program><![CDATA[
      * /// START OF INSTALL PGM HERE   ************************** ///
      *---------------------------------------------------------------------------------------
      * CRTBNDRPG PGM(QTEMP/XMLINST) SRCFILE(ISPHERE/QBUILD) SRCMBR(*PGM)
      *---------------------------------------------------------------------------------------
      * Parse / Install from xml text into source members and objects.
      * Copyright (C) 2001    Craig Rutledge    <craig_rutledge@mohawkind.com>
      * Martin Rowe    <Martin@dbg400.net>          scripting cmd prompts
      * David George   <webmaster@400times.co.uk>   intellectual input
      * Thomas Raddatz <thomas.raddatz@tools400.de> execute SQL statements
      * Thomas Raddatz <thomas.raddatz@tools400.de> conditions
      * Thomas Raddatz <thomas.raddatz@tools400.de> release
      * Thomas Raddatz <thomas.raddatz@tools400.de> retrieve object description
      *
      * Use xml tags in text to trigger:
      * 1. Parse text into source members (create srcfile & member if required).
      * 2. Compile source into objects.
      * 3. Send installation progress user messages.
      * 4. Execute qcmdexc as required.
      * 5. Execute SQL statements as required.
      *
      * This program is free software, you can redistribute it and/or modify it
      * under the terms of the GNU General Public License as published by
      * the Free Software Foundation.  See GNU General Public License for details
      *---------------------------------------------------------------------------------------
      * >>PRE-COMPILER<<
      *   >>CRTCMD<< CRTBNDRPG    PGM(&LI/&OB) SRCFILE(&SL/&SF) SRCMBR(*PGM) +
      *                           DBGVIEW(*LIST) OPTION(*EVENTF);
      *   >>EXECUTE<<
      * >>END-PRE-COMPILER<<
      *---------------------------------------------------------------------------------------
     H DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('QC2LE')
      *---------------------------------------------------------------------------------------
     Fxmlinput  if   f  112        disk    usropn                               uploaded text
     Fqxxxsrc   o    f  112        disk    usropn                               parsed out
      *--------------------------------------------------------------------
      * create parm prototypes
      *--------------------------------------------------------------------
      *  Tokenize String
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_token                        *   value  options(*string)
      * retrieve member description
     D qusrmbrd        PR                  ExtPgm('QUSRMBRD')                   MEMBER DESCRIPTION
     D  o_rcvVar                  32767a          options(*varsize)             RECEIVER
     D  i_lenRcvVar                  10i 0 const                                LENGTH OF RECVR
     D  i_format                      8    const                                UPLOAD TYPE
     D  i_qFile                      20    const                                FILE   LIB
     D  i_mbr                        10    const                                MEMBER NAME
     D  i_ovverride                   1    const                                PROCESS OVERIDE
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * retrieve object description
     D QUSROBJD...
     D                 PR                         extpgm('QUSROBJD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_type                       10A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    | OptGrp 1
      * send program message
     D qmhsndpm        PR                  ExtPgm('QMHSNDPM')                   SEND MESSAGES
     D  i_msgID                       7a   const                                ID
     D  i_qMsgF                      20a   const                                FILE
     D  i_msgText                 32767a   const  options(*varsize)             TEXT
     D  i_lenMsgText                 10i 0 const                                LENGTH
     D  i_msgType                    10a   const                                TYPE
     D  i_callStackE                 10a   const                                STACK ENTRY
     D  i_callStackC                 10i 0 const                                STACK COUNTER
     D  i_msgKey                      4a   const                                KEY
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * execute cl command
     D  qcmdexc        PR                  ExtPgm('QCMDEXC')
     D  i_cmd                        50a   Const
     D  i_lenCmd                     15p 5 Const
      *  Allocate Environment Handle
     D SQLAllocEnv...
     D                 PR                         extproc('SQLAllocEnv')
     D                                     like(SQLRETURN_t )
     D  o_phenv                        *   value
      *  Allocate Connection Handle
     D SQLAllocConnect...
     D                 PR                         extproc('SQLAllocConnect')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
     D  o_phdbc                        *   value
      *  Connect to a Data Source
     D SQLConnect...
     D                 PR                         extproc('SQLConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_szDSN                        *   value  options(*string)
     D  i_cbDSN                            value  like(SQLSMALLINT_t)
     D  i_szUID                        *   value  options(*string)
     D  i_cbUID                            value  like(SQLSMALLINT_t)
     D  i_szAuthStr                    *   value  options(*string)
     D  i_cbAuthStr                        value  like(SQLSMALLINT_t)
      *  Set Connection Option
     D SQLSetConnectOption...
     D                 PR                         extproc('SQLSetConnectOption')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_fOption                          value  like(SQLSMALLINT_t)
     D  i_vParam                           value  like(SQLPOINTER_t )
      *  Allocate a Statement Handle
     D SQLAllocStmt...
     D                 PR                         extproc('SQLAllocStmt')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  o_phstmt                       *   value
      *  Execute a Statement Directly
     D SQLExecDirect...
     D                 PR                         extproc('SQLExecDirect')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_szSqlStr                     *   value  options(*string)
     D  i_cbSqlStr                         value  like(SQLINTEGER_t)
      *  Free (or Reset) a Statement Handle
     D SQLFreeStmt...
     D                 PR                         extproc('SQLFreeStmt')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_fOption                          value  like(SQLSMALLINT_t)
      *  Disconnect from a Data Source
     D SQLDisconnect...
     D                 PR                         extproc('SQLDisconnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Connection Handle
     D SQLFreeConnect...
     D                 PR                         extproc('SQLFreeConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Environment Handle
     D SQLFreeEnv...
     D                 PR                         extproc('SQLFreeEnv')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
      *--------------------------------------------------------------------
     D long_t          S             10I 0                    based(pDummy)
     D short_t         S              5I 0                    based(pDummy)
      *
     D SQLINTEGER_t    S                   like(long_t      ) based(pDummy)
     D SQLSMALLINT_t   S                   like(short_t     ) based(pDummy)
      *
     D PTR_t           S               *                      based(pDummy)
     D SQLPOINTER_t    S                   like(PTR_t       ) based(pDummy)
     D HENV_t          S                   like(long_t      ) based(pDummy)
     D HDBC_t          S                   like(long_t      ) based(pDummy)
     D HSTMT_t         S                   like(long_t      ) based(pDummy)
     D RETCODE_t       S                   like(SQLINTEGER_t) based(pDummy)
      *
     D SQLHENV_t       S                   like(HENV_t      ) based(pDummy)
     D SQLHDBC_t       S                   like(HDBC_t      ) based(pDummy)
     D SQLHSTMT_t      S                   like(HSTMT_t     ) based(pDummy)
     D SQLRETURN_t     S                   like(RETCODE_t   ) based(pDummy)
      *
     D retCode         S                   like(SQLRETURN_t) inz
     D hdbc            S                   like(SQLHDBC_t  ) inz
     D hstmt           S                   like(SQLHSTMT_t ) inz
     D henv            S                   like(SQLHENV_t  ) inz
     D sqlInit         S              1A                     inz(*off)
     D cOptVal         S             10I 0                   inz
      *
     D SQL_NTS         C                   const( -3)
     D SQL_COMMIT_NONE...
     D                 C                   const(  1)
     D SQL_ATTR_COMMIT...
     D                 C                   const(  0)
     D SQL_DROP        C                   const(  1)
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     D readElement     PR                        like(bldexc)
     D  i_element                     9A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to double quotes in a string
      *--------------------------------------------------------------------
     D dblQuotes       PR          2048A         varying
     D  i_string                   2048A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to get attribute data from a string
      *--------------------------------------------------------------------
     D getAttrData...
     D                 PR          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *--------------------------------------------------------------------
      * Define function prototype to check for a condition
      *--------------------------------------------------------------------
     D isCondition...
     D                 PR              n
     D  i_condList                 2000A   value
      *---------------------------------------------------------------------------------------
     D loadConditions...
     D                 PR                  dim(32) like(condition)
     D  i_conditions                128A   value
      *--------------------------------------------------------------------
     D getCurrentRelease...
     D                 PR            10A
      *--------------------------------------------------------------------
     D isRelease...
     D                 PR              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *--------------------------------------------------------------------
     D setTargetRelease...
     D                 PR          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *--------------------------------------------------------------------
     D setVariable...
     D                 PR
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
      *---------------------------------------------------------------------------------------------
     D getVarName...
     D                 PR            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
      *---------------------------------------------------------------------------------------------
     D getVarValue...
     D                 PR            64a          varying
     D  i_name                       11a   value  varying
      *---------------------------------------------------------------------------------------------
     D uCase...
     D                 PR          2000A          varying
     D  i_string                   2000A   value  varying
      *--------------------------------------------------------------------
     D vrcvar          s            145
     D qm_msgid        s              7
     D qm_msgtxt       s            500
     D qm_msgq         s             10
     D qm_msgtyp       s             10
     D mbrname         s             10
     D mbrtype         s             10
     D mbrtext         s             50
     D srcfile         s             10
     D srclen          s              5
     D srclenN         s              5  0   inz(0)
     D srccssid        s              5
     D bldexc          s           2000
     D write_flag      s              1n   inz(*off)
     D srcSeqno        s              6s 2 inz(0)
     D aa              s              5u 0 inz(0)
     D ll              s              5u 0 inz(0)
     D qs              c                   ''''
     D qd              c                   '"'
     D errFLag         s              1    inz(*off)
     D cnd_msg         s             42
     D cnd_values      s            110
     D cnd_var         s             10
     D cnd_rtnVal      s             10
     D cnd_array       s                   dim(32) inz like(condition)
     D cnd_ptr         s             10i 0 inz
     D condition       s             10a
     D condList        s           2000a
     D release         s             10a
     D dltsplf         s             10a
     D objd_obj        s             10a
     D objd_lib        s             10a
     D objd_objtype    s             10a
     D objd_rtnlib     s             10a
     D objd0100        ds
     D  od_bytRet              1      4i 0
     D  od_bytAvl              5      8i 0
     D  od_name                9     18a
     D  od_lib                19     28a
     D  od_type               29     38a
     D  od_rtnLib             39     48a
     D fld_array       ds
     D  fld_x                        10i 0 inz
     D  fld_name                     11a   inz dim(64) varying
     D  fld_value                    64a   inz dim(64) varying
     D var_name        s             11a   inz varying
     D var_value       s             64a   inz varying
      * Error return code parm for APIs.
     D errCode         DS
     D  errCode_bytPrv...
     D                               10i 0 inz(%size(errCode))
     D  errCode_bytAvl...
     D                               10i 0 inz(0)
     D  errCode_excID...
     D                                7a   inz
     D  errCode_reserved...
     D                                1a   inz
     D  errCode_escData...
     D                              256a   inz
      * Optional parameters
     D OvrSrcFile      s                   like(i_OvrSrcFile) inz
     D isPreDefCond    s               N   inz(*off)
     D TgtRls          s                   like(i_TgtRls    ) inz
      *
      * Program status data structure.
     D sds            sds
     D  sds_pgmName                  10A
     D  sds_status                    5S 0
     D  sds_prvStat                   5S 0
     D  sds_lastSeq                   8A
     D  sds_lastSubR                  8A
     D  sds_numParm                   3S 0
     D  sds_msgID                     7A
     D  sds_MiInstr                   4A
     D  sds_wrkArea                  30A
     D  sds_lib                      10A
     D  sds_msgText                  80A
      *--------------------------------------------------------------------
     Ixmlinput  ns
     I                                 13   21  xmltag1
     I                                 18   27  xmltag2
     I                                 13  112  xmlcode
      *--------------------------------------------------------------------
     C     *entry        plist
     C                   parm                    ParseSrcMbr      10            source member
     C                   parm                    ParseSrcFile     10            source file
     C                   parm                    ParseSrcLib      10            source lib
      *  optional parameters:
     C                   parm                    i_OvrSrcFile     10            override to src
     C                   parm                    i_Conditions    128            pre-def conditions
     C                   parm                    i_TgtRls         10            target release
      *
      *  get optional parameter: Overrride to Source File
     C                   if        %parms() >= 4
     C                   eval      OvrSrcFile = i_OvrSrcFile
     C                   else
     C                   eval      OvrSrcFile = ''
     C                   endif
      *
      *  get optional parameter: Conditions
     C                   if        %parms() >= 5
     C                   if        %subst(i_Conditions:1:32) <> ''
     C                   eval      cnd_array = loadConditions(i_Conditions)
     C                   eval      isPreDefCond = *on
     C                   else
     C                   eval      isPreDefCond = *off
     C                   endif
     C                   endif
      *
      *  get optional parameter: Target Release
     C                   if        %parms() >= 6
     C                   eval      TgtRls = i_TgtRls
     C                   else
     C                   eval      TgtRls = getCurrentRelease()
     C                   endif
      *
     C                   exsr      srValidate                                   make sure exist
      *
      * Set user selected library *first for remainder of program
     C                   eval      bldexc = 'RMVLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
     C                   eval      bldexc = 'ADDLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ') POSITION(*FIRST)'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
      *       CPF2103 - Library &1 already exists in library list.
     C                   if        %error and sds_msgID <> 'CPF2103'
     C                   eval      qm_msgtxt = '0000 ' + sds_msgText
     C                   exsr      srKill
     C                   endif
      *
      * Set variable &TOLIB
     C                   callp     setVariable('tolib': ParseSrcLib)
      *
      * Set variable &TGTRLS
     C                   callp     setVariable('tgtrls': TgtRls)
      *
      * Set variable &XMLFILE
     C                   callp     setVariable('xmlfile': ParseSrcFile)
      *
      * Set variable &XMLLIB
     C                   callp     setVariable('xmllib': ParseSrcFile)
      *
      * Set variable &XMLMBR
     C                   callp     setVariable('xmlmbr': ParseSrcFile)
      *
      * Override Input file to uploaded text file
     C                   eval      bldexc = 'OVRDBF FILE(XMLINPUT) TOFILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(ParseSrcFile) + ') MBR(' +
     C                             %trimr(ParseSrcMbr) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   open      xmlinput
     C                   read      xmlinput
     C                   dow       not %eof
      * write records to outfile if flag is on
     C                   select
     C                   when      write_flag = *on
     C                   if        xmltag2<>'</copysrc>'
     C                   eval      srcSeqno=srcSeqno+1
     C                   except    write_one
     C                   else
     C                   eval      write_flag=*off
     C                   close     qxxxsrc
     C                   endif
      *
      * Extract values based on xml tags.
     C                   when      xmltag1 = 'mbrname ='
     C                   eval      mbrname = %subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtype ='
     C                   eval      mbrtype =%subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtext ='
     C                   eval      mbrtext =dblQuotes(%subst(xmlcode:13:50))
     C                   when      xmltag1 = 'srcfile ='
     C                   if        OvrSrcFile <> ''
     C                   eval      srcfile =OvrSrcFile
     C                   else
     C                   eval      srcfile =%subst(xmlcode:13:10)
     C                   endif
     C                   when      xmltag1 = 'srclen  ='
     C                   eval      srclen  =%subst(xmlcode:13:5)
     C                   when      xmltag1 = 'srccssid='
     C                   eval      srccssid=%subst(xmlcode:13:5)
      *--------------------------------------------------------------------
      * Start of data to copy.  Create source files/mbrs as required.
      *--------------------------------------------------------------------
     C                   when      xmltag1='<copysrc>'
     C                   move      srclen        srclenN
      * crtsrcpf
     C                   eval      bldexc = 'CRTSRCPF FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') RCDLEN(' +
     C                             srclen + ') CCSID(' +
     C                             srccssid + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      * addpfm
     C                   eval      bldexc = 'ADDPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') SRCTYPE(' +
     C                             %trimr(mbrtype) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error
      * chgpfm
     C                   eval      bldexc = 'CHGPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
      * clr mbr
     C                   eval      bldexc = 'CLRPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      * ovr to outfile mbr
     C                   eval      bldexc = 'OVRDBF QXXXSRC ' +
     C                             %trimr(ParseSrcLib) + '/' +
     C                             %trimr(srcfile) + ' ' +
     C                             mbrname
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   clear                   srcSeqno
     C                   open      qxxxsrc
     C                   eval      write_flag = *on
      *--------------------------------------------------------------------
      * Compile statement.  Read next record and execute it.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<compile '
     C                   eval      condList= getAttrData('condition':xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('compile')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      *--------------------------------------------------------------------
      * qcmdexc statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qcmdexc '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      release  = getAttrData('release'
     C                                                    :xmlcode:'*CURRENT')
     C                   eval      dltsplf  = getAttrData('dltsplf'
     C                                                    :xmlcode:'*NONE')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('qcmdexc')
     C                   if        isCondition(condList) and
     C                             isRelease(tgtRls: release)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   if        %subst(bldexc: 1: 3) = 'DLT'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   else
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error()
     C                   eval      qm_msgtxt = '0000 Failed to execute: '+bldexc
     C                   exsr      srKill
     C                   endif
     C                   if        dltsplf <> '' and dltsplf <> '*NONE'
     C                   eval      bldexc = 'DLTSPLF FILE(' + dltsplf +
     C                                      ') JOB(*) SPLNBR(*LAST)'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
     C                   endif
     C                   endif
      *--------------------------------------------------------------------
      * SQL statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute SQL statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<execsql '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('execsql')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      srSQLExecute
     C                   endif
      *--------------------------------------------------------------------
      * Send messages to user as program executes
      * Extract message ID, Message Type, from <sendmsg>
      * read a record and get the single line of message text.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<sendmsg '
     C                   eval      qm_msgid = %subst(xmlcode:22:7)
     C                   eval      qm_msgtyp = %subst(xmlcode:46:10)
     C                   read      xmlinput
     C                   eval      qm_msgq   = '*EXT   '
     C                   eval      qm_msgtxt = xmlcode
     C                   exsr      srSndMessage
      *--------------------------------------------------------------------
      * rtvobjd statement. retrieve object description of the specified
      * object. Store attributes in specified fields.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<rtvobjd '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('rtvobjd')
     C                   eval      objd_obj    =getAttrData('obj'    :bldexc:'')
     C                   eval      objd_lib    =getAttrData('lib'    :bldexc:'')
     C                   eval      objd_objtype=getAttrData('objtype':bldexc:'')
     C                   eval      objd_rtnlib =getAttrData('rtnlib' :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srRtvObjD
     C                   endif
      *--------------------------------------------------------------------
      * chgvar statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<chgvar  '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('chgvar')
     C                   eval      var_name  = getAttrData('var'    :bldexc:'')
     C                   eval      var_value = getAttrData('value'  :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srChgVar
     C                   endif
      *--------------------------------------------------------------------
      * Query condition
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qrycond '
     C                   eval      bldexc = readElement('qrycond')
     C                   eval      cnd_msg = getAttrData('msg'   : bldexc: '')
     C                   eval      cnd_values = getAttrData('values': bldexc:'')
     C                   eval      cnd_var = getAttrData('var': bldexc: '*NONE')
     C                   exsr      srQueryCond
     C                   endsl
      *
     C                   read      xmlinput
     C                   enddo
      *
     C                   exsr      srSQLEnd
     C                   eval      *inlr=*on
     C                   return
      *--------------------------------------------------------------------
      * Replace variable names with their associated values.
      *--------------------------------------------------------------------
     C     RplVars       begsr
     C                   eval      aa=%scan('&':bldexc)
     C                   dow       aa>0
     C                   eval      var_name=getVarName(bldexc:aa)
     C                   eval      var_value=getVarValue(var_name)
     C                   eval      bldexc=%replace(var_value:bldexc:aa
     C                                             :%len(var_name))
     C                   eval      aa=%scan('&':bldexc)
     C                   enddo
     C                   endsr
      *--------------------------------------------------------------------
      * Sets the target release according to the optional parameter
      * i_TgtRls.
      *--------------------------------------------------------------------
     C     SetTgtRls     begsr
     C                   if        TgtRls = getCurrentRelease()
     C                   leavesr
     C                   endif
     C                   eval      bldexc =
     C                                setTargetRelease('TGTRLS': bldexc: TgtRls)
     C                   endsr
      *--------------------------------------------------------------------
      * Check of file, lib, member exist.
      *--------------------------------------------------------------------
     C     srValidate    begsr
     C                   callp     QUSRMBRD(
     C                             vrcvar:
     C                             145:
     C                             'MBRD0100':
     C                             ParseSrcFile + ParseSrcLib:
     C                             ParseSrcMbr:
     C                             '0':
     C                             errCode)
      *   --------------------------------------------------------------------------------
      *   If error occurred on call, send appropriate message back to user.
      *   ---------------------------------------------------------------------------------
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   select
      * lib not found
     C                   when      errCode_excID = 'CPF9810'
     C                   eval      qm_msgtxt = '0000 Library ' +
     C                             %trimr(ParseSrcLib) + ' was not found.'
      * src file not found
     C                   when      errCode_excID = 'CPF9812'
     C                   eval      qm_msgtxt = '0000 Source file ' +
     C                             %trimr(ParseSrcFile)+' was not found in ' +
     C                             %trimr(ParseSrcLib) + '.'
      * member not found
     C                   when      errCode_excID = 'CPF9815'
     C                   eval      qm_msgtxt = '0000 Member ' +
     C                             %trimr(ParseSrcMbr)+' was not found in ' +
     C                             %trimr(ParseSrcLib)+'/'+ %trimr(ParseSrcFile)
      * unexpected
     C                   other
     C                   eval      qm_msgtxt = '0000 Unexpected message ' +
     C                             errCode_excID + ' received. '
     C                   endsl
      * send message
     C                   exsr      srKill
     C                   eval      *inlr=*on
     C                   return
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * kill application
      *--------------------------------------------------------------------
     C     srKill        begsr
     C                   eval      qm_msgid  = 'CPD0006'
     C                   eval      qm_msgtyp = '*DIAG'
     C                   eval      qm_msgq   = '*CTLBDY'
     C                   exsr      srSndMessage
     C                   eval      qm_msgtxt = *blanks
     C                   eval      qm_msgid  = 'CPF0002'
     C                   eval      qm_msgtyp = '*ESCAPE'
     C                   exsr      srSndMessage
     C                   endsr
      *--------------------------------------------------------------------
      * call send program message api
      *--------------------------------------------------------------------
     C     srSndMessage  begsr
     C                   callp     QMHSNDPM(
     C                             qm_msgid:
     C                             'QCPFMSG   *LIBL     ':
     C                             qm_msgtxt:
     C                             %size(qm_msgtxt):
     C                             qm_msgtyp:
     C                             qm_msgq:
     C                             1:
     C                             '    ':
     C                             errCode)
     C                   endsr
      *--------------------------------------------------------------------
      * retrieve object description and store attributes
      *--------------------------------------------------------------------
     C     srRtvObjD     begsr
     C                   callp     QUSROBJD(objd0100
     C                                      : %size(objd0100)
     C                                      : 'OBJD0100'
     C                                      : objd_obj + objd_lib
     C                                      : objd_objtype
     C                                      : errCode)
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   eval      qm_msgtxt = '0000 Failed to retrieve +
     C                             object description of object ' +
     C                             %trim(objd_lib) + '/' + %trim(objd_obj) +
     C                             ' type ' + %trim(objd_objtype) + '.'
      * send message
     C                   exsr      srKill
     C                   else
     C                   callp     setVariable(objd_rtnlib: od_rtnlib)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * change variable
      *--------------------------------------------------------------------
     C     srChgVar      begsr
     C                   callp     setVariable(var_name: var_value)
     C                   endsr
      *--------------------------------------------------------------------
      * execute SQL statement.
      *--------------------------------------------------------------------
     C     srSQLExecute  begsr
     C                   exsr      srSQLInit
     C                   Eval      retCode = SQLExecDirect(hstmt    :
     C                                                     bldexc   :
     C                                                     SQL_NTS  )
     C                   endsr
      *--------------------------------------------------------------------
      * query condition.
      *--------------------------------------------------------------------
     C     srQueryCond   begsr
     C                   if        isPreDefCond = *off
     C                   eval      cnd_values = uCase(cnd_values)
     C                   dou       (%scan(cnd_rtnVal: cnd_values) > 0) and
     C                             (cnd_rtnval <> ''                 )
     C                   eval      cnd_rtnval = ' '
     C     cnd_msg       dsply                   cnd_rtnval
     C                   eval      cnd_rtnVal = uCase(cnd_rtnVal)
     C                   enddo
     C                   eval      cnd_ptr = cnd_ptr + 1
     C                   eval      cnd_array(cnd_ptr) = cnd_rtnVal
     C                   endif
     C                   if        (cnd_var <> '*NONE')
     C                   callp     setVariable(cnd_var: cnd_rtnval)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * initialize SQL.
      *--------------------------------------------------------------------
     C     srSQLInit     begsr
      *
     C                   if        sqlInit = *off
     C                   Eval      retCode = SQLAllocEnv(%addr(henv))
     C                   Eval      retCode = SQLAllocConnect(henv: %addr(hdbc))
     C                   Eval      retCode = SQLConnect(hdbc      :
     C                                                  '*LOCAL'  :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   )
     C                   Eval      cOptVal = SQL_COMMIT_NONE
     C                   Eval      retCode = SQLSetConnectOption(hdbc          :
     C                                                          SQL_ATTR_COMMIT:
     C                                                          %addr(cOptVal) )
     C                   Eval      retCode = SQLAllocStmt(hdbc       :
     C                                                  %addr(hstmt) )
     C                   eval      sqlInit = *on
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * end SQL.
      *--------------------------------------------------------------------
     C     srSQLEnd      begsr
     C                   if        sqlInit = *on
     C                   Eval      retCode = SQLFreeStmt(hstmt    :
     C                                                   SQL_DROP )
     C                   Eval      retCode = SQLDisconnect(hdbc)
     C                   Eval      retCode = SQLFreeConnect(hdbc)
     C                   Eval      retCode = SQLFreeEnv(henv)
     C                   eval      sqlInit = *off
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * error handler
      *--------------------------------------------------------------------
     C     *pssr         begsr
     C                   if        errFLag = *off
     C                   eval      errFlag = *on
     C                   exsr      srSQLEnd
     C                   endif
     C                   endsr     '*CANCL'
     Oqxxxsrc   e            write_one
     O                       srcSeqno             6
     O                                           12 '000000'
     O                       xmlcode            112
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     P readElement...
     P                 B
     D                 PI                        like(bldexc)
     D  i_element                     9A   value varying
      *
     D i               S             10I 0 inz
     D value           S                   like(bldexc ) inz
     D endTag          S                   like(xmlTag2) inz
      *
     C                   eval      i = 1
     C                   eval      endTag = '</' + i_element + '>'
     C                   dow       xmltag2 <> endTag
     C                   eval      %subst(value: i: %len(xmlcode)) = xmlcode
     C                   eval      i = i + %len(xmlcode)
     C                   read      xmlinput
     C                   enddo
      *
     C                   Return    value
      *
     P                 E
      *--------------------------------------------------------------------
      * Double quotes
      *--------------------------------------------------------------------
     P dblQuotes...
     P                 B
     D                 PI          2048A         varying
     D  i_string                   2048A   value varying
      *
     D x               S             10I 0         inz
     D string          S           2048A   varying inz
      *
     C                   For       x = 1 to %len(i_string)
     C                   Eval      string = string + %subst(i_string: x:1)
     C                   If        %subst(i_string: x : 1) = qs
     C                   Eval      string = string + qs
     C                   Endif
     C                   Endfor
      *
     C                   Return    string
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get Attribute Data from String
      *---------------------------------------------------------------------------------------------
     P getAttrData...
     P                 B
     D                 PI          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *
      *  return value
     D attrData        S           2000A   varying inz                          like(string_t)
      *
      *  local fields
     D attr            S             20a   varying inz
     D lenAttr         S             10i 0 inz
     D aa              S             10i 0 inz
     D cc              S             10i 0 inz
      *
     D Qd              C                   const('"')
      *-------------------------------------------------------------------*
      *
      *  find the keyword
     C                   eval      attr = %trim(i_attr) + '=' + Qd
      *
     C                   eval      aa   = %scan(attr: i_string)
     C                   if        aa = 0
     C                   return    i_default
     C                   endif
      *
     C                   eval      aa   = aa + %len(attr)
     C                   eval      cc   = %scan(Qd: i_string: aa+1)
      *
      *  return the data between the double-quotes
     C                   if        (cc-aa) > 0
     C                   eval      attrData = %subst(i_string: aa: cc-aa)
     C                   endif
      *
     C                   Return    attrData
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Load condition array
      *---------------------------------------------------------------------------------------------
     P loadConditions...
     P                 B
     D                 PI                  dim(32) like(condition)
     D  i_conditions                128A   value
      *
      *  return value
     D cnd_array       s                   dim(32) inz like(condition)
     D pValue          s               *   inz
     D x               s             10i 0 inz
     D i               s             10i 0 inz
     D cnd_value       s            128a   varying
     D var_name        s             64a   varying
     D var_value       s             64a   varying
      *-------------------------------------------------------------------*
      /FREE

         i_conditions = uCase(i_conditions);

         pValue = strtok(i_conditions: ';');
         dow (pValue <> *null);
            x = x + 1;
            cnd_value = %str(pValue);
            i = %scan('=': cnd_value);
            if (i = 0);
               cnd_array(x) = cnd_value;
            else;
               var_name = %subst(cnd_value: 1: i-1);
               if (%subst(var_name: 1: 1) = '&');
                  var_name = %subst(var_name: 2);
               endif;
               var_value = %subst(cnd_value: i+1);
               setVariable(var_name: var_value);
               cnd_array(x) = var_value;
            endif;
            pValue = strtok(*null: ';');
         enddo;

         return cnd_array;
      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check for a condition
      *---------------------------------------------------------------------------------------------
     P isCondition...
     P                 B
     D                 PI              n
     D  i_condList                 2000A   value
      *
      *  return value
     D isCondition     S               n   inz
     D pValue          S               *   inz
     D aCondition      S             10a   inz
      *-------------------------------------------------------------------*
      *
     C                   eval      i_condList = uCase(i_condList)
      *
     C                   if        (i_condList = '*NONE')  or
     C                             (i_condList = ''     )
     C                   eval      *in01 = *on
     C                   else
      *
     C                   eval      pValue = strtok(i_condList: ' ')
     C                   dow       pValue <> *null
     C                   eval      aCondition = %str(pValue)
     C     aCondition    lookup    cnd_array                              01
     C                   if        not *in01
     C                   leave
     C                   endif
     C                   eval      pValue = strtok(*null     : ' ')
     C                   enddo
      *
     C                   endif
      *
     C                   if        *in01
     C                   eval      isCondition = *on
     C                   else
     C                   eval      isCondition = *off
     C                   endif
      *
     C                   Return    isCondition
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get the current release level of the operation system
      *---------------------------------------------------------------------------------------------
     P getCurrentRelease...
     P                 B
     D                 PI            10A
      *
      *  QSZRTVPR API
     D QSZRTVPR...
     D                 PR                  extpgm('QSZRTVPR')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  o_prodInf                 65535A   const  options(*varsize)
     D  io_errCode                65535A          options(*varsize)
      *
     D prdi0100        DS                  qualified
     D  productID              1      7A   inz('*OPSYS')
     D  releaseLvl             8     13A   inz('*CUR'  )
     D  productOpt            14     17A   inz('0000'  )
     D  loadID                18     27A   inz('*CODE' )
      *  Shortened!:
     D prdr0100        DS                  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     12I 0
     D  productID             13     19A
     D  releaseLvl            20     25A
      *  API error code
     D errCode         DS
     D  bytPrv                       10i 0 inz(0)
     D  bytAvl                       10i 0 inz(0)
      *-------------------------------------------------------------------*
      *
     C                   Callp     QSZRTVPR(prdr0100: %size(prdr0100):
     C                                      'PRDR0100': prdi0100: errCode)
     C                   Return    prdr0100.releaseLvl
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check the release level
      *---------------------------------------------------------------------------------------------
     P isRelease...
     P                 B
     D                 PI              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *
      *  return value
     D isRelease       S               n   inz(*off)
      *  Release
     D release         DS
     D  r_operator             1      3a
     D  r_space                4      4a
     D  r_level                5     10a
      *-------------------------------------------------------------------*
      *
     C                   If        i_release = '*CURRENT'
     C                   Eval      isRelease = *on
     C                   Else
     C                   Eval      release = i_release
     C                   Select
     C                   When      r_operator = '*LT' and
     C                             i_os_release < r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*EQ' and
     C                             i_os_release = r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GT' and
     C                             i_os_release > r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*LE' and
     C                             i_os_release <= r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GE' and
     C                             i_os_release >= r_level
     C                   Eval      isRelease = *on
     C                   Other
     C                   Eval      isRelease = *off
     C                   Endsl
     C                   Endif
      *
     C                   Return    isRelease
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Replaces the value of a given keyword.
      *---------------------------------------------------------------------------------------------
     P setTargetRelease...
     P                 B
     D                 PI          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *
      *  return value
     D string          S           2000A   varying inz
      *
      *  helper fields
     D x               S             10I 0 inz
     D l               S             10I 0 inz
     D tmpKeyword      S                   like(i_keyword) inz
     D tmpString       S                   like(i_string ) inz
     D tmpCmd          S             10A   inz
      *-------------------------------------------------------------------*
      /FREE

         tmpKeyword = uCase(%trimR(i_keyword));
         tmpString  = uCase(%trimR(i_string ));
         x = %scan(' ': tmpString);
         if x = 0;
            return i_string;
         endif;
         tmpCmd = %subst(tmpString: 1: x);
         if tmpCmd <> 'CRTRPGMOD' and
            tmpCmd <> 'CRTRPGPGM' and
            tmpCmd <> 'CRTCLMOD'  and
            tmpCmd <> 'CRTCLPGM'  and
            tmpCmd <> 'CRTCBLMOD' and
            tmpCmd <> 'CRTCBLPGM' and
            tmpCmd <> 'CRTCMOD'   and
            tmpCmd <> 'CRTCPPMOD' and
            tmpCmd <> 'CRTBNDC'   and
            tmpCmd <> 'CRTBNDCBL' and
            tmpCmd <> 'CRTBNDCL'  and
            tmpCmd <> 'CRTBNDCPP' and
            tmpCmd <> 'CRTBNDDIR' and
            tmpCmd <> 'CRTBNDRPG' and
            tmpCmd <> 'CRTPGM'    and
            tmpCmd <> 'CRTSRVPGM' ;
            return i_string;
         endif;
         x = %scan(tmpKeyword + '(': tmpString);
         if x = 0;
            return %trimR(i_string) +
                   ' ' + tmpKeyword + '(' + %trimR(i_value) + ')';
         endif;
         l = %scan(')': tmpString: x + %len(i_keyword) + 1);
         if l = 0;
            return i_string;
         endif;
         l = l - x + 1;
         string = %replace(tmpKeyword + '(' + %trimR(i_value) + ')'
                           : i_string: x: l);
         Return string;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Store field value.
      *---------------------------------------------------------------------------------------------
     P setVariable...
     P                 B
     D                 PI
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
     D i               s             10I 0 inz
      *-------------------------------------------------------------------*
      /FREE

         if (i_fldName = '');
            return;
         endif;

         for i = 1 to fld_x;
            if (uCase('&' + %trim(i_fldName)) = uCase(fld_name(i)));
               fld_value(i) = i_value;
               return;
            endif;
         endfor;

         if (fld_x >= %elem(fld_name));
            return;
         endif;

         fld_x = fld_x + 1;
         fld_name(fld_x)  = uCase('&' + %trim(i_fldName));
         fld_value(fld_x) = i_value;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable name from statement.
      *---------------------------------------------------------------------------------------------
     P getVarName...
     P                 B
     D                 PI            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
     D name            s             11a   varying inz
     D CHARS           c                   '&ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                      abcdefghijklmnopqrstuvwxyz+
     D                                      1234567890_'
      *-------------------------------------------------------------------*
      /FREE

         dow (i_pos<=%len(i_bldexc) and
              %check(CHARS:%subst(i_bldexc:i_pos:1))=0);
            name = name+%subst(i_bldexc:i_pos:1);
            i_pos=i_pos+1;
         enddo;

         return name;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable value.
      *---------------------------------------------------------------------------------------------
     P getVarValue...
     P                 B
     D                 PI            64a          varying
     D  i_name                       11a   value  varying
     D i               s             10i 0 inz
     D value           s             64a   varying inz('?')
      *-------------------------------------------------------------------*
      /FREE

         for i=1 to fld_x;
            if (ucase(fld_name(i))=uCase(i_name));
               value=%trimR(fld_value(i));
               leave;
            endif;
         endfor;

         return value;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  convert to upper case
      *---------------------------------------------------------------------------------------------
     P uCase...
     P                 B
     D                 PI          2000A          varying
     D  i_string                   2000A   value  varying
     D uCase           s           2000A   inz varying
     D LC              C                   const('abcdefghijklmnopqrstuvwxyz')
     D UC              C                   CONST('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      *-------------------------------------------------------------------*
      /FREE

         uCase = %xlate(LC:UC:i_string);

         return uCase;

      /END-FREE
     P                 E
      * /// END   OF INSTALL PGM HERE   ****************************************** ///
      * /// do not copy past this point ///
]]>  </install_program>
<chgvar   condition="*NONE" var="SRCFILE" value="QWHOAMI">
<![CDATA[
]]>  </chgvar>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_INSTALL  type CLLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_INSTALL "
mbrtype =  "CLLE      "
mbrtext =  "Whoami - Installer                                "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* =================================================================== */
     /*                                                                     */
     /*  Documentation:                                                     */
     /*                                                                     */
     /*  Utility . . . : WHOAMI                                             */
     /*  Object  . . . : A_INSTALL  (PGM)                                   */
     /*  Source member : A_INSTALL                                          */
     /*  Source type . : CLLE                                               */
     /*  Description   : Whoami - Installer                                 */
     /*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      */
     /*  Created . . . : 25.01.2017                                         */
     /*                                                                     */
     /* =================================================================== */
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /* =================================================================== */
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          nderung                                 */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /* =================================================================== */
     /*   >>PRE-COMPILER<<                                                  */
     /*     >>CRTCMD<<    CRTBNDCL  PGM(QTEMP/&OB) +                        */
     /*                             SRCFILE(&SL/&SF) SRCMBR(&SM);           */
     /*     >>IMPORTANT<<                                                   */
     /*       >>PARM<<    OPTION(*EVENTF);                                  */
     /*     >>END-IMPORTANT<<                                               */
     /*     >>EXECUTE<<                                                     */
     /*     >>CMD<<       CALL   PGM(QTEMP/A_INSTALL) +                     */
     /*                          PARM('*CURRENT' '&SF' '&LI');              */
     /*     >>CMD<<       DLTPGM PGM(QTEMP/A_INSTALL);                      */
     /*   >>END-PRE-COMPILER<<                                              */
     /* =================================================================== */
             PGM        PARM(&TGTRLS &SRCFILE &TOLIB)

             DCL        VAR(&TGTRLS   ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&SRCFILE  ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&TOLIB    ) TYPE(*CHAR) LEN(10)

             DCL        VAR(&SRCLIB   ) TYPE(*CHAR) LEN(10)

             CHGVAR     VAR(&SRCLIB) VALUE(&TOLIB   )

     /* -------------------------------- */
     /*  Delete old objects              */
     /* -------------------------------- */
             DLTPNLGRP  PNLGRP(&TOLIB/WHOAMIP)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/WHOAMICPP)
             MONMSG     MSGID(CPF2105)

             DLTCMD     CMD(&TOLIB/WHOAMI)
             MONMSG     MSGID(CPF2105)

     /* -------------------------------- */
     /*  Create programs                 */
     /* -------------------------------- */
             CRTBNDRPG  PGM(&TOLIB/WHOAMICPP) +
                          SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(*PGM) +
                          DBGVIEW(*LIST) TRUNCNBR(*NO) +
                          DFTACTGRP(*NO) ACTGRP(*NEW) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(WHOAMICPP) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create panel groups             */
     /* -------------------------------- */
             CRTPNLGRP  PNLGRP(&TOLIB/WHOAMIP) +
                          SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(*PNLGRP)
             DLTSPLF    FILE(WHOAMIP  ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create commands                 */
     /* -------------------------------- */
             CRTCMD     CMD(&TOLIB/WHOAMI) PGM(&TOLIB/WHOAMICPP) +
                          SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(*CMD) +
                          HLPPNLGRP(&TOLIB/WHOAMIP) HLPID(WHOAMI)
             DLTSPLF    FILE(WHOAMI   ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

             ENDPGM
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_README  type TXT - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_README  "
mbrtype =  "TXT       "
mbrtext =  "WHOAMI Readme                                     "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
WHOAMI - A tools400 Utility
---------------------------

WHOAMI is a CL command that displays job and workstation attributes
when executed on a IBM i (AS/400) command line.

The attributes displayed are:

   User name
   System name
   Device name
   TCP/IP address

The utility uses the following APIs:

   Retrieve Device Description (QDCRDEVD) API
   Retrieve Network Attributes (QWCRNETA) API

It uses the name of the job that called WHOAMI as the devices name
for the QDCRDEVD API, because for interactive jobs the job name
equals the device name.

Compile members with the following PDM option:

   STRPREPRC USESRCFILE(&L/&F) USESRCMBR(&N) OPTION(*EVENTF) CHGOBJD(*NO)
     LIB(&O) OBJ(&N) SRCLIB(&L) SRCFILE(&F) SRCMBR(&N) USER0(&X)
     USER1(*LIST) USER2(*FULL)

Members of type MAKPGM or BND are used for linking programs (MAKPGM)
and service programs (BND).

2018, Thomas Raddatz
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing COPYRIGHT  type CLLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "COPYRIGHT "
mbrtype =  "CLLE      "
mbrtext =  "Copyright information                             "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
**free
      /if not defined(COPYRIGHT_DSPEC)
       ctl-opt copyright('V1.1 - 16.01.2019 - mailto: thomas.raddatz@tools400.de');
      /eof
      /endif
       dcl-c WHOAMI_VERSION '1.1.0';
       dcl-c WHOAMI_DATE    '16.01.2019';
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing WHOAMI  type CMD - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "WHOAMI    "
mbrtype =  "CMD       "
mbrtext =  "Who am I                                          "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* =================================================================== */
     /*                                                                     */
     /*  Documentation:                                                     */
     /*                                                                     */
     /*  Utility . . . : WHOAMI                                             */
     /*  Object  . . . : WHOAMI     (*CMD)                                  */
     /*  Source member : WHOAMIC1                                           */
     /*  Source type . : CMD                                                */
     /*  Description   : Who am I                                           */
     /*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      */
     /*  Created . . . : 25.01.2017                                         */
     /*                                                                     */
     /* =================================================================== */
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /* =================================================================== */
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          Change                                   */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /* =================================================================== */
     /* STRPREPRC Compile Options:                                          */
     /*   >>PRE-COMPILER<<                                                  */
     /*     >>CRTCMD<<    CRTCMD   CMD(&LI/WHOAMI) +                        */
     /*                              SRCFILE(&SL/&SF) SRCMBR(&SM);          */
     /*     >>IMPORTANT<<                                                   */
     /*         >>PARM<<   PGM(&LI/WHOAMI);                                 */
     /*         >>PARM<<   HLPPNLGRP(&LI/WHOAMI);                           */
     /*         >>PARM<<   HLPID(WHOAMI);                                   */
     /*     >>END-IMPORTANT<<                                               */
     /*     >>EXECUTE<<                                                     */
     /*   >>END-PRE-COMPILER<<                                              */
     /* =================================================================== */
             CMD        PROMPT('Who am I?')
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing WHOAMIP  type PNLGRP - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "WHOAMIP   "
mbrtype =  "PNLGRP    "
mbrtext =  "Who am I - Help                                   "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
.* =================================================================== *
.*                                                                     *
.*  Documentation:                                                     *
.*                                                                     *
.*  Utility . . . : WHOAMI                                             *
.*  Object  . . . : WHOAMI     (*PNLGRP)                               *
.*  Source member : WHOAMIH1                                           *
.*  Source type . : PNLGRP                                             *
.*  Description   : Who am I - Help                                    *
.*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      *
.*  Created . . . : 25.01.2017                                         *
.*                                                                     *
.* =================================================================== *
.*                                                                     *
.*  This software is free software, you can redistribute it and/or     *
.*  modify it under the terms of the GNU General Public License (GPL)  *
.*  as published by the Free Software Foundation.                      *
.*                                                                     *
.*  See GNU General Public License for details.                        *
.*          http://www.opensource.org                                  *
.*          http://www.opensource.org/licenses/gpl-license.html        *
.*                                                                     *
.* =================================================================== *
.*  STRPREPRC Compile Options:                                         *
.*    >>PRE-COMPILER<<                                                 *
.*      >>CRTCMD<<    CRTPNLGRP  PNLGRP(&LI/WHOAMI) +                  *
.*                               SRCFILE(&SL/&SF) SRCMBR(&SM);         *
.*      >>IMPORTANT<<                                                  *
.*        >>PARM<<    OPTION(*EVENTF);                                 *
.*      >>END-IMPORTANT<<                                              *
.*      >>EXECUTE<<                                                    *
.*    >>END-PRE-COMPILER<<                                             *
.* =================================================================== *
:PNLGRP.
.*
:HELP name='WHOAMI/ALL'.
:EHELP.
.*--------------------------------------------------------------------
.* Command help text
.*--------------------------------------------------------------------
:HELP NAME='WHOAMI'.
Who am I? (WHOAMI) - Help
:P.
The WHOAMI command retrieves and displays information about the current
thread:
.*
:LINES.
User    - The user profile under which the job is run.
System  - The current system name.
Device  - The name of the 5250 device.
IP      - TCP/IP address in dotted decimal form.
:ELINES.
:P.
An information message is send to the command line.
.*
:EHELP.
:EPNLGRP.
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing WHOAMIR1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "WHOAMIR1  "
mbrtype =  "RPGLE     "
mbrtext =  "Who am I - CPP                                    "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
**free
// =================================================================== *
//                                                                     *
//  Documentation:                                                     *
//                                                                     *
//  Utility . . . : WHOAMI                                             *
//  Object  . . . : WHOAMIM1   (*MODULE)                               *
//  Source member : WHOAMIC1                                           *
//  Source type . : RPGLE                                              *
//  Description   : Who am I - CPP                                     *
//  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      *
//  Created . . . : 25.01.2017                                         *
//                                                                     *
// =================================================================== *
//                                                                     *
//  This software is free software, you can redistribute it and/or     *
//  modify it under the terms of the GNU General Public License (GPL)  *
//  as published by the Free Software Foundation.                      *
//                                                                     *
//  See GNU General Public License for details.                        *
//          http://www.opensource.org                                  *
//          http://www.opensource.org/licenses/gpl-license.html        *
//                                                                     *
// =================================================================== *
//  History:                                                           *
//                                                                     *
//  Datum       Name          Change                                   *
//  ----------  ------------  ---------------------------------------  *
//                                                                     *
// =================================================================== *
// STRPREPRC Compile Options:                                          *
//   >>PRE-COMPILER<<                                                  *
//     >>CRTCMD<<    CRTRPGMOD  MODULE(&LI/&OB) +                      *
//                              SRCFILE(&SL/&SF) SRCMBR(&SM);          *
//     >>IMPORTANT<<                                                   *
//       >>PARM<<    TRUNCNBR(*NO);                                    *
//       >>PARM<<    DBGVIEW(*LIST);                                   *
//       >>PARM<<    OPTION(*EVENTF);                                  *
//     >>END-IMPORTANT<<                                               *
//     >>EXECUTE<<                                                     *
//   >>END-PRE-COMPILER<<                                              *
// =================================================================== *

ctl-opt main(main);
ctl-opt debug(*yes);
      /if defined(CRTBNDRPG)
       ctl-opt dftactgrp(*no) actgrp(*new);
/endif
/include QWHOAMI,COPYRIGHT

// Send Program Message (QMHSNDPM) API
dcl-pr QMHSNDPM extpgm('QMHSNDPM');
   i_msgId       char(7)     const;
   i_qMsgF       char(20)    const;
   i_msgData     char(32768) options(*varsize) const;
   i_lenMsgData  int(10)     const;
   i_msgType     char(10)    const;
   i_callStkE    char(10)    const;
   i_callStkC    int(10)     const;
   o_msgKey      char(4);
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

// Retrieve Device Description (QDCRDEVD) API
dcl-pr QDCRDEVD extpgm('QDCRDEVD');
   o_rcvVar      char(37767) options(*varsize);
   i_lenRcv      int(10)     const;
   i_format      char(8)     const;
   i_device      char(10)    const;
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

dcl-ds devd0600_t qualified template;
   bytRet          int(10)   pos(1);
   bytAvl          int(10)   pos(5);
   dateInfRtv      char(7)   pos(9);
   timeInfRtv      char(6)   pos(16);
   devName         char(10)  pos(22);
   decCategory     char(10)  pos(32);
   onlineAtIPL     char(10)  pos(42);
   text            char(51)  pos(51);
   reserved_1      char(3)   pos(102);
   graphCharSet    int(10)   pos(105);
   codePage        int(10)   pos(109);
   maxLenReqU      int(10)   pos(113);
   inactTimer      int(10)   pos(117);
   dbcsRamSize     int(10)   pos(121);
   actTimer        int(10)   pos(125);
   swsSetting      int(10)   pos(129);
   devPort         int(10)   pos(133);
   maxOutFrms      int(10)   pos(137);
   idlTimer        int(10)   pos(141);
   nrmPollTimer    int(10)   pos(145);
   frmRetry        int(10)   pos(149);
   ofsAuxDev       int(10)   pos(153);
   numAuxDev       int(10)   pos(157);
   lenAuxDev       int(10)   pos(161);
   devClass        char(10)  pos(165);
   devType         char(10)  pos(175);
   devModel        char(10)  pos(185);
   lclLocAddr      char(10)  pos(195);
   attNonSwsCtrl   char(10)  pos(205);
   keybLngType     char(10)  pos(215);
   dropLineAtSnO   char(10)  pos(225);
   alwBlkCrs       char(10)  pos(235);
   prtDev          char(10)  pos(245);
   rmtLocName      char(10)  pos(255);
   lclLocName      char(10)  pos(265);
   rmtNetworkID    char(10)  pos(275);
   ctrlSessDevD    char(10)  pos(285);
   acoPrtName      char(10)  pos(295);
   acoPrtRmtNtID   char(10)  pos(305);
   altPrtName      char(10)  pos(315);
   altPrtRmtNtID   char(10)  pos(325);
   outQName        char(10)  pos(335);
   outQLib         char(10)  pos(345);
   printer         char(10)  pos(355);
   prtFName        char(10)  pos(365);
   prtFLib         char(10)  pos(375);
   wsCstObjName    char(10)  pos(385);
   wsCstObjLib     char(10)  pos(395);
   applType        char(10)  pos(405);
   dbcsMtxSize     char(10)  pos(415);
   dbcsLangID      char(10)  pos(425);
   dbcsLastCdePt   char(10)  pos(435);
   snaPassThrDev   char(10)  pos(445);
   snaPassThrGrp   char(10)  pos(455);
   emlDev          char(10)  pos(465);
   emlModel        char(10)  pos(475);
   emlAscDev       char(10)  pos(485);
   physAttach      char(10)  pos(495);
   lineSpeed       char(10)  pos(505);
   wordLength      char(10)  pos(515);
   parityType      char(10)  pos(525);
   stopBits        char(10)  pos(535);
   ascTerminalID   char(20)  pos(545);
   acoAppcDev      char(10)  pos(565);
   hostSignonCmd   char(256) pos(575);
   passThrID       char(1)   pos(831);
   autoCfg         char(10)  pos(832);
   reserved_2      char(3)   pos(842);
   shrdSessNbr     int(10)   pos(845);
   depLocName      char(10)  pos(849);
   netwProt        char(1)   pos(859);
   netwProtAddr    char(18)  pos(860);
   tcpIpDotAddr    char(15)  pos(878);
   alcByJobName    char(10)  pos(893);
   alcByUserName   char(10)  pos(903);
   alcByJobNbr     char(6)   pos(913);
   curMsgQName     char(10)  pos(919);
   curMsgQLib      char(10)  pos(929);
   svrNetwProt     char(1)   pos(939);
   svrNetwProtAddr char(18)  pos(940);
   svrTcpIpDotAddr char(15)  pos(958);
end-ds;

// Retrieve Network Attributes (QWCRNETA) API
dcl-pr QWCRNETA extpgm('QWCRNETA');
   o_rcvVar      char(37767) options(*varsize);
   i_lenRcv      int(10)     const;
   i_numAttr     int(10)     const;
   i_attrNames   char(10) dim(50)  options(*varsize) const;
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

dcl-ds QWCRNETA_returned_t qualified template;
   numE          int(10);
   offsAttr      int(10);
end-ds;

dcl-ds QWCRNETA_attr_t qualified template;
   name          char(10);
   type          char(1);
   status        char(1);
   length        int(10);
   data_char     char(256);
   data_bin      int(10) overlay(data_char);
end-ds;

dcl-c QWCRNETA_TYPE_NONE '';
dcl-c QWCRNETA_TYPE_CHAR 'C';
dcl-c QWCRNETA_TYPE_BIN 'B';

dcl-c QWCRNETA_STATUS_OK '';
dcl-c QWCRNETA_STATUS_LOCKED 'L';

// IBM API error structure
dcl-ds errCode_t qualified template;
   bytPrv        int(10);
   bytAvl        int(10);
   excId         char(7);
   reserved      char(1);
   excData       char(512);
end-ds;

// IBM qualified object name
dcl-ds qObj_t qualified template;
   name          char(10);
   lib           char(10);
end-ds;

// Program status information data structure
dcl-ds sds PSDS qualified;
   pgmName       char(10) pos(1);
   pgmStat       zoned(5) pos(11);
   prevStat      zoned(5) pos(16);
   lastSeq       char(8)  pos(21);
   lastSubr      char(8)  pos(29);
   nbrParm       zoned(3) pos(37);
   excType       char(3)  pos(40);
   excNbr        char(4)  pos(43);
   miInstruction char(4)  pos(47);
   workArea      char(30) pos(51);
   pgmLib        char(10) pos(81);
   excData       char(80) pos(91);
   rnx9001Exc    char(4)  pos(171);
   lastFileLong  char(10) pos(175);
   unused_1      char(6)  pos(185);
   datFmt        char(8)  pos(191);
   year          zoned(2) pos(199);
   lastFileShort char(8)  pos(201);
   fileStat      char(35) pos(209);
   job           char(10) pos(244);
   user          char(10) pos(254);
   nbr           char(6)  pos(264);
   startDate     zoned(6) pos(270);
   runDate       zoned(6) pos(276);
   runTime       zoned(6) pos(282);
   compDate      char(6)  pos(288);
   compTime      char(6)  pos(294);
   compLevel     char(4)  pos(300);
   srcFile       char(10) pos(304);
   srcLib        char(10) pos(314);
   srcMbr        char(10) pos(324);
   pgmContProc   char(10) pos(334);
   modContProc   char(10) pos(344);
   sourceID1     int(5)   pos(354);
   sourceID2     int(5)   pos(356);
   currUser      char(10) pos(358);
   unused_2      char(62) pos(368);
end-ds;

// =================================================================== *
//   Main procedure                                                    *
// =================================================================== *
dcl-proc main;
   dcl-pi *n end-pi;

   // IBM API error structure:
   dcl-ds errCode likeds(errCode_t) inz;

   // QWCRNETA fields:
   dcl-s QWCRNETA_rcvBuff char(300);
   dcl-ds QWCRNETA_returned likeds(QWCRNETA_returned_t) based(pQWCRNETA_returned);
   dcl-ds QWCRNETA_attr likeds(QWCRNETA_attr_t) based(pQWCRNETA_attr);
   dcl-s QWCRNETA_attrs char(10) dim(1);

   dcl-s sysName char(10);

   // Retrieve Device Description (QDCRDEVD) API
   dcl-s workstation char(10);
   dcl-ds devd0600 likeds(devd0600_t) inz;
   dcl-s tcpIdAddr like(devd0600.tcpIpDotAddr);

   // Send Program Message (QMHSNDPM) API
   dcl-ds qMsgF likeds(qObj_t) inz;
   dcl-s message varchar(132);
   dcl-s msgKey char(4);

   // Retrieve system name
   QWCRNETA_attrs(1) = 'SYSNAME';
   QWCRNETA(QWCRNETA_rcvBuff: %size(QWCRNETA_rcvBuff)
            : %elem(QWCRNETA_attrs): QWCRNETA_attrs: errCode);

   pQWCRNETA_returned = %addr(QWCRNETA_rcvBuff);
   if (QWCRNETA_returned.numE = 1);
      pQWCRNETA_attr = pQWCRNETA_returned + QWCRNETA_returned.offsAttr;
      sysName = %subst(QWCRNETA_attr.data_char: 1: QWCRNETA_attr.length);
   endif;

   // Retrieve TCP/IP address from device description
   workstation = sds.job;
   QDCRDEVD(devd0600: %size(devd0600): 'DEVD0600': workstation: errCode);
   tcpIdAddr = devd0600.tcpIpDotAddr;

   // Send result to command line
   message = 'User: '     + %trim(sds.user) +
             ', System: ' + %trim(sysName) +
             ', Device: ' + %trim(workstation) +
             ', IP: '     + %trim(tcpIdAddr);

   qMsgF.name = 'QCPFMSG';
   qMsgF.lib = 'QSYS';
   QMHSNDPM('CPDA0FF': qMsgF: message: %len(message): '*INFO': '*PGMBDY': 1: msgKey: errCode);

end-proc;


]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing WHOAMICPP  type MAKPGM - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "WHOAMICPP "
mbrtype =  "MAKPGM    "
mbrtext =  "Who am I - CPP                                    "
srcfile =  "QWHOAMI   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
**free
// ===================================================================
//
//  Documentation:
//
//  Utility . . . : WHOAMI
//  Object  . . . : WHOAMIM1   (*MODULE)
//  Source member : WHOAMIC1
//  Source type . : RPGLE
//  Description   : Who am I - CPP
//  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>
//  Created . . . : 25.01.2017
//
// ===================================================================
//
//  This software is free software, you can redistribute it and/or
//  modify it under the terms of the GNU General Public License (GPL)
//  as published by the Free Software Foundation.
//
//  See GNU General Public License for details.
//          http://www.opensource.org
//          http://www.opensource.org/licenses/gpl-license.html
//
// ===================================================================
//  History:
//
//  Datum       Name          Change
//  ----------  ------------  ---------------------------------------
//
// ===================================================================
// STRPREPRC Compile Options:
//   >>PRE-COMPILER<<
//     >>CRTCMD<<    CRTBNDRPG  PGM(&LI/&OB) +
//                              SRCFILE(&SL/&SF) SRCMBR(&SM);
//     >>IMPORTANT<<
//       >>PARM<<    TRUNCNBR(*NO);
//       >>PARM<<    DBGVIEW(*LIST);
//       >>PARM<<    DFTACTGREP(*NO);
//       >>PARM<<    ACTGRP(*NEW);
//       >>PARM<<    OPTION(*EVENTF);
//     >>END-IMPORTANT<<
//     >>EXECUTE<<
//   >>END-PRE-COMPILER<<
// ===================================================================

ctl-opt main(main);
ctl-opt debug(*yes);
      /if defined(CRTBNDRPG)
       ctl-opt dftactgrp(*no) actgrp(*new);
/endif
/include QWHOAMI,COPYRIGHT

// Send Program Message (QMHSNDPM) API
dcl-pr QMHSNDPM extpgm('QMHSNDPM');
   i_msgId       char(7)     const;
   i_qMsgF       char(20)    const;
   i_msgData     char(32768) options(*varsize) const;
   i_lenMsgData  int(10)     const;
   i_msgType     char(10)    const;
   i_callStkE    char(10)    const;
   i_callStkC    int(10)     const;
   o_msgKey      char(4);
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

// Retrieve Device Description (QDCRDEVD) API
dcl-pr QDCRDEVD extpgm('QDCRDEVD');
   o_rcvVar      char(37767) options(*varsize);
   i_lenRcv      int(10)     const;
   i_format      char(8)     const;
   i_device      char(10)    const;
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

dcl-ds devd0600_t qualified template;
   bytRet          int(10)   pos(1);
   bytAvl          int(10)   pos(5);
   dateInfRtv      char(7)   pos(9);
   timeInfRtv      char(6)   pos(16);
   devName         char(10)  pos(22);
   decCategory     char(10)  pos(32);
   onlineAtIPL     char(10)  pos(42);
   text            char(51)  pos(51);
   reserved_1      char(3)   pos(102);
   graphCharSet    int(10)   pos(105);
   codePage        int(10)   pos(109);
   maxLenReqU      int(10)   pos(113);
   inactTimer      int(10)   pos(117);
   dbcsRamSize     int(10)   pos(121);
   actTimer        int(10)   pos(125);
   swsSetting      int(10)   pos(129);
   devPort         int(10)   pos(133);
   maxOutFrms      int(10)   pos(137);
   idlTimer        int(10)   pos(141);
   nrmPollTimer    int(10)   pos(145);
   frmRetry        int(10)   pos(149);
   ofsAuxDev       int(10)   pos(153);
   numAuxDev       int(10)   pos(157);
   lenAuxDev       int(10)   pos(161);
   devClass        char(10)  pos(165);
   devType         char(10)  pos(175);
   devModel        char(10)  pos(185);
   lclLocAddr      char(10)  pos(195);
   attNonSwsCtrl   char(10)  pos(205);
   keybLngType     char(10)  pos(215);
   dropLineAtSnO   char(10)  pos(225);
   alwBlkCrs       char(10)  pos(235);
   prtDev          char(10)  pos(245);
   rmtLocName      char(10)  pos(255);
   lclLocName      char(10)  pos(265);
   rmtNetworkID    char(10)  pos(275);
   ctrlSessDevD    char(10)  pos(285);
   acoPrtName      char(10)  pos(295);
   acoPrtRmtNtID   char(10)  pos(305);
   altPrtName      char(10)  pos(315);
   altPrtRmtNtID   char(10)  pos(325);
   outQName        char(10)  pos(335);
   outQLib         char(10)  pos(345);
   printer         char(10)  pos(355);
   prtFName        char(10)  pos(365);
   prtFLib         char(10)  pos(375);
   wsCstObjName    char(10)  pos(385);
   wsCstObjLib     char(10)  pos(395);
   applType        char(10)  pos(405);
   dbcsMtxSize     char(10)  pos(415);
   dbcsLangID      char(10)  pos(425);
   dbcsLastCdePt   char(10)  pos(435);
   snaPassThrDev   char(10)  pos(445);
   snaPassThrGrp   char(10)  pos(455);
   emlDev          char(10)  pos(465);
   emlModel        char(10)  pos(475);
   emlAscDev       char(10)  pos(485);
   physAttach      char(10)  pos(495);
   lineSpeed       char(10)  pos(505);
   wordLength      char(10)  pos(515);
   parityType      char(10)  pos(525);
   stopBits        char(10)  pos(535);
   ascTerminalID   char(20)  pos(545);
   acoAppcDev      char(10)  pos(565);
   hostSignonCmd   char(256) pos(575);
   passThrID       char(1)   pos(831);
   autoCfg         char(10)  pos(832);
   reserved_2      char(3)   pos(842);
   shrdSessNbr     int(10)   pos(845);
   depLocName      char(10)  pos(849);
   netwProt        char(1)   pos(859);
   netwProtAddr    char(18)  pos(860);
   tcpIpDotAddr    char(15)  pos(878);
   alcByJobName    char(10)  pos(893);
   alcByUserName   char(10)  pos(903);
   alcByJobNbr     char(6)   pos(913);
   curMsgQName     char(10)  pos(919);
   curMsgQLib      char(10)  pos(929);
   svrNetwProt     char(1)   pos(939);
   svrNetwProtAddr char(18)  pos(940);
   svrTcpIpDotAddr char(15)  pos(958);
end-ds;

// Retrieve Network Attributes (QWCRNETA) API
dcl-pr QWCRNETA extpgm('QWCRNETA');
   o_rcvVar      char(37767) options(*varsize);
   i_lenRcv      int(10)     const;
   i_numAttr     int(10)     const;
   i_attrNames   char(10) dim(50)  options(*varsize) const;
   io_errCode    likeds(errCode_t) options(*varsize);
end-pr;

dcl-ds QWCRNETA_returned_t qualified template;
   numE          int(10);
   offsAttr      int(10);
end-ds;

dcl-ds QWCRNETA_attr_t qualified template;
   name          char(10);
   type          char(1);
   status        char(1);
   length        int(10);
   data_char     char(256);
   data_bin      int(10) overlay(data_char);
end-ds;

dcl-c QWCRNETA_TYPE_NONE '';
dcl-c QWCRNETA_TYPE_CHAR 'C';
dcl-c QWCRNETA_TYPE_BIN 'B';

dcl-c QWCRNETA_STATUS_OK '';
dcl-c QWCRNETA_STATUS_LOCKED 'L';

// IBM API error structure
dcl-ds errCode_t qualified template;
   bytPrv        int(10);
   bytAvl        int(10);
   excId         char(7);
   reserved      char(1);
   excData       char(512);
end-ds;

// IBM qualified object name
dcl-ds qObj_t qualified template;
   name          char(10);
   lib           char(10);
end-ds;

// Program status information data structure
dcl-ds sds PSDS qualified;
   pgmName       char(10) pos(1);
   pgmStat       zoned(5) pos(11);
   prevStat      zoned(5) pos(16);
   lastSeq       char(8)  pos(21);
   lastSubr      char(8)  pos(29);
   nbrParm       zoned(3) pos(37);
   excType       char(3)  pos(40);
   excNbr        char(4)  pos(43);
   miInstruction char(4)  pos(47);
   workArea      char(30) pos(51);
   pgmLib        char(10) pos(81);
   excData       char(80) pos(91);
   rnx9001Exc    char(4)  pos(171);
   lastFileLong  char(10) pos(175);
   unused_1      char(6)  pos(185);
   datFmt        char(8)  pos(191);
   year          zoned(2) pos(199);
   lastFileShort char(8)  pos(201);
   fileStat      char(35) pos(209);
   job           char(10) pos(244);
   user          char(10) pos(254);
   nbr           char(6)  pos(264);
   startDate     zoned(6) pos(270);
   runDate       zoned(6) pos(276);
   runTime       zoned(6) pos(282);
   compDate      char(6)  pos(288);
   compTime      char(6)  pos(294);
   compLevel     char(4)  pos(300);
   srcFile       char(10) pos(304);
   srcLib        char(10) pos(314);
   srcMbr        char(10) pos(324);
   pgmContProc   char(10) pos(334);
   modContProc   char(10) pos(344);
   sourceID1     int(5)   pos(354);
   sourceID2     int(5)   pos(356);
   currUser      char(10) pos(358);
   unused_2      char(62) pos(368);
end-ds;

// ===================================================================
//   Main procedure
// ===================================================================
dcl-proc main;
   dcl-pi *n end-pi;

   // IBM API error structure:
   dcl-ds errCode likeds(errCode_t) inz;

   // QWCRNETA fields:
   dcl-s QWCRNETA_rcvBuff char(300);
   dcl-ds QWCRNETA_returned likeds(QWCRNETA_returned_t) based(pQWCRNETA_returned);
   dcl-ds QWCRNETA_attr likeds(QWCRNETA_attr_t) based(pQWCRNETA_attr);
   dcl-s QWCRNETA_attrs char(10) dim(1);

   dcl-s sysName char(10);

   // Retrieve Device Description (QDCRDEVD) API
   dcl-s workstation char(10);
   dcl-ds devd0600 likeds(devd0600_t) inz;
   dcl-s tcpIdAddr like(devd0600.tcpIpDotAddr);

   // Send Program Message (QMHSNDPM) API
   dcl-ds qMsgF likeds(qObj_t) inz;
   dcl-s message varchar(132);
   dcl-s msgKey char(4);

   // Retrieve system name
   QWCRNETA_attrs(1) = 'SYSNAME';
   QWCRNETA(QWCRNETA_rcvBuff: %size(QWCRNETA_rcvBuff)
            : %elem(QWCRNETA_attrs): QWCRNETA_attrs: errCode);

   pQWCRNETA_returned = %addr(QWCRNETA_rcvBuff);
   if (QWCRNETA_returned.numE = 1);
      pQWCRNETA_attr = pQWCRNETA_returned + QWCRNETA_returned.offsAttr;
      sysName = %subst(QWCRNETA_attr.data_char: 1: QWCRNETA_attr.length);
   endif;

   // Retrieve TCP/IP address from device description
   workstation = sds.job;
   QDCRDEVD(devd0600: %size(devd0600): 'DEVD0600': workstation: errCode);
   tcpIdAddr = devd0600.tcpIpDotAddr;

   // Send result to command line
   message = 'User: '     + %trim(sds.user) +
             ', System: ' + %trim(sysName) +
             ', Device: ' + %trim(workstation) +
             ', IP: '     + %trim(tcpIdAddr);

   qMsgF.name = 'QCPFMSG';
   qMsgF.lib = 'QSYS';
   QMHSNDPM('CPDA0FF': qMsgF: message: %len(message): '*INFO': '*PGMBDY': 1: msgKey: errCode);

end-proc;


]]>  </copysrc>
</mbr>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="A_INSTALL"><![CDATA[
CRTBNDCL PGM(&tolib/A_INSTALL) SRCFILE(&tolib/QWHOAMI) SRCMBR(*PGM) DFTACTGRP(*NO) ACTGRP(*NEW) DBGV
IEW(*LIST)
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
CALL PGM(&tolib/A_INSTALL) PARM('&TGTRLS' '&SRCFILE' '&tolib')
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
DLTPGM PGM(&tolib/A_INSTALL)
]]>  </qcmdexc>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*COMP     "><![CDATA[
Application WHOAMI successfully installed.
]]>  </sendmsg>
</upload> 