<?xml version="1.0" encoding="ISO-8859-1"?>
     <!-- Embedded DTD for validation -->
     <!DOCTYPE upload [
     <!ELEMENT compile (#PCDATA)>
     <!ATTLIST compile
      condition CDATA #REQUIRED
     >
     <!ELEMENT copysrc (#PCDATA)>
     <!ELEMENT install_instructions (#PCDATA)>
     <!ELEMENT install_program (#PCDATA)>
     <!ELEMENT mbr (copysrc)>
     <!ATTLIST mbr
      mbrname CDATA #REQUIRED
      mbrtype CDATA #REQUIRED
      mbrtext CDATA #REQUIRED
      srcfile CDATA #REQUIRED
      srclib CDATA #REQUIRED
      srclen CDATA #REQUIRED
      srccssid CDATA #REQUIRED
     >
     <!ELEMENT qcmdexc (#PCDATA)>
     <!ATTLIST qcmdexc
      condition CDATA #REQUIRED
      release CDATA #REQUIRED
      dltsplf CDATA #REQUIRED
     >
     <!ELEMENT qrycond (#PCDATA)>
     <!ATTLIST qrycond
      msg CDATA #REQUIRED
      values CDATA #REQUIRED
      var CDATA #REQUIRED
     >
     <!ELEMENT sendmsg (#PCDATA)>
     <!ATTLIST sendmsg
      sendmsgid CDATA #REQUIRED
      sendmsgtype CDATA #REQUIRED
     >
     <!ELEMENT rtvobjd (#PCDATA)>
     <!ATTLIST rtvobjd
      condition CDATA #REQUIRED
      obj CDATA #REQUIRED
      lib CDATA #REQUIRED
      objtype CDATA #REQUIRED
      rtnlib CDATA #IMPLIED
     >
     <!ELEMENT upload (install_instructions | install_program | qrycond |
                       qcmdexc | sendmsg | mbr | compile | rtvobjd | chgvar)+>
     <!ATTLIST upload
      appname CDATA #REQUIRED
      appauthor CDATA #REQUIRED
      appblddate CDATA #REQUIRED
     >
     ]>
<upload  appname="JOBLOG"  appauthor="Thomas Raddatz"  appblddate="11/26/2019">
<install_instructions><![CDATA[
     *----------------------------------------------------------------      ------
     *  1. Upload entire XML to your AS/400 to a source file 112 long, into any mbr
     *     name not in this XML (suggest member name like ABCX or XYZX). The source
     *     file must be in the library where source and objects are to be installed.
     *
     *  2. If you have XMLPREVIEW installed, skip to step 3.
     *
     *     Copy the text between the start tag <install_program> and the end
     *     tag </install_program> into any member name (your choice)
     *     in file QRPGLESRC member type RPGLE.   CRTBNDRPG to compile.
     *     NOTE: You need extract the install program only once, this same program
     *           will install any upload on this page.
     *
     *  3. Call the install program (or execute XmlPrevew) passing these 3 parms.
     *       'your-member-name you uploaded this text into'
     *       'your-source-file-name the member is in'
     *       'your-library-name the source file is in'
     *
     *  The various source members will be extracted and the objects required
     *   for the application will be created in your-library-name.
     *----------------------------------------------------------------      ------
]]>  </install_instructions>
<install_program><![CDATA[
      * /// START OF INSTALL PGM HERE   ************************** ///
      *---------------------------------------------------------------------------------------
      * CRTBNDRPG PGM(QTEMP/XMLINST) SRCFILE(ISPHERE/QBUILD) SRCMBR(*PGM)
      *---------------------------------------------------------------------------------------
      * Parse / Install from xml text into source members and objects.
      * Copyright (C) 2001    Craig Rutledge    <craig_rutledge@mohawkind.com>
      * Martin Rowe    <Martin@dbg400.net>          scripting cmd prompts
      * David George   <webmaster@400times.co.uk>   intellectual input
      * Thomas Raddatz <thomas.raddatz@tools400.de> execute SQL statements
      * Thomas Raddatz <thomas.raddatz@tools400.de> conditions
      * Thomas Raddatz <thomas.raddatz@tools400.de> release
      * Thomas Raddatz <thomas.raddatz@tools400.de> retrieve object description
      *
      * Use xml tags in text to trigger:
      * 1. Parse text into source members (create srcfile & member if required).
      * 2. Compile source into objects.
      * 3. Send installation progress user messages.
      * 4. Execute qcmdexc as required.
      * 5. Execute SQL statements as required.
      *
      * This program is free software, you can redistribute it and/or modify it
      * under the terms of the GNU General Public License as published by
      * the Free Software Foundation.  See GNU General Public License for details
      *---------------------------------------------------------------------------------------
      * >>PRE-COMPILER<<
      *   >>CRTCMD<< CRTBNDRPG    PGM(&LI/&OB) SRCFILE(&SL/&SF) SRCMBR(*PGM) +
      *                           DBGVIEW(*LIST) OPTION(*EVENTF);
      *   >>EXECUTE<<
      * >>END-PRE-COMPILER<<
      *---------------------------------------------------------------------------------------
     H DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('QC2LE')
      *---------------------------------------------------------------------------------------
     Fxmlinput  if   f  112        disk    usropn                               uploaded text
     Fqxxxsrc   o    f  112        disk    usropn                               parsed out
      *--------------------------------------------------------------------
      * create parm prototypes
      *--------------------------------------------------------------------
      *  Tokenize String
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_token                        *   value  options(*string)
      * retrieve member description
     D qusrmbrd        PR                  ExtPgm('QUSRMBRD')                   MEMBER DESCRIPTION
     D  o_rcvVar                  32767a          options(*varsize)             RECEIVER
     D  i_lenRcvVar                  10i 0 const                                LENGTH OF RECVR
     D  i_format                      8    const                                UPLOAD TYPE
     D  i_qFile                      20    const                                FILE   LIB
     D  i_mbr                        10    const                                MEMBER NAME
     D  i_ovverride                   1    const                                PROCESS OVERIDE
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * retrieve object description
     D QUSROBJD...
     D                 PR                         extpgm('QUSROBJD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_type                       10A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    | OptGrp 1
      * send program message
     D qmhsndpm        PR                  ExtPgm('QMHSNDPM')                   SEND MESSAGES
     D  i_msgID                       7a   const                                ID
     D  i_qMsgF                      20a   const                                FILE
     D  i_msgText                 32767a   const  options(*varsize)             TEXT
     D  i_lenMsgText                 10i 0 const                                LENGTH
     D  i_msgType                    10a   const                                TYPE
     D  i_callStackE                 10a   const                                STACK ENTRY
     D  i_callStackC                 10i 0 const                                STACK COUNTER
     D  i_msgKey                      4a   const                                KEY
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * execute cl command
     D  qcmdexc        PR                  ExtPgm('QCMDEXC')
     D  i_cmd                        50a   Const
     D  i_lenCmd                     15p 5 Const
      *  Allocate Environment Handle
     D SQLAllocEnv...
     D                 PR                         extproc('SQLAllocEnv')
     D                                     like(SQLRETURN_t )
     D  o_phenv                        *   value
      *  Allocate Connection Handle
     D SQLAllocConnect...
     D                 PR                         extproc('SQLAllocConnect')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
     D  o_phdbc                        *   value
      *  Connect to a Data Source
     D SQLConnect...
     D                 PR                         extproc('SQLConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_szDSN                        *   value  options(*string)
     D  i_cbDSN                            value  like(SQLSMALLINT_t)
     D  i_szUID                        *   value  options(*string)
     D  i_cbUID                            value  like(SQLSMALLINT_t)
     D  i_szAuthStr                    *   value  options(*string)
     D  i_cbAuthStr                        value  like(SQLSMALLINT_t)
      *  Set Connection Option
     D SQLSetConnectOption...
     D                 PR                         extproc('SQLSetConnectOption')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_fOption                          value  like(SQLSMALLINT_t)
     D  i_vParam                           value  like(SQLPOINTER_t )
      *  Allocate a Statement Handle
     D SQLAllocStmt...
     D                 PR                         extproc('SQLAllocStmt')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  o_phstmt                       *   value
      *  Execute a Statement Directly
     D SQLExecDirect...
     D                 PR                         extproc('SQLExecDirect')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_szSqlStr                     *   value  options(*string)
     D  i_cbSqlStr                         value  like(SQLINTEGER_t)
      *  Free (or Reset) a Statement Handle
     D SQLFreeStmt...
     D                 PR                         extproc('SQLFreeStmt')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_fOption                          value  like(SQLSMALLINT_t)
      *  Disconnect from a Data Source
     D SQLDisconnect...
     D                 PR                         extproc('SQLDisconnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Connection Handle
     D SQLFreeConnect...
     D                 PR                         extproc('SQLFreeConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Environment Handle
     D SQLFreeEnv...
     D                 PR                         extproc('SQLFreeEnv')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
      *--------------------------------------------------------------------
     D long_t          S             10I 0                    based(pDummy)
     D short_t         S              5I 0                    based(pDummy)
      *
     D SQLINTEGER_t    S                   like(long_t      ) based(pDummy)
     D SQLSMALLINT_t   S                   like(short_t     ) based(pDummy)
      *
     D PTR_t           S               *                      based(pDummy)
     D SQLPOINTER_t    S                   like(PTR_t       ) based(pDummy)
     D HENV_t          S                   like(long_t      ) based(pDummy)
     D HDBC_t          S                   like(long_t      ) based(pDummy)
     D HSTMT_t         S                   like(long_t      ) based(pDummy)
     D RETCODE_t       S                   like(SQLINTEGER_t) based(pDummy)
      *
     D SQLHENV_t       S                   like(HENV_t      ) based(pDummy)
     D SQLHDBC_t       S                   like(HDBC_t      ) based(pDummy)
     D SQLHSTMT_t      S                   like(HSTMT_t     ) based(pDummy)
     D SQLRETURN_t     S                   like(RETCODE_t   ) based(pDummy)
      *
     D retCode         S                   like(SQLRETURN_t) inz
     D hdbc            S                   like(SQLHDBC_t  ) inz
     D hstmt           S                   like(SQLHSTMT_t ) inz
     D henv            S                   like(SQLHENV_t  ) inz
     D sqlInit         S              1A                     inz(*off)
     D cOptVal         S             10I 0                   inz
      *
     D SQL_NTS         C                   const( -3)
     D SQL_COMMIT_NONE...
     D                 C                   const(  1)
     D SQL_ATTR_COMMIT...
     D                 C                   const(  0)
     D SQL_DROP        C                   const(  1)
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     D readElement     PR                        like(bldexc)
     D  i_element                     9A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to double quotes in a string
      *--------------------------------------------------------------------
     D dblQuotes       PR          2048A         varying
     D  i_string                   2048A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to get attribute data from a string
      *--------------------------------------------------------------------
     D getAttrData...
     D                 PR          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *--------------------------------------------------------------------
      * Define function prototype to check for a condition
      *--------------------------------------------------------------------
     D isCondition...
     D                 PR              n
     D  i_condList                 2000A   value
      *---------------------------------------------------------------------------------------
     D loadConditions...
     D                 PR                  dim(32) like(condition)
     D  i_conditions                128A   value
      *--------------------------------------------------------------------
     D getCurrentRelease...
     D                 PR            10A
      *--------------------------------------------------------------------
     D isRelease...
     D                 PR              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *--------------------------------------------------------------------
     D setTargetRelease...
     D                 PR          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *--------------------------------------------------------------------
     D setVariable...
     D                 PR
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
      *---------------------------------------------------------------------------------------------
     D getVarName...
     D                 PR            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
      *---------------------------------------------------------------------------------------------
     D getVarValue...
     D                 PR            64a          varying
     D  i_name                       11a   value  varying
      *---------------------------------------------------------------------------------------------
     D uCase...
     D                 PR          2000A          varying
     D  i_string                   2000A   value  varying
      *--------------------------------------------------------------------
     D vrcvar          s            145
     D qm_msgid        s              7
     D qm_msgtxt       s            500
     D qm_msgq         s             10
     D qm_msgtyp       s             10
     D mbrname         s             10
     D mbrtype         s             10
     D mbrtext         s             50
     D srcfile         s             10
     D srclen          s              5
     D srclenN         s              5  0   inz(0)
     D srccssid        s              5
     D bldexc          s           2000
     D write_flag      s              1n   inz(*off)
     D srcSeqno        s              6s 2 inz(0)
     D aa              s              5u 0 inz(0)
     D ll              s              5u 0 inz(0)
     D qs              c                   ''''
     D qd              c                   '"'
     D errFLag         s              1    inz(*off)
     D cnd_msg         s             42
     D cnd_values      s            110
     D cnd_var         s             10
     D cnd_rtnVal      s             10
     D cnd_array       s                   dim(32) inz like(condition)
     D cnd_ptr         s             10i 0 inz
     D condition       s             10a
     D condList        s           2000a
     D release         s             10a
     D dltsplf         s             10a
     D objd_obj        s             10a
     D objd_lib        s             10a
     D objd_objtype    s             10a
     D objd_rtnlib     s             10a
     D objd0100        ds
     D  od_bytRet              1      4i 0
     D  od_bytAvl              5      8i 0
     D  od_name                9     18a
     D  od_lib                19     28a
     D  od_type               29     38a
     D  od_rtnLib             39     48a
     D fld_array       ds
     D  fld_x                        10i 0 inz
     D  fld_name                     11a   inz dim(64) varying
     D  fld_value                    64a   inz dim(64) varying
     D var_name        s             11a   inz varying
     D var_value       s             64a   inz varying
      * Error return code parm for APIs.
     D errCode         DS
     D  errCode_bytPrv...
     D                               10i 0 inz(%size(errCode))
     D  errCode_bytAvl...
     D                               10i 0 inz(0)
     D  errCode_excID...
     D                                7a   inz
     D  errCode_reserved...
     D                                1a   inz
     D  errCode_escData...
     D                              256a   inz
      * Optional parameters
     D OvrSrcFile      s                   like(i_OvrSrcFile) inz
     D isPreDefCond    s               N   inz(*off)
     D TgtRls          s                   like(i_TgtRls    ) inz
      *
      * Program status data structure.
     D sds            sds
     D  sds_pgmName                  10A
     D  sds_status                    5S 0
     D  sds_prvStat                   5S 0
     D  sds_lastSeq                   8A
     D  sds_lastSubR                  8A
     D  sds_numParm                   3S 0
     D  sds_msgID                     7A
     D  sds_MiInstr                   4A
     D  sds_wrkArea                  30A
     D  sds_lib                      10A
     D  sds_msgText                  80A
      *--------------------------------------------------------------------
     Ixmlinput  ns
     I                                 13   21  xmltag1
     I                                 18   27  xmltag2
     I                                 13  112  xmlcode
      *--------------------------------------------------------------------
     C     *entry        plist
     C                   parm                    ParseSrcMbr      10            source member
     C                   parm                    ParseSrcFile     10            source file
     C                   parm                    ParseSrcLib      10            source lib
      *  optional parameters:
     C                   parm                    i_OvrSrcFile     10            override to src
     C                   parm                    i_Conditions    128            pre-def conditions
     C                   parm                    i_TgtRls         10            target release
      *
      *  get optional parameter: Overrride to Source File
     C                   if        %parms() >= 4
     C                   eval      OvrSrcFile = i_OvrSrcFile
     C                   else
     C                   eval      OvrSrcFile = ''
     C                   endif
      *
      *  get optional parameter: Conditions
     C                   if        %parms() >= 5
     C                   if        %subst(i_Conditions:1:32) <> ''
     C                   eval      cnd_array = loadConditions(i_Conditions)
     C                   eval      isPreDefCond = *on
     C                   else
     C                   eval      isPreDefCond = *off
     C                   endif
     C                   endif
      *
      *  get optional parameter: Target Release
     C                   if        %parms() >= 6
     C                   eval      TgtRls = i_TgtRls
     C                   else
     C                   eval      TgtRls = getCurrentRelease()
     C                   endif
      *
     C                   exsr      srValidate                                   make sure exist
      *
      * Set user selected library *first for remainder of program
     C                   eval      bldexc = 'RMVLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
     C                   eval      bldexc = 'ADDLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ') POSITION(*FIRST)'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
      *       CPF2103 - Library &1 already exists in library list.
     C                   if        %error and sds_msgID <> 'CPF2103'
     C                   eval      qm_msgtxt = '0000 ' + sds_msgText
     C                   exsr      srKill
     C                   endif
      *
      * Set variable &TOLIB
     C                   callp     setVariable('tolib': ParseSrcLib)
      *
      * Set variable &TGTRLS
     C                   callp     setVariable('tgtrls': TgtRls)
      *
      * Set variable &XMLFILE
     C                   callp     setVariable('xmlfile': ParseSrcFile)
      *
      * Set variable &XMLLIB
     C                   callp     setVariable('xmllib': ParseSrcFile)
      *
      * Set variable &XMLMBR
     C                   callp     setVariable('xmlmbr': ParseSrcFile)
      *
      * Override Input file to uploaded text file
     C                   eval      bldexc = 'OVRDBF FILE(XMLINPUT) TOFILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(ParseSrcFile) + ') MBR(' +
     C                             %trimr(ParseSrcMbr) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   open      xmlinput
     C                   read      xmlinput
     C                   dow       not %eof
      * write records to outfile if flag is on
     C                   select
     C                   when      write_flag = *on
     C                   if        xmltag2<>'</copysrc>'
     C                   eval      srcSeqno=srcSeqno+1
     C                   except    write_one
     C                   else
     C                   eval      write_flag=*off
     C                   close     qxxxsrc
     C                   endif
      *
      * Extract values based on xml tags.
     C                   when      xmltag1 = 'mbrname ='
     C                   eval      mbrname = %subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtype ='
     C                   eval      mbrtype =%subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtext ='
     C                   eval      mbrtext =dblQuotes(%subst(xmlcode:13:50))
     C                   when      xmltag1 = 'srcfile ='
     C                   if        OvrSrcFile <> ''
     C                   eval      srcfile =OvrSrcFile
     C                   else
     C                   eval      srcfile =%subst(xmlcode:13:10)
     C                   endif
     C                   when      xmltag1 = 'srclen  ='
     C                   eval      srclen  =%subst(xmlcode:13:5)
     C                   when      xmltag1 = 'srccssid='
     C                   eval      srccssid=%subst(xmlcode:13:5)
      *--------------------------------------------------------------------
      * Start of data to copy.  Create source files/mbrs as required.
      *--------------------------------------------------------------------
     C                   when      xmltag1='<copysrc>'
     C                   move      srclen        srclenN
      * crtsrcpf
     C                   eval      bldexc = 'CRTSRCPF FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') RCDLEN(' +
     C                             srclen + ') CCSID(' +
     C                             srccssid + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      * addpfm
     C                   eval      bldexc = 'ADDPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') SRCTYPE(' +
     C                             %trimr(mbrtype) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error
      * chgpfm
     C                   eval      bldexc = 'CHGPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
      * clr mbr
     C                   eval      bldexc = 'CLRPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      * ovr to outfile mbr
     C                   eval      bldexc = 'OVRDBF QXXXSRC ' +
     C                             %trimr(ParseSrcLib) + '/' +
     C                             %trimr(srcfile) + ' ' +
     C                             mbrname
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   clear                   srcSeqno
     C                   open      qxxxsrc
     C                   eval      write_flag = *on
      *--------------------------------------------------------------------
      * Compile statement.  Read next record and execute it.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<compile '
     C                   eval      condList= getAttrData('condition':xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('compile')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      *--------------------------------------------------------------------
      * qcmdexc statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qcmdexc '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      release  = getAttrData('release'
     C                                                    :xmlcode:'*CURRENT')
     C                   eval      dltsplf  = getAttrData('dltsplf'
     C                                                    :xmlcode:'*NONE')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('qcmdexc')
     C                   if        isCondition(condList) and
     C                             isRelease(tgtRls: release)
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   if        %subst(bldexc: 1: 3) = 'DLT'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   else
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error()
     C                   eval      qm_msgtxt = '0000 Failed to execute: '+bldexc
     C                   exsr      srKill
     C                   endif
     C                   if        dltsplf <> '' and dltsplf <> '*NONE'
     C                   eval      bldexc = 'DLTSPLF FILE(' + dltsplf +
     C                                      ') JOB(*) SPLNBR(*LAST)'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
     C                   endif
     C                   endif
      *--------------------------------------------------------------------
      * SQL statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute SQL statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<execsql '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('execsql')
     C                   if        isCondition(condList)
     C                   exsr      RplVars
     C                   exsr      srSQLExecute
     C                   endif
      *--------------------------------------------------------------------
      * Send messages to user as program executes
      * Extract message ID, Message Type, from <sendmsg>
      * read a record and get the single line of message text.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<sendmsg '
     C                   eval      qm_msgid = %subst(xmlcode:22:7)
     C                   eval      qm_msgtyp = %subst(xmlcode:46:10)
     C                   read      xmlinput
     C                   eval      qm_msgq   = '*EXT   '
     C                   eval      qm_msgtxt = xmlcode
     C                   exsr      srSndMessage
      *--------------------------------------------------------------------
      * rtvobjd statement. retrieve object description of the specified
      * object. Store attributes in specified fields.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<rtvobjd '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('rtvobjd')
     C                   eval      objd_obj    =getAttrData('obj'    :bldexc:'')
     C                   eval      objd_lib    =getAttrData('lib'    :bldexc:'')
     C                   eval      objd_objtype=getAttrData('objtype':bldexc:'')
     C                   eval      objd_rtnlib =getAttrData('rtnlib' :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srRtvObjD
     C                   endif
      *--------------------------------------------------------------------
      * chgvar statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<chgvar  '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('chgvar')
     C                   eval      var_name  = getAttrData('var'    :bldexc:'')
     C                   eval      var_value = getAttrData('value'  :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srChgVar
     C                   endif
      *--------------------------------------------------------------------
      * Query condition
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qrycond '
     C                   eval      bldexc = readElement('qrycond')
     C                   eval      cnd_msg = getAttrData('msg'   : bldexc: '')
     C                   eval      cnd_values = getAttrData('values': bldexc:'')
     C                   eval      cnd_var = getAttrData('var': bldexc: '*NONE')
     C                   exsr      srQueryCond
     C                   endsl
      *
     C                   read      xmlinput
     C                   enddo
      *
     C                   exsr      srSQLEnd
     C                   eval      *inlr=*on
     C                   return
      *--------------------------------------------------------------------
      * Replace variable names with their associated values.
      *--------------------------------------------------------------------
     C     RplVars       begsr
     C                   eval      aa=%scan('&':bldexc)
     C                   dow       aa>0
     C                   eval      var_name=getVarName(bldexc:aa)
     C                   eval      var_value=getVarValue(var_name)
     C                   eval      bldexc=%replace(var_value:bldexc:aa
     C                                             :%len(var_name))
     C                   eval      aa=%scan('&':bldexc)
     C                   enddo
     C                   endsr
      *--------------------------------------------------------------------
      * Sets the target release according to the optional parameter
      * i_TgtRls.
      *--------------------------------------------------------------------
     C     SetTgtRls     begsr
     C                   if        TgtRls = getCurrentRelease()
     C                   leavesr
     C                   endif
     C                   eval      bldexc =
     C                                setTargetRelease('TGTRLS': bldexc: TgtRls)
     C                   endsr
      *--------------------------------------------------------------------
      * Check of file, lib, member exist.
      *--------------------------------------------------------------------
     C     srValidate    begsr
     C                   callp     QUSRMBRD(
     C                             vrcvar:
     C                             145:
     C                             'MBRD0100':
     C                             ParseSrcFile + ParseSrcLib:
     C                             ParseSrcMbr:
     C                             '0':
     C                             errCode)
      *   --------------------------------------------------------------------------------
      *   If error occurred on call, send appropriate message back to user.
      *   ---------------------------------------------------------------------------------
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   select
      * lib not found
     C                   when      errCode_excID = 'CPF9810'
     C                   eval      qm_msgtxt = '0000 Library ' +
     C                             %trimr(ParseSrcLib) + ' was not found.'
      * src file not found
     C                   when      errCode_excID = 'CPF9812'
     C                   eval      qm_msgtxt = '0000 Source file ' +
     C                             %trimr(ParseSrcFile)+' was not found in ' +
     C                             %trimr(ParseSrcLib) + '.'
      * member not found
     C                   when      errCode_excID = 'CPF9815'
     C                   eval      qm_msgtxt = '0000 Member ' +
     C                             %trimr(ParseSrcMbr)+' was not found in ' +
     C                             %trimr(ParseSrcLib)+'/'+ %trimr(ParseSrcFile)
      * unexpected
     C                   other
     C                   eval      qm_msgtxt = '0000 Unexpected message ' +
     C                             errCode_excID + ' received. '
     C                   endsl
      * send message
     C                   exsr      srKill
     C                   eval      *inlr=*on
     C                   return
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * kill application
      *--------------------------------------------------------------------
     C     srKill        begsr
     C                   eval      qm_msgid  = 'CPD0006'
     C                   eval      qm_msgtyp = '*DIAG'
     C                   eval      qm_msgq   = '*CTLBDY'
     C                   exsr      srSndMessage
     C                   eval      qm_msgtxt = *blanks
     C                   eval      qm_msgid  = 'CPF0002'
     C                   eval      qm_msgtyp = '*ESCAPE'
     C                   exsr      srSndMessage
     C                   endsr
      *--------------------------------------------------------------------
      * call send program message api
      *--------------------------------------------------------------------
     C     srSndMessage  begsr
     C                   callp     QMHSNDPM(
     C                             qm_msgid:
     C                             'QCPFMSG   *LIBL     ':
     C                             qm_msgtxt:
     C                             %size(qm_msgtxt):
     C                             qm_msgtyp:
     C                             qm_msgq:
     C                             1:
     C                             '    ':
     C                             errCode)
     C                   endsr
      *--------------------------------------------------------------------
      * retrieve object description and store attributes
      *--------------------------------------------------------------------
     C     srRtvObjD     begsr
     C                   callp     QUSROBJD(objd0100
     C                                      : %size(objd0100)
     C                                      : 'OBJD0100'
     C                                      : objd_obj + objd_lib
     C                                      : objd_objtype
     C                                      : errCode)
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   eval      qm_msgtxt = '0000 Failed to retrieve +
     C                             object description of object ' +
     C                             %trim(objd_lib) + '/' + %trim(objd_obj) +
     C                             ' type ' + %trim(objd_objtype) + '.'
      * send message
     C                   exsr      srKill
     C                   else
     C                   callp     setVariable(objd_rtnlib: od_rtnlib)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * change variable
      *--------------------------------------------------------------------
     C     srChgVar      begsr
     C                   callp     setVariable(var_name: var_value)
     C                   endsr
      *--------------------------------------------------------------------
      * execute SQL statement.
      *--------------------------------------------------------------------
     C     srSQLExecute  begsr
     C                   exsr      srSQLInit
     C                   Eval      retCode = SQLExecDirect(hstmt    :
     C                                                     bldexc   :
     C                                                     SQL_NTS  )
     C                   endsr
      *--------------------------------------------------------------------
      * query condition.
      *--------------------------------------------------------------------
     C     srQueryCond   begsr
     C                   if        isPreDefCond = *off
     C                   eval      cnd_values = uCase(cnd_values)
     C                   dou       (%scan(cnd_rtnVal: cnd_values) > 0) and
     C                             (cnd_rtnval <> ''                 )
     C                   eval      cnd_rtnval = ' '
     C     cnd_msg       dsply                   cnd_rtnval
     C                   eval      cnd_rtnVal = uCase(cnd_rtnVal)
     C                   enddo
     C                   eval      cnd_ptr = cnd_ptr + 1
     C                   eval      cnd_array(cnd_ptr) = cnd_rtnVal
     C                   endif
     C                   if        (cnd_var <> '*NONE')
     C                   callp     setVariable(cnd_var: cnd_rtnval)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * initialize SQL.
      *--------------------------------------------------------------------
     C     srSQLInit     begsr
      *
     C                   if        sqlInit = *off
     C                   Eval      retCode = SQLAllocEnv(%addr(henv))
     C                   Eval      retCode = SQLAllocConnect(henv: %addr(hdbc))
     C                   Eval      retCode = SQLConnect(hdbc      :
     C                                                  '*LOCAL'  :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   )
     C                   Eval      cOptVal = SQL_COMMIT_NONE
     C                   Eval      retCode = SQLSetConnectOption(hdbc          :
     C                                                          SQL_ATTR_COMMIT:
     C                                                          %addr(cOptVal) )
     C                   Eval      retCode = SQLAllocStmt(hdbc       :
     C                                                  %addr(hstmt) )
     C                   eval      sqlInit = *on
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * end SQL.
      *--------------------------------------------------------------------
     C     srSQLEnd      begsr
     C                   if        sqlInit = *on
     C                   Eval      retCode = SQLFreeStmt(hstmt    :
     C                                                   SQL_DROP )
     C                   Eval      retCode = SQLDisconnect(hdbc)
     C                   Eval      retCode = SQLFreeConnect(hdbc)
     C                   Eval      retCode = SQLFreeEnv(henv)
     C                   eval      sqlInit = *off
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * error handler
      *--------------------------------------------------------------------
     C     *pssr         begsr
     C                   if        errFLag = *off
     C                   eval      errFlag = *on
     C                   exsr      srSQLEnd
     C                   endif
     C                   endsr     '*CANCL'
     Oqxxxsrc   e            write_one
     O                       srcSeqno             6
     O                                           12 '000000'
     O                       xmlcode            112
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     P readElement...
     P                 B
     D                 PI                        like(bldexc)
     D  i_element                     9A   value varying
      *
     D i               S             10I 0 inz
     D value           S                   like(bldexc ) inz
     D endTag          S                   like(xmlTag2) inz
      *
     C                   eval      i = 1
     C                   eval      endTag = '</' + i_element + '>'
     C                   dow       xmltag2 <> endTag
     C                   eval      %subst(value: i: %len(xmlcode)) = xmlcode
     C                   eval      i = i + %len(xmlcode)
     C                   read      xmlinput
     C                   enddo
      *
     C                   Return    value
      *
     P                 E
      *--------------------------------------------------------------------
      * Double quotes
      *--------------------------------------------------------------------
     P dblQuotes...
     P                 B
     D                 PI          2048A         varying
     D  i_string                   2048A   value varying
      *
     D x               S             10I 0         inz
     D string          S           2048A   varying inz
      *
     C                   For       x = 1 to %len(i_string)
     C                   Eval      string = string + %subst(i_string: x:1)
     C                   If        %subst(i_string: x : 1) = qs
     C                   Eval      string = string + qs
     C                   Endif
     C                   Endfor
      *
     C                   Return    string
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get Attribute Data from String
      *---------------------------------------------------------------------------------------------
     P getAttrData...
     P                 B
     D                 PI          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *
      *  return value
     D attrData        S           2000A   varying inz                          like(string_t)
      *
      *  local fields
     D attr            S             20a   varying inz
     D lenAttr         S             10i 0 inz
     D aa              S             10i 0 inz
     D cc              S             10i 0 inz
      *
     D Qd              C                   const('"')
      *-------------------------------------------------------------------*
      *
      *  find the keyword
     C                   eval      attr = %trim(i_attr) + '=' + Qd
      *
     C                   eval      aa   = %scan(attr: i_string)
     C                   if        aa = 0
     C                   return    i_default
     C                   endif
      *
     C                   eval      aa   = aa + %len(attr)
     C                   eval      cc   = %scan(Qd: i_string: aa+1)
      *
      *  return the data between the double-quotes
     C                   if        (cc-aa) > 0
     C                   eval      attrData = %subst(i_string: aa: cc-aa)
     C                   endif
      *
     C                   Return    attrData
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Load condition array
      *---------------------------------------------------------------------------------------------
     P loadConditions...
     P                 B
     D                 PI                  dim(32) like(condition)
     D  i_conditions                128A   value
      *
      *  return value
     D cnd_array       s                   dim(32) inz like(condition)
     D pValue          s               *   inz
     D x               s             10i 0 inz
     D i               s             10i 0 inz
     D cnd_value       s            128a   varying
     D var_name        s             64a   varying
     D var_value       s             64a   varying
      *-------------------------------------------------------------------*
      /FREE

         i_conditions = uCase(i_conditions);

         pValue = strtok(i_conditions: ';');
         dow (pValue <> *null);
            x = x + 1;
            cnd_value = %str(pValue);
            i = %scan('=': cnd_value);
            if (i = 0);
               cnd_array(x) = cnd_value;
            else;
               var_name = %subst(cnd_value: 1: i-1);
               if (%subst(var_name: 1: 1) = '&');
                  var_name = %subst(var_name: 2);
               endif;
               var_value = %subst(cnd_value: i+1);
               setVariable(var_name: var_value);
               cnd_array(x) = var_value;
            endif;
            pValue = strtok(*null: ';');
         enddo;

         return cnd_array;
      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check for a condition
      *---------------------------------------------------------------------------------------------
     P isCondition...
     P                 B
     D                 PI              n
     D  i_condList                 2000A   value
      *
      *  return value
     D isCondition     S               n   inz
     D pValue          S               *   inz
     D aCondition      S             10a   inz
      *-------------------------------------------------------------------*
      *
     C                   eval      i_condList = uCase(i_condList)
      *
     C                   if        (i_condList = '*NONE')  or
     C                             (i_condList = ''     )
     C                   eval      *in01 = *on
     C                   else
      *
     C                   eval      pValue = strtok(i_condList: ' ')
     C                   dow       pValue <> *null
     C                   eval      aCondition = %str(pValue)
     C     aCondition    lookup    cnd_array                              01
     C                   if        not *in01
     C                   leave
     C                   endif
     C                   eval      pValue = strtok(*null     : ' ')
     C                   enddo
      *
     C                   endif
      *
     C                   if        *in01
     C                   eval      isCondition = *on
     C                   else
     C                   eval      isCondition = *off
     C                   endif
      *
     C                   Return    isCondition
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get the current release level of the operation system
      *---------------------------------------------------------------------------------------------
     P getCurrentRelease...
     P                 B
     D                 PI            10A
      *
      *  QSZRTVPR API
     D QSZRTVPR...
     D                 PR                  extpgm('QSZRTVPR')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  o_prodInf                 65535A   const  options(*varsize)
     D  io_errCode                65535A          options(*varsize)
      *
     D prdi0100        DS                  qualified
     D  productID              1      7A   inz('*OPSYS')
     D  releaseLvl             8     13A   inz('*CUR'  )
     D  productOpt            14     17A   inz('0000'  )
     D  loadID                18     27A   inz('*CODE' )
      *  Shortened!:
     D prdr0100        DS                  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     12I 0
     D  productID             13     19A
     D  releaseLvl            20     25A
      *  API error code
     D errCode         DS
     D  bytPrv                       10i 0 inz(0)
     D  bytAvl                       10i 0 inz(0)
      *-------------------------------------------------------------------*
      *
     C                   Callp     QSZRTVPR(prdr0100: %size(prdr0100):
     C                                      'PRDR0100': prdi0100: errCode)
     C                   Return    prdr0100.releaseLvl
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check the release level
      *---------------------------------------------------------------------------------------------
     P isRelease...
     P                 B
     D                 PI              n
     D  i_os_release                  6A   value
     D  i_release                    10A   value
      *
      *  return value
     D isRelease       S               n   inz(*off)
      *  Release
     D release         DS
     D  r_operator             1      3a
     D  r_space                4      4a
     D  r_level                5     10a
      *-------------------------------------------------------------------*
      *
     C                   If        i_release = '*CURRENT'
     C                   Eval      isRelease = *on
     C                   Else
     C                   Eval      release = i_release
     C                   Select
     C                   When      r_operator = '*LT' and
     C                             i_os_release < r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*EQ' and
     C                             i_os_release = r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GT' and
     C                             i_os_release > r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*LE' and
     C                             i_os_release <= r_level
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GE' and
     C                             i_os_release >= r_level
     C                   Eval      isRelease = *on
     C                   Other
     C                   Eval      isRelease = *off
     C                   Endsl
     C                   Endif
      *
     C                   Return    isRelease
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Replaces the value of a given keyword.
      *---------------------------------------------------------------------------------------------
     P setTargetRelease...
     P                 B
     D                 PI          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *
      *  return value
     D string          S           2000A   varying inz
      *
      *  helper fields
     D x               S             10I 0 inz
     D l               S             10I 0 inz
     D tmpKeyword      S                   like(i_keyword) inz
     D tmpString       S                   like(i_string ) inz
     D tmpCmd          S             10A   inz
      *-------------------------------------------------------------------*
      /FREE

         tmpKeyword = uCase(%trimR(i_keyword));
         tmpString  = uCase(%trimR(i_string ));
         x = %scan(' ': tmpString);
         if x = 0;
            return i_string;
         endif;
         tmpCmd = %subst(tmpString: 1: x);
         if tmpCmd <> 'CRTRPGMOD' and
            tmpCmd <> 'CRTRPGPGM' and
            tmpCmd <> 'CRTCLMOD'  and
            tmpCmd <> 'CRTCLPGM'  and
            tmpCmd <> 'CRTCBLMOD' and
            tmpCmd <> 'CRTCBLPGM' and
            tmpCmd <> 'CRTCMOD'   and
            tmpCmd <> 'CRTCPPMOD' and
            tmpCmd <> 'CRTBNDC'   and
            tmpCmd <> 'CRTBNDCBL' and
            tmpCmd <> 'CRTBNDCL'  and
            tmpCmd <> 'CRTBNDCPP' and
            tmpCmd <> 'CRTBNDDIR' and
            tmpCmd <> 'CRTBNDRPG' and
            tmpCmd <> 'CRTPGM'    and
            tmpCmd <> 'CRTSRVPGM' ;
            return i_string;
         endif;
         x = %scan(tmpKeyword + '(': tmpString);
         if x = 0;
            return %trimR(i_string) +
                   ' ' + tmpKeyword + '(' + %trimR(i_value) + ')';
         endif;
         l = %scan(')': tmpString: x + %len(i_keyword) + 1);
         if l = 0;
            return i_string;
         endif;
         l = l - x + 1;
         string = %replace(tmpKeyword + '(' + %trimR(i_value) + ')'
                           : i_string: x: l);
         Return string;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Store field value.
      *---------------------------------------------------------------------------------------------
     P setVariable...
     P                 B
     D                 PI
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
     D i               s             10I 0 inz
      *-------------------------------------------------------------------*
      /FREE

         if (i_fldName = '');
            return;
         endif;

         for i = 1 to fld_x;
            if (uCase('&' + %trim(i_fldName)) = uCase(fld_name(i)));
               fld_value(i) = i_value;
               return;
            endif;
         endfor;

         if (fld_x >= %elem(fld_name));
            return;
         endif;

         fld_x = fld_x + 1;
         fld_name(fld_x)  = uCase('&' + %trim(i_fldName));
         fld_value(fld_x) = i_value;

      /END-FREE
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable name from statement.
      *---------------------------------------------------------------------------------------------
     P getVarName...
     P                 B
     D                 PI            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
     D name            s             11a   varying inz
     D CHARS           c                   '&ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                      abcdefghijklmnopqrstuvwxyz+
     D                                      1234567890_'
      *-------------------------------------------------------------------*
      /FREE

         dow (i_pos<=%len(i_bldexc) and
              %check(CHARS:%subst(i_bldexc:i_pos:1))=0);
            name = name+%subst(i_bldexc:i_pos:1);
            i_pos=i_pos+1;
         enddo;

         return name;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable value.
      *---------------------------------------------------------------------------------------------
     P getVarValue...
     P                 B
     D                 PI            64a          varying
     D  i_name                       11a   value  varying
     D i               s             10i 0 inz
     D value           s             64a   varying inz('?')
      *-------------------------------------------------------------------*
      /FREE

         for i=1 to fld_x;
            if (ucase(fld_name(i))=uCase(i_name));
               value=%trimR(fld_value(i));
               leave;
            endif;
         endfor;

         return value;

      /END-FREE
      *
     P                 E
      *---------------------------------------------------------------------------------------------
      *  convert to upper case
      *---------------------------------------------------------------------------------------------
     P uCase...
     P                 B
     D                 PI          2000A          varying
     D  i_string                   2000A   value  varying
     D uCase           s           2000A   inz varying
     D LC              C                   const('abcdefghijklmnopqrstuvwxyz')
     D UC              C                   CONST('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      *-------------------------------------------------------------------*
      /FREE

         uCase = %xlate(LC:UC:i_string);

         return uCase;

      /END-FREE
     P                 E
      * /// END   OF INSTALL PGM HERE   ****************************************** ///
      * /// do not copy past this point ///
]]>  </install_program>
<qrycond
  msg="'Create sample programs? (YES, NO)'"
  values="YES        NO"
  var="CRTTSTPGM">
<![CDATA[
]]>  </qrycond>
<chgvar   condition="*NONE" var="SRCFILE" value="QJOBLOG">
<![CDATA[
]]>  </chgvar>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_INSTALL  type CLLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_INSTALL "
mbrtype =  "CLLE      "
mbrtext =  "JOBLOG - Installer                                "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* =================================================================== */
     /*                                                                     */
     /*  Documentation:                                                     */
     /*                                                                     */
     /*  Utility . . . : JOBLOG                                             */
     /*  Object  . . . : A_INSTALL  (PGM)                                   */
     /*  Source member : A_INSTALL                                          */
     /*  Source type . : CLLE                                               */
     /*  Description   : JOBLOG - Installer                                 */
     /*  Author  . . . : Thomas Raddatz   <thomas.raddatz@tools400.de>      */
     /*                                                                     */
     /* =================================================================== */
     /*                                                                     */
     /*  This software is free software, you can redistribute it and/or     */
     /*  modify it under the terms of the GNU General Public License (GPL)  */
     /*  as published by the Free Software Foundation.                      */
     /*                                                                     */
     /*  See GNU General Public License for details.                        */
     /*          http://www.opensource.org                                  */
     /*          http://www.opensource.org/licenses/gpl-license.html        */
     /*                                                                     */
     /* =================================================================== */
     /*  History:                                                           */
     /*                                                                     */
     /*  Datum       Name          nderung                                 */
     /*  ----------  ------------  ---------------------------------------  */
     /*                                                                     */
     /* =================================================================== */
     /*   >>PRE-COMPILER<<                                                  */
     /*     >>CRTCMD<<    CRTBNDCL  PGM(QTEMP/&OB) +                        */
     /*                             SRCFILE(&SL/&SF) SRCMBR(&SM);           */
     /*     >>IMPORTANT<<                                                   */
     /*       >>PARM<<    OPTION(*EVENTF);                                  */
     /*     >>END-IMPORTANT<<                                               */
     /*     >>EXECUTE<<                                                     */
     /*     >>CMD<<       CALL   PGM(QTEMP/A_INSTALL) +                     */
     /*                          PARM('*CURRENT' '&SF' '&LI' 'NO');         */
     /*     >>CMD<<       DLTPGM PGM(QTEMP/A_INSTALL);                      */
     /*   >>END-PRE-COMPILER<<                                              */
     /* =================================================================== */
             PGM        PARM(&TGTRLS &SRCFILE &TOLIB &CRTTSTPGM)

             DCL        VAR(&TGTRLS   ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&SRCFILE  ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&TOLIB    ) TYPE(*CHAR) LEN(10)
             DCL        VAR(&CRTTSTPGM) TYPE(*CHAR) LEN(10)

             DCL        VAR(&SRCLIB   ) TYPE(*CHAR) LEN(10)

             CHGVAR     VAR(&SRCLIB) VALUE(&TOLIB   )

     /* -------------------------------- */
     /*  Delete old objects              */
     /* -------------------------------- */
             DLTMOD     MODULE(&TOLIB/JOBLOG1)
             MONMSG     MSGID(CPF2105)

             DLTSRVPGM  SRVPGM(&TOLIB/JOBLOG)
             MONMSG     MSGID(CPF2105)

             DLTMOD     MODULE(&TOLIB/JOBLOGT1)
             MONMSG     MSGID(CPF2105)

             DLTPGM     PGM(&TOLIB/JOBLOGT1)
             MONMSG     MSGID(CPF2105)

     /* -------------------------------- */
     /*  Create modules                  */
     /* -------------------------------- */
             CRTRPGMOD  MODULE(&TOLIB/JOBLOG1) +
                          SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(*MODULE) +
                          DBGVIEW(*LIST) TRUNCNBR(*NO) +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(JOBLOG1 ) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create service programs         */
     /* -------------------------------- */
             CRTSRVPGM  SRVPGM(&TOLIB/JOBLOG) +
                          MODULE(&TOLIB/JOBLOG1) +
                          EXPORT(*SRCFILE) +
                          SRCFILE(&SRCLIB/&SRCFILE) +
                          SRCMBR(JOBLOG) +
                          ACTGRP(*CALLER) +
                          BNDSRVPGM(&TOLIB/BASICS1) +
                          DETAIL(*BASIC) +
                          TEXT('Job Log API') +
                          TGTRLS(&TGTRLS)
             DLTSPLF    FILE(JOBLOG) JOB(*) SPLNBR(*LAST)
             MONMSG     MSGID(CPF0000)

     /* -------------------------------- */
     /*  Create test programs            */
     /* -------------------------------- */
             IF         COND(&CRTTSTPGM *EQ 'YES') THEN(DO)
                CRTRPGMOD  MODULE(&TOLIB/JOBLOGT1) +
                             SRCFILE(&SRCLIB/&SRCFILE) +
                             SRCMBR(*MODULE) +
                             DBGVIEW(*LIST) +
                             TRUNCNBR(*NO) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(JOBLOGT1) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                CRTPGM     PGM(&TOLIB/JOBLOGT1) +
                             MODULE(*PGM) +
                             BNDSRVPGM(&TOLIB/JOBLOG &TOLIB/BASICS1) +
                             ACTGRP(*NEW) +
                             DETAIL(*BASIC) +
                             TGTRLS(&TGTRLS)
                DLTSPLF    FILE(JOBLOGT1) JOB(*) SPLNBR(*LAST)
                MONMSG     MSGID(CPF0000)

                DLTMOD    MODULE(&TOLIB/JOBLOGT1)

             ENDDO

     /* -------------------------------- */
     /*  Delete obsolete objects         */
     /* -------------------------------- */
             DLTMOD     MODULE(&TOLIB/JOBLOG1)

             ENDPGM
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing A_README  type TXT - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "A_README  "
mbrtype =  "TXT       "
mbrtext =  "JOBLOG Readme                                     "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
JOBLOG - A Tools/400 Service Program
------------------------------------

JOBLOG is service program that offers services for reading messages
from job logs.

Dependencies: BASICS1

Compile members with the following PDM option:

   STRPREPRC USESRCFILE(&L/&F) USESRCMBR(&N) OPTION(*EVENTF) CHGOBJD(*NO)
     LIB(&O) OBJ(&N) SRCLIB(&L) SRCFILE(&F) SRCMBR(&N) USER0(&X)
     USER1(*LIST) USER2(*FULL)

Members of type MAKPGM or BND are used for linking programs (MAKPGM)
and service programs (BND).

2018, Thomas Raddatz
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing CLIB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "CLIB      "
mbrtype =  "RPGLE     "
mbrtext =  "Prototypes of C-Library                  (include)"
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
 DEF  /IF NOT DEFINED(CLIB)
 DEF  /DEFINE CLIB
      *
      *  Basic C data types
      /IF NOT DEFINED(C_DATA_TYPES)
      /DEFINE C_DATA_TYPES
      * C Data Types
     D char_t          S              1A   based(pDummy)
     D short_t         S              5I 0 based(pDummy)
     D ushort_t        S              5U 0 based(pDummy)
     D int_t           S             10I 0 based(pDummy)
     D uint_t          S             10U 0 based(pDummy)
     D long_t          S             10I 0 based(pDummy)
     D ulong_t         S             10U 0 based(pDummy)
     D float_t         S              4F   based(pDummy)
     D double_t        S              8F   based(pDummy)
      /ENDIF
      *
      *  stdin, stdout and stderr
     D stdin           S               *   import('_C_IFS_stdin')
     D stdout          S               *   import('_C_IFS_stdout')
     D stderr          S               *   import('_C_IFS_stderr')
      *
      *  system -- Execute a Command
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     0                  the command is successful
      *     -1                 for a NULL pointer
      *     1                  the command fails
     D system          PR            10I 0 extproc('system')
     D  i_clCommand                    *   value options(*string)
      *
     D EXCP_MSGID      S              7A   import('_EXCP_MSGID')
      *
      *  time -- Determine Current Time
      *     The time() function returns the current calendar time.
      *     The return value is also stored in the location that
      *     is given by timeptr.
     D time...
     D                 PR            10i 0 extproc('time')
     D  timeptr                        *   value
      *
      *  strftime -- Convert to Formatted Time
      *     strftime() returns the number of bytes placed into the
      *     array pointed to by 'dest'.
     D strftime...
     D                 PR            10i 0 extproc('strftime')
     D  dest                           *   value
     D  maxsize                      10i 0 value
     D  format                         *   value options(*string)
     D  timeptr                            const  likeds(tm_t)
      *
     D tm_t            DS                  qualified  based(pDummy)
     D  tm_sec                       10I 0
     D  tm_min                       10I 0
     D  tm_hour                      10I 0
     D  tm_mday                      10I 0
     D  tm_mon                       10I 0
     D  tm_year                      10I 0
     D  tm_wday                      10I 0
     D  tm_yday                      10I 0
     D  tm_isdst                     10I 0
      *
      *  localtime() -- Correct Local Time, returns tm_t*
      *     The localtime() function converts a time value, in
      *     seconds, to a structure of type tm.
     D localtime...
     D                 PR              *   extproc('localtime')
     D  time                         10I 0 const
      *
      *  localtime_r() -- Correct Local Time
      *     It is the same as localtime() except that it passes
      *     in the place to store the returned structure result.
     D localtime_r...
     D                 PR              *   extproc('localtime_r')
     D  time                         10I 0 const
     D  tm                                 const  likeds(tm_t)
      *
      *  strtok -- Tokenize String
      *     The first time the strtok() function is called, it returns
      *     a pointer to the first token in i_string. In later calls
      *     it returns a pointer to the next token. A null pointer is
      *     returned when there are no more tokens.
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_delimiters                   *   value  options(*string)
      *
      *  atoi -- Convert Character String to Integer
      *     The atoi() function returns an int value of the
      *     interpreted input string.
     D atoi            PR            10I 0        extproc('atoi')
     D  i_string                       *   value  options(*string)
      *
      *  memcpy -- Copy Bytes
      *     The behavior is undefined if copying takes place
      *     between objects that overlap.
      *     The memcpy() function returns a pointer to dest.
     D memcpy          PR              *          extproc('memcpy')
     D  i_pDest                        *   value
     D  i_pSrc                         *   value
     D  i_count                      10U 0 value
      *
      *  memset -- Set Bytes to Value
      *     The memset() function returns a pointer to dest.
     D memset          PR              *          extproc('memset')
     D  i_pDest                        *   value
     D  i_char                       10I 0 value
     D  i_count                      10U 0 value
      *
      *  memmove -- Copy Bytes
      *     memmove allows copying between objects that may overlap
      *     as if src is first copied into a temporary array.
      *     The memmove() function returns a pointer to dest.
     D memmove         PR              *          extproc('memmove')
     D  pMemDest                       *   value
     D  pMemSrc                        *   value
     D  memSize                            value like(size_t)
      *
      *  memcmp -- Compare Buffers
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        buf1 less than buf2
      *     0                  buf1 identical to buf2
      *     Greater than 0     buf1 greater than buf2
     D memcmp          PR            10I 0        extproc('memcmp')
     D  pBuf1                          *   value
     D  pBuf2                          *   value
     D  count                              value like(size_t)
      *
      *  memicmp -- Compare Bytes (ignore case)
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        buf1 less than buf2
      *     0                  buf1 identical to buf2
      *     Greater than 0     buf1 greater than buf2
     D memicmp         PR            10I 0        extproc('__memicmp')
     D  pBuf1                          *   value
     D  pBuf2                          *   value
     D  count                        10U 0 value
      *
      *  strcmp() -- Compare Strings
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        string 1 less than string 2
      *     0                  string 1 equivalent to string 2
      *     Greater than 0     string 1 greater than string 2
     D strcmp...
     D                 PR            10I 0
     D                                            extproc('strcmp')
     D  string1                        *   value  options(*string)
     D  string2                        *   value  options(*string)
      *
      *  strcasecmp() -- Compare Strings without Case Sensitivity
      *     Return value       Meaning
      *     ----------------   --------------------------------------
      *     Less than 0        string 1 less than string 2
      *     0                  string 1 equivalent to string 2
      *     Greater than 0     string 1 greater than string 2
     D strcasecmp...
     D                 PR            10I 0
     D                                            extproc('strcasecmp')
     D  string1                        *   value  options(*string)
     D  string2                        *   value  options(*string)
      /IF NOT DEFINED(TESTPTR)
      /DEFINE TESTPTR
      *
      *  Test Pointer (TESTPTR)
     D testptr         PR            10I 0 extproc('_TESTPTR')
     D  i_ptr                          *   value
     D  i_test_type                  10I 0 value
      *
     D cTESTPTR_TYPE_PROCPTR...
     D                 C                   0
     D cTESTPTR_NO_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   0
     D cTESTPTR_OPTIMIZED_PARAMETER_PASSING...
     D                 C                   1
      *
     D cTESTPTR_TYPE_MEMPTR...
     D                 C                   1
     D cTESTPTR_NON_TERASPACE...
     D                 C                   0
     D cTESTPTR_TERASPACE...
     D                 C                   1
      *
     D cTESTPTR_ERROR_NOT_EXIST...
     D                 C                   x'2401'
     D cTESTPTR_ERROR_INVALID...
     D                 C                   x'2402'
     D cTESTPTR_ERROR_OBJECT_DESTROYED...
     D                 C                   x'2202'
      /ENDIF
      *
      *  malloc() - Reserve Storage Block
     D TS_malloc...
     D                 PR              *   extproc('_C_TS_malloc')
     D  i_size                       10U 0 value
      *
      *  realloc() - Change Reserved Storage Block Size
     D TS_realloc...
     D                 PR              *   extproc('_C_TS_realloc')
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  free() - Release Storage Blocks
     D TS_free...
     D                 PR                  extproc('_C_TS_free')
     D  i_pMem                         *   value
      *
      *  _C_TS_malloc_info() - Determine amount of teraspace memory used
     D TS_malloc_info...
     D                 PR            10I 0 extproc('_C_TS_malloc_info')
     D  o_c_mallinfo                       const  likeds(C_mallinfo_t)
     D  i_size                       10U 0 value
      *
      *  _C_TS_malloc_debug() - Determine amount of teraspace memory
      *                         used (with optional dumps and verification)
     D TS_malloc_debug...
     D                 PR            10I 0 extproc('_C_TS_malloc_debug')
     D  i_dump_level                 10U 0 value
     D  i_vrfy_level                 10U 0 value
     D  o_c_mallinfo                       const  likeds(C_mallinfo_t)
     D  i_size                       10U 0 value
      *
      * The following are possible values for the dump_level parameter
     D C_NO_DUMPS      C                   0
      *  Dumps the _C_mallinfo_t structure:
     D C_DUMP_TOTALS   C                   1
      *  Does a hex dump of all allocated chunks of teraspace storage,
      *  this is the entire 512K chunk of storage:
     D C_DUMP_CHUNKS   C                   2
      *  Dumps each of the allocated nodes.
      *  There is a node for each malloc performed with the header
      *  associated with that malloc:
     D C_DUMP_NODES    C                   3
      *  Dumps the cartesian tree used to keep track of the freed nodes:
     D C_DUMP_TREE     C                   4
     D C_DUMP_ALL      C                   9999
      *
      *  The following are possible values for the verify_level parameter
     D C_NO_CHECKS     C                   0
     D C_CHECK_TOTALS  C                   1
     D C_CHECK_CHUNKS  C                   2
     D C_CHECK_NODES   C                   3
     D C_CHECK_TREE    C                   4
     D C_CHECK_ALL     C                   9998
      *  Will call abort() if verification fails
     D C_CHECK_ALL_AND_ABORT...
     D                 C                   9999
      *
      * The following structure is used to return information
      * from the _C_TS_malloc_info routine.  The fields are:
      *   total_bytes        - bytes allocated from system
      *                        (high water mark)
      *   allocated_bytes    - number of allocated bytes
      *   unallocated_bytes  - number of unallocated bytes
      *   allocated_blocks   - number of allocated blocks
      *   unallocated_blocks - number of unallocated blocks
      *   requested_bytes    - bytes actually requested from malloc
      *   pad_bytes          - bytes used to pad allocation length
      *                        to a multiple of 16
      *   overhead_bytes     - bytes used for malloc overhead
     D C_mallinfo_t...
     D                 DS                  qualified               based(pDummy)
     D  total_bytes...
     D                               20I 0
     D  allocated_bytes...
     D                               20I 0
     D  unallocated_bytes...
     D                               20I 0
     D  allocated_blocks...
     D                               20I 0
     D  unallocated_blocks...
     D                               20I 0
     D  requested_bytes...
     D                               20I 0
     D  pad_bytes...
     D                               20I 0
     D  overhead_bytes...
     D                               20I 0
      *
      *  malloc -- Reserve Storage Block
     D malloc          PR              *          extproc('malloc')
     D  i_size                       10U 0 value
      *
      *  realloc -- Change Reserved Storage Block Size
     D realloc         PR              *          extproc('realloc')
     D  i_pMem                         *   value
     D  i_size                       10U 0 value
      *
      *  free -- Release Storage Blocks
     D free            PR                         extproc('free')
     D  i_pMem                         *   value
      *
      *  srand -- Set Seed for rand Function   e.g.:   srand(getSeed(*null))
     D srand           PR                         extproc('srand')
     D  i_seed                       10U 0 value
      *
      *  rand -- Generate Random Number                x = rand()
     D rand            PR            10I 0        extproc('rand')
      *
     D RAND_MAX        C                   const(32767)
      *
      *  getSeed -- Get Seed for srand function
     D getSeed         PR            10I 0        extproc('time')
     D  i_timePtr                      *   value
      *
      *  strlen -- Determine String Length
     D strlen...
     D                 PR            10U 0 extproc('strlen')
     D  i_string                       *   value
      *
      *  tmpnam -- Produce Temporary File Name
     D tmpnam          PR              *          extproc('tmpnam')
     D  pTmpNme                        *   value
      *
      *  _C_IFS_tmpnam -- Produce Temporary File Name for the IFS file system
     D ifs_tmpnam      PR              *          extproc('_C_IFS_tmpnam')
     D  fileName                       *   value
      *
     D L_tmpnam        C                   const(39)                            ! <stdio.h>
      *
     D TMP_MAX         C                   const(32767)                         ! <stdio.h>
      *
      *  qsort -- Sort Array
     D qsort           PR              *                       extproc('qsort')
     D  memPtr                         *   value
     D  numElem                            value  like(size_t)
     D  width                              value  like(size_t)
     D  pSortFunc                      *   value  procptr
      *
      *  bsearch -- Search Arrays
     D bsearch         PR              *          extproc('bsearch')
     D  keyPtr                         *   value
     D  memPtr                         *   value
     D  numElem                            value  like(size_t)
     D  width                              value  like(size_t)
     D  pSearchFnc                     *   value  procptr
      *
      *  iconv_open()--Code Conversion Allocation API
     D iconv_open...
     D                 PR                  extproc('iconv_open')
     D                                     like(iconv_t   )
     D  i_toCode                       *   value
     D  i_fromCode                     *   value
      *
     D iconv_t         DS                  qualified   based(pDummy)   align
     D  return_value                 10I 0
     D  cd                           10I 0 dim(12)
      *
     D iconv_fromcode_t...
     D                 DS                  qualified   based(pDummy)
     D  ibmccsid                      8A
     D  ccsid                         5A
     D  convAlt                       3A
     D  substAlt                      1A
     D  shiftStateAlt                 1A
     D  inpLengthOpt                  1A
     D  errOption                     1A
     D  reserved                     12A
      *
     D iconv_tocode_t...
     D                 DS                  qualified   based(pDummy)
     D  ibmccsid                      8A
     D  ccsid                         5A
     D  reserved                     19A
      *
      *  QtqIconvOpen()--Code Conversion Allocation API
     D QtqIconv_open...
     D                 PR                  extproc('QtqIconvOpen')
     D                                     likeds(iconv_t )
     D  i_toCode                           const  likeds(QtqCode_t)
     D  i_fromCode                         const  likeds(QtqCode_t)
      *
     D QtqCode_t...
     D                 DS                  qualified   based(pDummy)
     D  ccsid                        10I 0
     D  conversionA                  10I 0
     D  substitutionA                10I 0
     D  shiftStateA                  10I 0
     D  inpLenOpt                    10I 0
     D  errOptMxdDta                 10I 0
     D  reserved                     12A
      *
      *  iconv()--Code Conversion API
     D iconv...
     D                 PR            10U 0        extproc('iconv')
     D  i_cd                               value likeds(iconv_t  )
     D  i_pInBuf                       *
     D  i_inBytLeft                  10U 0
     D  i_pOutBuf                      *
     D  i_outBytLeft                 10U 0
      *
     D cICONV_ERROR    C                   const(4294967295)
      *
      *  iconv_close()--Code Conversion Deallocation API
     D iconv_close...
     D                 PR            10I 0        extproc('iconv_close')
     D  i_cd                               value likeds(iconv_t  )
      *
      *  0/-1 = stat()--Get File Information                include <sys/stat.h>
     D stat...
     D                 PR            10I 0        extproc('stat')               = int
     D  i_pPath                        *   value options(*string)               = *path
     D  i_pStat                        *   value                                = *buf
      *
      *  0/-1 = fstat()--Get File Information by Descriptor include <sys/stat.h>
     D fstat...
     D                 PR            10I 0        extproc('fstat')              = int
     D  i_fd                         10I 0 value                                = int
     D  i_stat                             const likeds(st_stat_t)              = *buf
      *
      *  0/-1 = lstat()--Get File or Link Information       include <sys/stat.h>
     D lstat...
     D                 PR            10I 0        extproc('lstat')              = int
     D  i_pPath                        *   value options(*string)               = *path
     D  i_pStat                        *   value                                = *buf
      *
     D st_stat_t       DS                  qualified   based(pDummy)   align
     D  mode                         10U 0                                      mode_t =uint
     D  ino                          10U 0                                      ino_t  =uint
     D  nlink                         5U 0                                      nlink_t=ushort
     D  reserved2                     2A
     D  uid                          10U 0                                      uid_t  =uint
     D  gid                          10U 0                                      gid_t  =uint
     D  size                         10I 0                                      off_t  =int
     D  atime                        10I 0                                      time_t =long
     D  mtime                        10I 0                                      time_t =long
     D  ctime                        10I 0                                      time_t =long
     D  dev                          10U 0                                      dev_t  =uint
     D  blksize                      10U 0                                      size_t =uint
     D  allocsize                    10U 0                                      ulong
     D  objtype                      11A                                        qp0l_objtype_t
     D  reserved3                     1A
     D  codepage                      5U 0                                      ushort
     D  ccsid                         5U 0                                      ushort
     D  rdev                         10U 0                                      dev_t  =uint
     D  nlink32                      10U 0                                      nlink32_t=ulng
     D  rdev64                       20U 0                                      dev64_t=ullng
     D  dev64                        20U 0                                      dev64_t=ullng
     D  reserved1                    36A
     D  ino_gen_id                   10U 0                                      uint
      *
      *  Qp0lGetAttr()--Get Attributes
     D Qp0lGetAttr...
     D                 PR            10I 0 extproc('Qp0lGetAttr')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
     D  i_attrArray                        const  like(Qlg_attrArray_t  )
     D  i_pBuffer                      *   value
     D  i_bytPrv                     10U 0 value
     D  o_sizeNeeded                 10U 0
     D  o_bytRet                     10U 0
     D  i_followLnk                  10U 0 value
      *
      /if not defined(Qlg_Path_Name)
      /define Qlg_Path_Name
     D Qlg_Path_Name_t...
     D                 DS                  qualified align         based(pDummy)
     D   CCSID                       10I 0
     D   Country_ID                   2A
     D   Language_ID                  3A
     D   Reserved                     3A
     D   Path_Type                   10U 0
     D   Path_Length                 10I 0
     D   Path_Name_Delimiter...
     D                                2A
     D   Reserved2                   10A
     D   Path_Name                  256A
      *
     D QLG_PATH_JOB_CCSID...
     D                 C                   const(0)
     D QLG_PATH_JOB_COUNTRYID...
     D                 C                   const(X'0000')
     D QLG_PATH_JOB_LANGUAGEID...
     D                 C                   const(X'000000')
      *
      *  The Path_Name is a character string and the delimiter is one byte long.
     D QLG_CHAR_SINGLE...
     D                 C                   const(0)
      *
      *  The Path_Name is a pointer and the delimiter is one byte long.
     D QLG_PTR_SINGLE...
     D                 C                   const(1)
      *
      *  The Path_Name is a character string and the delimiter is two bytes long.
     D QLG_CHAR_DOUBLE...
     D                 C                   const(2)
      *
      *  The Path_Name is a pointer and the delimiter is two bytes long.
     D QLG_PTR_DOUBLE...
     D                 C                   const(3)
      *
      /endif
      *
     D Qlg_attrArray_t...
     D                 DS                  qualified               based(pDummy)
     D  numE                         10I 0
     D  attr                         10I 0 dim(64)
      *
     D Qlg_rtnAttr_t...
     D                 DS                  qualified               based(pDummy)
     D  ofsNextAttr                  10I 0
     D  ID                           10I 0
     D  size                         10I 0
     D  reserved                      4A
      *
     D QP0L_ATTR_OBJTYPE...
     D                 C                   const(0)                             CHAR(10)
     D QP0L_ATTR_DATA_SIZE...
     D                 C                   const(1)                             UINT(4)
     D QP0L_ATTR_ALLOC_SIZE...
     D                 C                   const(2)                             UINT(4)
     D QP0L_ATTR_EXTENDED_ATTR_SIZE...
     D                 C                   const(3)                             UINT(4)
     D QP0L_ATTR_CREATE_TIME...
     D                 C                   const(4)                             UINT(4)
     D QP0L_ATTR_ACCESS_TIME...
     D                 C                   const(5)                             UINT(4)
     D QP0L_ATTR_CHANGE_TIME...
     D                 C                   const(6)                             UINT(4)
     D QP0L_ATTR_MODIFY_TIME...
     D                 C                   const(7)                             UINT(4)
     D QP0L_ATTR_STG_FREE...
     D                 C                   const(8)                             CHAR(1)
     D QP0L_ATTR_CHECKED_OUT...
     D                 C                   const(9)                             chkOut Fmt
     D QP0L_ATTR_LOCAL_REMOTE...
     D                 C                   const(10)                            CHAR(1)
      *
     D QP0L_DONOT_FOLLOW_SYMLNK...
     D                 C                   const(x'00')
     D QP0L_FOLLOW_SYMLNK...
     D                 C                   const(x'01')
      *
     D QP0L_NOT_CHECKED_OUT...
     D                 C                   const(x'00')
     D QP0L_CHECKED_OUT...
     D                 C                   const(x'01')
      *
     D QP0L_LOCAL_OBJ...
     D                 C                   const(x'01')
     D QP0L_REMOTE_OBJ...
     D                 C                   const(x'02')
      *
      *  QlgGetcwd()--Get Current Directory (using NLS-enabled path name)
      *  Returns: Qlg_Path_Name_T
     D QlgGetcwd...
     D                 PR              *   extproc('QlgGetcwd')
     D  o_path                             const  likeds(Qlg_Path_Name_t)
     D  i_size                             value  like(size_t)
      *
      *  getcwd()--Get Current Directory
     D getcwd...
     D                 PR              *   extproc('getcwd')
     D  o_path                    65535A   const  options(*varsize)
     D  i_size                             value  like(size_t)
      *
      *  QlgChdir()--Change Current Directory (using NLS-enabled path name)
      *  Returns: Qlg_Path_Name_T
     D QlgChdir...
     D                 PR            10I 0 extproc('QlgChdir')
     D  i_path                             const  likeds(Qlg_Path_Name_t)
      *
      *  chdir()--Change Current Directory
     D chdir...
     D                 PR            10I 0 extproc('chdir')
     D  i_path                         *   value  options(*string)
      *
      *  QSYSINC/SYS.TYPES
     D off_t           S             10I 0 based(pDummy)
     D size_t          S             10U 0 based(pDummy)
     D ssize_t         S             10I 0 based(pDummy)
     D time_t          S             10I 0 based(pDummy)
      *
      *  0/-1 = chmod()--Change File Authorizations         include <sys/stat.h>
     D chmod...
     D                 PR            10I 0        extproc('chmod')              = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_mode                       10U 0 value                                = mode_t =uint
      *
      *  mkdir()--Make Directory                            include <sys/stat.h>
     D mkdir...
     D                 PR            10I 0        extproc('mkdir')              = rc
     D  i_pPath                        *   value options(*string)               = *path
     D  i_mode                       10U 0 value                                = mode_t =uint
      *
      *  rmdir()--Remove Directory                          include <sys/stat.h>
     D rmdir...
     D                 PR            10I 0        extproc('rmdir')              = rc
     D  i_pPath                        *   value options(*string)               = *path
      *
      *  opendir()--Open Directory                          include <dirent.h>
     D opendir...
     D                 PR              *          extproc('opendir')            = *DIR
     D  i_pDirName                     *   value options(*string)               = *dirname
      *
      *  readdir()--Read Directory Entry
     D readdir...
     D                 PR              *          extproc('readdir')            = *dirent
     D  i_dirp                         *   value                                = *DIR
      *
     D dirent_t        DS                  qualified  based(pDummy)
     D   d_reserv1                   16A
     D   d_fileno_gen_id...
     D                               10U 0
     D   d_fileno                    10U 0
     D   d_reclen                    10U 0
     D   d_reserv3                   10I 0
     D   d_reserv4                    8A
      /if not defined(*V5R2M0)
     D   d_nlsinfo                         like(qlg_nls_t)
      /else
     D   d_nlsinfo                         likeds(qlg_nls_t)
      /endif
     D   d_namelen                   10U 0
     D   d_name                     640A
      *
     D qlg_nls_t       DS                  qualified  based(pDummy)    align
     D  ccsid                        10I 0
     D  country_id                    2A
     D  language_id                   3A
     D  nls_reserved                  3A
      *
      *  rewinddir()--Reset Directory Stream to Beginning
     D rewinddir...
     D                 PR                  extproc('rewinddir')
     D  i_dirp                         *   value                                = *DIR
      *
      *  closedir()--Close Directory
     D closedir...
     D                 PR            10I 0        extproc('closedir')           = rc
     D  i_dirp                         *   value                                = *DIR
      *
      *  fd/-1 = open()--Open File                          include <fcntl.h>
     D open...
     D                 PR            10I 0        extproc('open')               = int
     D  i_pPath                        *   value  options(*string)              = *path
     D  i_opnFLag                    10I 0 value                                = int
     D  i_mode                       10U 0 value  options(*nopass)              = uint
     D  i_codePage                   10U 0 value  options(*nopass)              = uint
     D  i_crtCodePage                10U 0 value  options(*nopass)              = uint
      *
      *  <sys/stat.h>
     D S_IRUSR         C                   const(         256)                  ! Read For Own
     D S_IWUSR         C                   const(         128)                  ! Write For Ow
     D S_IXUSR         C                   const(          64)                  ! Exc/Srch For
     D S_IRWXU         C                   const(         448)                  ! Rd/Wrt/Exc O
      *
     D S_IRGRP         C                   const(          32)                  ! Read For Gro
     D S_IWGRP         C                   const(          16)                  ! Write For Gr
     D S_IXGRP         C                   const(           8)                  ! Exc/Srch For
     D S_IRWXG         C                   const(          56)                  ! Rd/Wrt/Exc G
      *
     D S_IROTH         C                   const(           4)                  ! Read For Oth
     D S_IWOTH         C                   const(           2)                  ! Write For Ot
     D S_IXOTH         C                   const(           1)                  ! Exc/Srch For
     D S_IRWXO         C                   const(           7)                  ! Rd/Wrt/Exc O
      *
     D S_ISUID         C                   const(        2048)
     D S_ISGID         C                   const(        1024)
     D S_ISVTX         C                   const(         512)
      *
      *  <h/fcntl.h>
     D O_CREAT         C                   const( 8)                            ! Append Mode
     D O_EXCL          C                   const(16)                            ! Exclusive Us
     D O_TRUNC         C                   const(64)                            ! Truncate Fla
      *
     D O_APPEND        C                   const(256)                           ! Append Mode
      *
     D O_CODEPAGE      C                   const(  8388608)                     ! Codepage Fla
     D O_TEXTDATA      C                   const( 16777216)                     ! Text Data Fl
     D O_FORCE_SCAN    C                   const( 67108864)                     ! Force scan
     D O_INHERITMODE   C                   const(134217728)                     ! Inherit Mode
     D O_CCSID         C                   const(       32)                     ! CCSID
     D O_TEXT_CREAT    C                   const( 33554432)                     !
      *
     D O_SHARE_RDONLY  C                   const( 65536)                        ! Shared Read
     D O_SHARE_WRONLY  C                   const(131072)                        ! Shared Write
     D O_SHARE_RDWR    C                   const(262144)                        ! Shared Rd/Wr
     D O_SHARE_NONE    C                   const(524288)                        ! No Share
      *
     D O_RDONLY        C                   const(1)                             ! Read Only
     D O_WRONLY        C                   const(2)                             ! Write Only
     D O_RDWR          C                   const(4)                             ! Read/Write
      *
      *  value/-1 = read()--Write from Descriptor           include <unistd.h>
     D read...
     D                 PR                  extproc('read')   like(ssize_t   )   = ssize_t
     D  i_fd                         10I 0 value                                = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_buflen                           value like(size_t    )               = size_t
      *
      *  value/-1 = write()--Write to Descriptor            include <unistd.h>
     D write...
     D                 PR                  extproc('write')  like(ssize_t   )   = ssize_t
     D  i_fd                         10I 0 value                                = int
     D  i_pBuffer                      *   value                                = *buf
     D  i_buflen                           value like(size_t    )               = size_t
      *
      *  0/-1 = ftruncate()--Truncate File                  include <unistd.h>
     D ftruncate...
     D                 PR            10I 0 extproc('ftruncate')                 = int
     D  i_fd                         10I 0 value                                = int
     D  i_length                           value like(off_t     )               = off_t
      *
      *  off_t = lseek()--Set File Read/Write Offset        include <unistd.h>
     D lseek...
     D                 PR                  extproc('lseek')  like(off_t     )   = off_t
     D  i_fd                         10I 0 value                                = int
     D  i_offset                           value like(off_t     )               = off_t
     D  i_whence                     10I 0 value                                = int
      *
      *  <h/unistd.h>
     D SEEK_SET        C                   const(0)                             ! seek start
     D SEEK_CUR        C                   const(1)                             ! seek curPos
     D SEEK_END        C                   const(2)                             ! seek end
      *
      *  0/-1 = unlink()--Remove Link to File               include <unistd.h>
     D unlink...
     D                 PR            10I 0 extproc('unlink')                    = int
     D  i_pPath                        *   value options(*string)               = *path
      *
      *  0/-1 = Qp0lRenameKeep()--Rename File or Directory, Keep "new" If It Exists
     D Qp0lRenameKeep...
     D                 PR            10I 0 extproc('Qp0lRenameKeep')            = int
     D  i_pOldPath                     *   value options(*string)               = *path
     D  i_pNewPath                     *   value options(*string)               = *path
      *
      *  0/-1 = Qp0lRenameUnlink()--Rename File or Directory, Unlink "new" If It Exists
     D Qp0lRenameUnlink...
     D                 PR            10I 0 extproc('Qp0lRenameUnlink')          = int
     D  i_pOldPath                     *   value options(*string)               = *path
     D  i_pNewPath                     *   value options(*string)               = *path
      *
      *  0/-1 = close()--Close File or Socket Descriptor    include <unistd.h>
      /IF NOT DEFINED(c_close_function)
      /DEFINE c_close_function
     D close...
     D                 PR            10I 0 extproc('close')                     = int
     D  i_fd                         10I 0 value                                = int
      /ENDIF
      *
      *  erno--Set Pointer to Runtime Error Code
     D errno           PR              *                     extproc('__errno')
      *
      *  strerror -- Set Pointer to Runtime Error Message
     D strerror        PR              *                     extproc('strerror')
     D  errno                        10I 0 value
      *
      *  <sys/errno.h>
     D EDOM_C          C                   const(3001)                          domain error i
     D ERANGE_C        C                   const(3002)                          range error in
     D ETRUNC_C        C                   const(3003)                          truncation on
     D ENOTOPEN_C      C                   const(3004)                          file has not b
     D ENOTREAD_C      C                   const(3005)                          file not opene
     D ERECIO_C        C                   const(3008)                          file opened fo
     D ENOTWRITE_C     C                   const(3009)                          file not opene
     D ESTDIN_C        C                   const(3010)                          stdin cannot b
     D ESTDOUT_C       C                   const(3011)                          stdout cannot
     D ESTDERR_C       C                   const(3012)                          stderr cannot
     D EBADSEEK_C      C                   const(3013)                          bad offset to
     D EBADNAME_C      C                   const(3014)                          invalid file n
     D EBADMODE_C      C                   const(3015)                          invalid file m
     D EBADPOS_C       C                   const(3017)                          invalid positi
     D ENOPOS_C        C                   const(3018)                          no record at s
     D ENUMMBRS_C      C                   const(3019)                          no ftell if mo
     D ENUMRECS_C      C                   const(3020)                          no ftell if to
     D EBADFUNC_C      C                   const(3022)                          invalid functi
     D ENOREC_C        C                   const(3026)                          record not fou
     D EBADDATA_C      C                   const(3028)                          message data i
     D EBADOPT_C       C                   const(3040)                          bad option on
     D ENOTUPD_C       C                   const(3041)                          file not opene
     D ENOTDLT_C       C                   const(3042)                          file not opene
     D EPAD_C          C                   const(3043)                          padding occurr
     D EBADKEYLN_C     C                   const(3044)                          bad key length
     D EPUTANDGET_C    C                   const(3080)                          illegal write
     D EGETANDPUT_C    C                   const(3081)                          illegal read a
     D EIOERROR_C      C                   const(3101)                          I/O exception
     D EIORECERR_C     C                   const(3102)                          I/O exception
      *
      *  The following values are defined by POSIX ISO/IEC 9945-1:1990.
     D EINVAL_C        C                   const(3021)                          invalid argume
     D EIO_C           C                   const(3006)                          input/output e
     D ENODEV_C        C                   const(3007)                          no such device
     D EBUSY_C         C                   const(3029)                          resource busy
     D ENOENT_C        C                   const(3025)                          no such file o
     D EPERM_C         C                   const(3027)                          operation not
      *
      *  AS/400 specific error numbers
     D EACCES_C        C                   const(3401)                          Permission den
     D ENOTDIR_C       C                   const(3403)                          Not a director
     D ENOSPC_C        C                   const(3404)                          No space avail
     D EXDEV_C         C                   const(3405)                          Improper link.
     D EWOULDBLOCK_C   C                   const(3406)                          Operation woul
     D EAGAIN_C        C                   const(3406)                          Operation woul
     D EINTR_C         C                   const(3407)                          Interrupted fu
     D EFAULT_C        C                   const(3408)                          The address us
     D ETIME_C         C                   const(3409)                          Operation time
     D ENXIO_C         C                   const(3415)                          No such device
     D ECLOSED_C       C                   const(3417)                          Socket closed
     D EADDRINUSE_C    C                   const(3420)                          Address alread
     D EADDRNOTAVAIL_C...
     D                 C                   const(3421)                          Address not av
     D EAFNOSUPPORT_C  C                   const(3422)                          The type of so
     D EALREADY_C      C                   const(3423)                          Operation alre
     D ECONNABORTED_C  C                   const(3424)                          Connection end
     D ECONNREFUSED_C  C                   const(3425)                          A remote host
     D ECONNRESET_C    C                   const(3426)                          A connection w
     D EDESTADDRREQ_C  C                   const(3427)                          Operation requ
     D EHOSTDOWN_C     C                   const(3428)                          A remote host
     D EHOSTUNREACH_C  C                   const(3429)                          A route to the
     D EINPROGRESS_C   C                   const(3430)                          Operation in p
     D EISCONN_C       C                   const(3431)                          A connection h
     D EMSGSIZE_C      C                   const(3432)                          Message size o
     D ENETDOWN_C      C                   const(3433)                          The network is
     D ENETRESET_C     C                   const(3434)                          A socket is co
     D ENETUNREACH_C   C                   const(3435)                          Cannot reach t
     D ENOBUFS_C       C                   const(3436)                          There is not e
     D ENOPROTOOPT_C   C                   const(3437)                          The protocol d
     D ENOTCONN_C      C                   const(3438)                          Requested oper
     D ENOTSOCK_C      C                   const(3439)                          The specified
     D ENOTSUP_C       C                   const(3440)                          Operation not
     D EOPNOTSUPP_C    C                   const(3440)                          Operation not
     D EPFNOSUPPORT_C  C                   const(3441)                          The socket pro
     D EPROTONOSUPPORT_C...
     D                 C                   const(3442)                          No protocol of
     D EPROTOTYPE_C    C                   const(3443)                          The socket typ
     D ERCVDERR_C      C                   const(3444)                          An error indic
     D ESHUTDOWN_C     C                   const(3445)                          Cannot send da
     D ESOCKTNOSUPPORT_C...
     D                 C                   const(3446)                          The specified
     D ETIMEDOUT_C     C                   const(3447)                          A remote host
     D EUNATCH_C       C                   const(3448)                          The protocol r
     D EBADF_C         C                   const(3450)                          Descriptor not
     D EMFILE_C        C                   const(3452)                          Too many open
     D ENFILE_C        C                   const(3453)                          Too many open
     D EPIPE_C         C                   const(3455)                          Broken pipe.
     D EEXIST_C        C                   const(3457)                          File exists.
     D EDEADLK_C       C                   const(3459)                          Resource deadl
     D ENOMEM_C        C                   const(3460)                          Storage alloca
     D EOWNERTERM_C    C                   const(3462)                          The mutex no l
     D EDESTROYED_C    C                   const(3463)                          he synchroniza
     D ETERM_C         C                   const(3464)                          Operation term
     D EMLINK_C        C                   const(3468)                          Maximum link c
     D ESPIPE_C        C                   const(3469)                          Seek request n
     D ENOSYS_C        C                   const(3470)                          Function not i
     D EISDIR_C        C                   const(3471)                          Specified targ
     D EROFS_C         C                   const(3472)                          Read-only file
     D EUNKNOWN_C      C                   const(3474)                          Unknown system
     D EITERBAD_C      C                   const(3475)                          Iterator is in
     D EDAMAGE_C       C                   const(3484)                          A damaged obje
     D ELOOP_C         C                   const(3485)                          A loop exists
     D ENAMETOOLONG_C  C                   const(3486)                          A path name is
     D ENOLCK_C        C                   const(3487)                          No locks avail
     D ENOTEMPTY_C     C                   const(3488)                          Directory not
     D ENOSYSRSC_C     C                   const(3489)                          System resourc
     D ECONVERT_C      C                   const(3490)                          Conversion err
     D E2BIG_C         C                   const(3491)                          Argument list
     D EILSEQ_C        C                   const(3492)                          Conversion sto
     D ESOFTDAMAGE_C   C                   const(3497)                          Object has sof
     D ENOTENROLL_C    C                   const(3498)                          User not enrol
     D EOFFLINE_C      C                   const(3499)                          Object is susp
     D EROOBJ_C        C                   const(3500)                          Object is a re
     D ELOCKED_C       C                   const(3506)                          Area being rea
     D EFBIG_C         C                   const(3507)                          Object too lar
     D EIDRM_C         C                   const(3509)                          The semaphore,
     D ENOMSG_C        C                   const(3510)                          The queue does
     D EFILECVT_C      C                   const(3511)                          File ID conver
     D EBADFID_C       C                   const(3512)                          A File ID coul
     D ESTALE_C        C                   const(3513)                          A File ID coul
     D ESRCH_C         C                   const(3515)                          No such proces
     D ENOTSIGINIT_C   C                   const(3516)                          Process not en
     D ECHILD_C        C                   const(3517)                          No child proce
     D EBADH_C         C                   const(3520)                          Handle is not
     D ETOOMANYREFS_C  C                   const(3523)                          The operation
     D ENOTSAFE_C      C                   const(3524)                          Function not a
     D EOVERFLOW_C     C                   const(3525)                          Object is too
     D EJRNDAMAGE_C    C                   CONST(3526)                          Journal damage
     D EJRNINACTIVE_C  C                   CONST(3527)                          Journal inacti
     D EJRNRCVSPC_C    C                   CONST(3528)                          Journal space
     D EJRNRMT_C       C                   CONST(3529)                          Journal is rem
     D ENEWJRNRCV_C    C                   CONST(3530)                          New journal re
     D ENEWJRN_C       C                   CONST(3531)                          New journal is
     D EJOURNALED_C    C                   CONST(3532)                          Object already
     D EJRNENTTOOLONG_C...
     D                 C                   CONST(3533)                          Entry too larg
     D EDATALINK_C     C                   CONST(3534)                          Object is a Da
     D ENOTAVAIL_C     C                   CONST(3535)                          Independent AS
     D ENOTTY_C        C                   CONST(3536)                          Inappropriate
     D EFBIG2_C        C                   CONST(3540)                          Write or trunc
     D ETXTBSY_C       C                   CONST(3543)                          Text file busy
     D EASPGRPNOTSET_C...
     D                 C                   CONST(3544)                          ASP group not
     D ERESTART_C      C                   CONST(3545)                          System call ca
     D ESCANFAILURE_C  C                   CONST(3546)                          Object marked
      *
      *  Unix return codes
     D RC_OK           C                   const(0)
     D RC_ERROR        C                   const(-1)
      *
      *  Convert External Form to Numeric Value (CVTEFN)
     D cvtefnd...
     D                 PR             8F   extproc('cvtefnd')
     D  i_source                       *   value
     D  i_len                        10U 0 value
     D  i_mask                         *   value
      *
      *  Test Bit in String (TSTBTS)
     D tstbts...
     D                 PR            10I 0 extproc('tstbts')
     D  bit_string                     *   value
     D  bit_offset                   10I 0 value
      *
      *  getenv()--Get Value of Environment Variable
     D getenv...
     D                 PR              *   extproc('getenv')
     D  name                           *   value  options(*string)
      *
      *  putenv()--Change or Add Environment Variable
     D putenv...
     D                 PR            10I 0 extproc('putenv')
     D  string                         *   value  options(*string)
      *
      *  Qp0zDltEnv()--Delete an Environment Variable
     D Qp0zDltEnv...
     D                 PR            10I 0 extproc('Qp0zDltEnv')
     D  name                           *   value  options(*string)
      *
      *  Qp0zInitEnv()--Initialize Environment for Variables
     D Qp0zInitEnv...
     D                 PR            10I 0 extproc('Qp0zInitEnv')
      *
     D ENVIRON         S               *   import('environ')
      *
      *  Generate Universal Unique Identifier (GENUUID)
     D genUUID...
     D                 PR                  extproc('_GENUUID')
     D  uuid_template                  *   value
      *
     D uuid_template_t...
     D                 DS                  qualified  based(pDummy)
     D  bytPrv                       10U 0
     D  bytAvl                       10U 0
     D  reserved                      8A
     D  uuid                         16A
      *
      *  Convert Hex to Character (CVTHC)
     D cvthc...
     D                 PR                  extproc('cvthc')
     D  pResult                        *   value
     D  pSource                        *   value
     D  sourceSize                   10I 0 value
      *
      *  Convert Eight Bit Character to Hex Nibbles (CVTCH)
     D cvtch...
     D                 PR                  extproc('cvtch')
     D  pResult                        *   value
     D  pSource                        *   value
     D  sourceLen                    10I 0 value
      *
      *  Cipher (CIPHER)
     D cipher...
     D                 PR                  extproc('_CIPHER')
     D                                 *   const
     D                                 *   value
     D                                 *   const
      *
     D cipherCtrls_t   DS                  qualified  based(pDummy)  align
     D  function               1      2A
     D  hashAlg                3      3A
     D  sequence               4      4A
     D  dataLength             5      8U 0
     D  output                 9      9A
     D  reserved_1            10     16A
     D  hashContext           17     32*
     D  HMACKey               33     48*
     D  HMACKeyLength         49     52U 0
     D  reserved_2            53     96A
      *
     D cCIPHER_MD5...
     D                 C                   const(x'00')
     D cCIPHER_SHA1...
     D                 C                   const(x'01')
      *
     D cCIPHER_ONLY...
     D                 C                   const(x'00')
     D cCIPHER_FIRST...
     D                 C                   const(x'01')
     D cCIPHER_MIDDLE...
     D                 C                   const(x'02')
     D cCIPHER_FINAL...
     D                 C                   const(x'03')
      *
     D cCIPHER_HASH...
     D                 C                   const(x'00')
     D cCIPHER_HMAC...
     D                 C                   const(x'01')
      *
 DEF  /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing COPYRIGHT  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "COPYRIGHT "
mbrtype =  "RPGLE     "
mbrtext =  "Copyright information                             "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /if not defined(COPYRIGHT_DSPEC)
     H COPYRIGHT('V1.0.2 - 26.11.2019 - mailto:thomas.raddatz@tools400.de')
      /eof
      /endif
     D JOBLOG_VERSION...
     D                 C                   '1.0.2'
     D JOBLOG_DATE...
     D                 C                   '26.04.2019'
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing FDQJOB  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "FDQJOB    "
mbrtype =  "RPGLE     "
mbrtext =  "cpybk   : Qualified job name                      "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(qJob_t    )
      /DEFINE qJob_t
      * ============================================================= *
      *   Qualified job name                                          *
      *===============================================================*
      *
     D qJob_t          DS                  qualified           based(pDummy)
     D  name                         10A
     D  user                         10A
     D  nbr                           6A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing H_SPEC  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "H_SPEC    "
mbrtype =  "RPGLE     "
mbrtext =  "H-Specifications                                  "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
      /IF NOT DEFINED(NO_DECEDIT)
     H DECEDIT('0,')
      /ENDIF
     H DATEDIT(*DMY.)
     H DATFMT(*ISO ) TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
     H CCSID(*CHAR: *JOBRUN)
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing JOBLOG  type MAKSRV - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "JOBLOG    "
mbrtype =  "MAKSRV    "
mbrtext =  "Job Log API                                       "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
     /* ===================================================================== */
     /*  Job Log API                                                          */
     /* ===================================================================== */
     /*  Author  :  Thomas Raddatz                                            */
     /*  Date    :  19.05.2013                                                */
     /*  E-mail  :  thomas.raddatz@Tools400.de                                */
     /*  Homepage:  www.tools400.de                                           */
     /* ===================================================================== */
     /* >>PRE-COMPILER<<                                                      */
     /*   >>CRTCMD<< CRTSRVPGM    SRVPGM(&LI/JOBLOG);                         */
     /*   >>LINK<<                                                            */
     /*     >>PARM<< MODULE(+                                                 */
     /*                     &LI/JOBLOG1   +                                   */
     /*                     );                                                */
     /*     >>PARM<< EXPORT(*SRCFILE);                                        */
     /*     >>PARM<<   SRCFILE(&SL/&SF);                                      */
     /*     >>PARM<<   SRCMBR(&SM);                                           */
     /*     >>PARM<< ACTGRP(*CALLER);                                         */
     /*     >>PARM<< ALWUPD(*YES);                                            */
     /*     >>PARM<< ALWLIBUPD(*YES);                                         */
     /*     >>PARM<< BNDSRVPGM(&LI/BASICS1);                                  */
     /*     >>PARM<< TEXT('Job Log API');                                     */
     /*     >>PARM<< TGTRLS(V7R1M0  );                                        */
     /*     >>PARM<< DETAIL(*BASIC);                                          */
     /*   >>END-LINK<<                                                        */
     /*   >>EXECUTE<<                                                         */
     /* >>END-PRE-COMPILER<<                                                  */
     /* ===================================================================== */

STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('Job_Log_API')

  EXPORT SYMBOL('JOBLOG1_JobLog_open')
  EXPORT SYMBOL('JOBLOG1_JobLog_getEntry')
  EXPORT SYMBOL('JOBLOG1_JobLog_close')

  EXPORT SYMBOL('JOBLOG1_JobLog_getNewest')
  EXPORT SYMBOL('JOBLOG1_JobLog_getOldest')
  EXPORT SYMBOL('JOBLOG1_JobLog_getMessageType')

  EXPORT SYMBOL('JOBLOG1_JobLog_isNull')
  EXPORT SYMBOL('JOBLOG1_JobLog_null')
ENDPGMEXP
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing JOBLOGT1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "JOBLOGT1  "
mbrtype =  "RPGLE     "
mbrtext =  "Job Log API - Example 1                           "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *===============================================================*
      *                                                               *
      *  erstellt : 19.05.2013                                        *
      *                                                               *
      *===============================================================*
      *                                                               *
      *  Kurzdokumentation :                                          *
      *                                                               *
      *  Rahmentestprogramm mit Protokollausgabe                      *
      *  Thema:                                                       *
      *     Job Log API - Example 1                                   *
      *                                                               *
      *===============================================================*
      * >>PRE-COMPILER<<                                              *
      *                                                               *
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +                   *
      *                           SRCFILE(&SL/&SF) +                  *
      *                           SRCMBR(&SM);                        *
      *                                                               *
      *   >>COMPILE<<                                                 *
      *     >>PARM<< TRUNCNBR(*NO);                                   *
      *     >>PARM<< DBGVIEW(*LIST);                                  *
      *   >>END-COMPILE<<                                             *
      *                                                               *
      *   >>EXECUTE<<                                                 *
      *                                                               *
      *   >>CMD<<    CRTPGM       PGM(&LI/&OB) +                      *
      *                           MODULE(&LI/&OB          +           *
      *                                          ) +                  *
      *                           BNDSRVPGM(*LIBL/BASICS1      +      *
      *                                     *LIBL/JOBLOG       +      *
      *                                          ) +                  *
      *                           BNDDIR(*N         ) +               *
      *                           DETAIL(*BASIC) +                    *
      *                           ACTGRP(*NEW);                       *
      *                                                               *
      * >>END-PRE-COMPILER<<                                          *
      *===============================================================*
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H DECEDIT('0,') DATEDIT(*DMY.)
     H DATFMT(*ISO )  TIMFMT(*ISO )
     H EXPROPTS(*RESDECPOS)
     H EXTBININT(*YES)
      *===============================================================*
     FQSYSPRT   O    F   80        PRINTER OFLIND(*in70)
      *
      * ------------------------------------
      *  Type definitions
      * ------------------------------------
      *
      * ------------------------------------
      *  External Prototypes
      * ------------------------------------
      /COPY QBASICS1,PBASICS1                      SrvPgm: Basics 1
      *
      *  Examinee
      /COPY QJOBLOG,PJOBLOG                        Job Log API
      *
      * ------------------------------------
      *  Global Fields
      * ------------------------------------
      *
      * ------------------------------------
      *  Globale Konstanten
      * ------------------------------------
      *
      * ------------------------------------
      *  Prototypes
      * ------------------------------------
      *
     D PGM_ENTRY_POINT...
     D                 PR                  extpgm('JOBLOGT1')
     D  gi_job                       28A   const options(*nopass)
      *
     D main...
     D                 PR                         extproc('main')
     D  i_qJob                             const likeds(qJob_t)
      *
      *  Logs a message to the job log or appends it to a spooled file
     D logMsg...
     D                 PR                         extproc('logMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Sends a message to QCMD
     D sndMsg...
     D                 PR                         extproc('sndMsg')
     D  i_text                      128A   value  varying
      *
      *  Prints a given message to QSYSPRT.
     D printMsg...
     D                 PR                  extproc('printMsg')
     D  i_text                      128A   value  varying options(*nopass)
      *
      *===============================================================*
      *  Program Entry Point
      *===============================================================*
     D PGM_ENTRY_POINT...
     D                 PI
     D  gi_job                       28A   const options(*nopass)
      *
     D g_s1            s             10i 0
     D g_s2            s             10i 0
     D g_qJob          ds                  likeds(qJob_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= %parmnum(gi_job) and gi_job <> '*');
           g_s1 = %scan('/': gi_job: 1);
           g_s2 = %scan('/': gi_job: g_s1+1);
           g_qJob.nbr = %subst(gi_job: 1: g_s1-1);
           g_qJob.user = %subst(gi_job: g_s1+1: g_s2-(g_s1+1));
           g_qJob.name = %subst(gi_job: g_s2+1);
         else;
           g_qJob.name = '*';
         endif;

         main(g_qJob);

         if (%open(QSYSPRT));
            close QSYSPRT;
         endif;

         *inlr = *on;

      /END-FREE
      *
      *===============================================================*
      *  *** private ***
      *  Logs a message to the job log or appends it to a spooled file
      *===============================================================*
     P logMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE


         if (%parms() >= 1);
            printMsg(i_text);
            // sndMsg(i_text);
         else;
            printMsg('');
            // no output to the job log
         endif;

      /END-FREE
      *
     P                 E
      *
      *===============================================================*
      *  *** private ***
      *  Sends a message to the caller.
      *===============================================================*
     P sndMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying
      *
      *  Return value
     D pBuffer         S               *   inz
      *
      *  Local fields
     D msgKey          S              4A                        inz
      *
     D qMsgF           DS                  qualified            inz
     D  name                         10A
     D  lib                          10A
      *
     D errCode         DS                  qualified            inz
     D  bytPrv                       10I 0
     D  bytAvl                       10I 0
     D  excID                         7A
     D  reserved                      1A
     D  excDta                      256A
      *
      *  Send Program Message (QMHSNDPM) API
     D QMHSNDPM        PR                         extpgm('QMHSNDPM')
     D   i_msgID                      7A   const
     D   i_qMsgF                     20A   const
     D   i_msgData                32767A   const  options(*varsize )
     D   i_length                    10I 0 const
     D   i_msgType                   10A   const
     D   i_callStkE               32767A   const  options(*varsize )
     D   i_callStkC                  10I 0 const
     D   o_msgKey                     4A
     D   io_ErrCode               32767A          options(*varsize )
     D   i_lenStkE                   10I 0 const  options(*nopass  )
     D   i_callStkEQ                 20A   const  options(*nopass  )
     D   i_wait                      10I 0 const  options(*nopass  )
     D   i_callStkEDT                10A   const  options(*nopass  )
     D   i_ccsid                     10I 0 const  options(*nopass  )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE
         clear qMsgF;
         qMsgF.name = 'QCPFMSG';
         qMsgF.lib  = '*LIBL';
         clear errCode;
         errCode.bytPrv = %size(errCode);
         QMHSNDPM('CPF9897': qMsgF: i_text: %len(i_text): '*INFO'
                  : '*CTLBDY': 1
                  : msgKey: errCode);
         return;

      /END-FREE
      *
     P                 E
      *
      * =====================================================================
      *  *** private ***
      *  Prints a given message to QSYSPRT.
      * =====================================================================
     P printMsg...
     P                 B
     D                 PI
     D  i_text                      128A   value  varying options(*nopass)
      *
      *  Local fields
     D lineOutput      DS            80    inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free
         if (not %open(QSYSPRT));
            open QSYSPRT;
         endif;
         if (%parms() >= 1);
            lineOutput = i_text;
         endif;
         write QSYSPRT lineOutput;
      /end-free
     P                 E
      *
      *===============================================================*
      *  Main procedure
      *===============================================================*
     P main...
     P                 B
      *
     D main...
     D                 PI
     D  i_qJob                             const likeds(qJob_t)
      *
      *  Helper fields
     D hJobLog         s                   like(JobLog_handle_t)
     D jobLogEntry     ds                  likeds(JobLog_jobLogEntry_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         // Retrieve first (oldest) job log entry.
         logMsg('Retrieving first (oldest) job log entry');
         JobLog_getOldest(i_qJob: jobLogEntry);
         logMsg(jobLogEntry.msgID + ' - ' + jobLogEntry.msgText);
         logMsg();

         // Retrieve last (newest) job log entry.
         logMsg('Retrieving last (newest) job log entry');
         JobLog_getNewest(i_qJob: jobLogEntry);
         logMsg(jobLogEntry.msgID + ' - ' + jobLogEntry.msgText);
         logMsg();

         // Open the job log
         logMsg('Retrieving job log entries from newest to oldest entry');
         hJobLog = JobLog_open(i_qJob: JOBLOG_OPTION_MSG +
                                       JOBLOG_OPTION_REPLACE_VARS +
                                       JOBLOG_OPTION_SENDER);

         // Spin through the job log entries from oldest to newest.
         dow (JobLog_getEntry(hJobLog: jobLogEntry));
            logMsg(jobLogEntry.msgID + ': ' +
                   %char(jobLogEntry.timeSent) + ' - ' + jobLogEntry.msgText);
         enddo;

         // Close the job log
         JobLog_close(hJobLog);

         // Open the job log
         logMsg('Retrieving job log entries from oldest to newest entry');
         hJobLog = JobLog_open(i_qJob: JOBLOG_OPTION_MSG +
                                       JOBLOG_OPTION_REPLACE_VARS +
                                       JOBLOG_OPTION_SENDER
                                     : JOBLOG_NEXT);

         // Spin through the job log entries from oldest to newest.
         dow (JobLog_getEntry(hJobLog: jobLogEntry));
            logMsg(jobLogEntry.msgID + ': ' +
                   %char(jobLogEntry.timeSent) + ' - ' + jobLogEntry.msgText);
         enddo;

         // Close the job log
         JobLog_close(hJobLog);

         return;

      /END-FREE
      *
     P main...
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing JOBLOG1  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "JOBLOG1   "
mbrtype =  "RPGLE     "
mbrtext =  "Job Log API - Public Interface                    "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      *=====================================================================*
      *  Job Log API                                                        *
      *=====================================================================*
      *  Author  :  Thomas Raddatz                                          *
      *  Date    :  19.05.2013                                              *
      *  E-mail  :  thomas.raddatz@Tools400.de                              *
      *  Homepage:  www.tools400.de                                         *
      *=====================================================================*
      *                                                                     *
      *  This software is free software, you can redistribute it and/or     *
      *  modify it under the terms of the GNU General Public License (GPL)  *
      *  as published by the Free Software Foundation.                      *
      *                                                                     *
      *  See GNU General Public License for details.                        *
      *          http://www.opensource.org                                  *
      *          http://www.opensource.org/licenses/gpl-license.html        *
      *                                                                     *
      *=====================================================================*
      *  History:                                                           *
      *                                                                     *
      *  Date        Name          Description                              *
      *  ----------  ------------  ---------------------------------------  *
      *  19.04.2019  Th.Raddatz    Fixed unexpected error because size of   *
      *                            buffer 'oljl0100_buffer' was too small.  *
      *                                                                     *
      *  26.11.2019  Th.Raddatz    Fixed problem, that QGYGTLE crashed with *
      *                            CPF3C53 (Job not found).                 *
      *                                                                     *
      *=====================================================================*
      *   >>PRE-COMPILER<<                                                  *
      *     >>CRTCMD<<  CRTRPGMOD   MODULE(&LI/&OB) +                       *
      *                             SRCFILE(&SL/&SF) +                      *
      *                             SRCMBR(&SM);                            *
      *     >>COMPILE<<                                                     *
      *       >>PARM<< TRUNCNBR(*NO);                                       *
      *       >>PARM<< DBGVIEW(*LIST);                                      *
      *       >>PARM<< TGTRLS(V7R1M0  );                                    *
      *       >>PARM<< OPTION(*EVENTF);                                     *
      *     >>END-COMPILE<<                                                 *
      *     >>EXECUTE<<                                                     *
      *   >>END-PRE-COMPILER<<                                              *
      *=====================================================================*
     H NOMAIN BNDDIR('QC2LE')
      /COPY QJOBLOG,H_SPEC
      /COPY QJOBLOG,COPYRIGHT
      *=====================================================================*
      *
      * ------------------------------------
      *  Constants
      * ------------------------------------
     D MSGKEY_NEXT...
     D                 c                   x'00000000'
     D MSGKEY_PREVIOUS...
     D                 c                   x'FFFFFFFF'
      *
      * ------------------------------------
      *  Type Definitions
      * ------------------------------------
     D handle_t        ds                  qualified based(pDummy)
     D  isOpen                         n
     D  isEOF                          n
     D  qJob                               likeds(qJob_t)
     D  direction                          like(JobLog_direction_t)
     D  strMsgKey                          like(JobLog_msgKey_t)
     D  rcdNbr                       10i 0
     D  listInf                            likeds(qgy_opnListInf_t)
     D  options                            likeds(listOptions_t)
      *
     D listOptions_t   ds                  qualified based(pDummy)
     D  isMsg                          n
     D  msgSelectId                  10i 0
     D  isMsgHelp                      n
     D  hlpSelectId                  10i 0
     D  isSender                       n
     D  isReceiver                     n
      *
     D mixedData_t     ds                  likeds(JobLog_stmts_t)
      *
      * ------------------------------------
      *  Exported prototypes
      * ------------------------------------
      /COPY QJOBLOG,PJOBLOG
      *
      * ------------------------------------
      *  Imported prototypes
      * ------------------------------------
      /COPY QJOBLOG,CLIB                          C Runtime Library
      /COPY QBASICS1,PBASICS1                     Tools/400 Runtime Library
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      /COPY QJOBLOG,OPNLSTAPIS                    Process Open List APIs
      /COPY QJOBLOG,QGYOLJBL                      Open List of Job Log Messages (QGYOLJBL) API
      *
      *  Opens the job log and returns the first entry.
     D openJobLog...
     D                 PR              n
     D                                     extproc('openJobLog')
     D  i_qJob                             const likeds(qJob_t)
     D  i_options                          const like(JobLog_options_t)
     D  i_direction                        const like(JobLog_direction_t)
     D  i_msgKey                           const like(JobLog_msgKey_t)
     D  o_listInf                                likeds(qgy_opnListInf_t)
     D  o_options                                likeds(listOptions_t)
     D  o_errCode                                likeds(errCode_t)
      *
      *  Returns the next/previous job log entry.
     D getJobLogEntry...
     D                 PR                        likeds(JobLog_jobLogEntry_t)
     D                                     extproc('getJobLogEntry')
     D  i_hRequest                         const like(qgy_opnListInf_t.hRequest)
     D  i_rcdNbr                     10i 0 const
     D  i_options                          const likeds(listOptions_t)
     D  o_listInf                                likeds(qgy_opnListInf_t)
     D  o_errCode                                likeds(errCode_t)
      *
      *  Retrieves the character data of the specified field identifier.
     D getCharData...
     D                 PR          8192a          varying
     D                                     extproc('getCharData')
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Retrieves the mixed data of the specified field identifier.
     D getMixedData...
     D                 PR                         likeds(mixedData_t)
     D                                     extproc('getMixedData')
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Retrieves the binary data of the specified field identifier.
     D getBinData...
     D                 PR            10i 0
     D                                     extproc('getBinData')
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Returns the data buffer of the specified field.
     D getData...
     D                 PR          8192a   varying
     D                                     extproc('getData')
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Returns the default message key for a given direction.
     D getDftMsgKey...
     D                 PR                         like(JobLog_msgKey_t)
     D                                     extproc('getDftMsgKey')
     D  i_direction                        const  like(JobLog_direction_t)
      *
      *  Returns timestamp the message was send to the job log.
     D getTimeSent...
     D                 PR              Z
     D                                     extproc('getTimeSent')
     D  i_oljl0100                         const  likeds(oljl0100_t)
      *
      * ------------------------------------
      *  Global fields & constants
      * ------------------------------------
      *
      *=========================================================================
      *  Opens a job log.
      *=========================================================================
      *  Parameters:
      *   i_qJob        - Optional. Job whose job log is opened.
      *                   Default: current job
      *   i_options     - Optional. Specifies the information that is
      *                   retrieved from the job log.
      *                   Default: JOBLOG_PREVIOUS
      *   i_direction   - Optional. Direction to list the job log messages.
      *                   Default: JOBLOG_OPTION_MSG + JOBLOG_OPTION_REPLACE_VARS
      *   i_strMsgKey   - Optional. The message key to be used to begin
      *                   searching for messages to list from the job.
      *                   Default: depending on i_options.
      *
      *  Returns:
      *   hJobLog         Handle of the job log.
      *=========================================================================
     P JobLog_open...
     P                 B                   export
     D                 PI                         like(JobLog_handle_t)
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*nopass: *omit)
     D  i_options                          const  like(JobLog_options_t)
     D                                            options(*nopass: *omit)
     D  i_direction                        const  like(JobLog_direction_t)
     D                                            options(*nopass: *omit)
     D  i_strMsgKey                        const  like(JobLog_msgKey_t)
     D                                            options(*nopass: *omit)
      *
      *  Return value
     D hJobLog         s                   like(JobLog_handle_t)
      *
      *  Parameter positions
     D p_qJob          c                   1
     D p_options       c                   2
     D p_direction     c                   3
     D p_strMsgKey     c                   4
      *
      *  Optional parameters
     D qJob            ds                  likeds(i_qJob) inz
     D options         s                   like(i_options) inz
     D direction       s                   like(i_direction) inz
     D strMsgKey       s                   like(i_strMsgKey) inz
      *
      *  Local fields
     D errCode         ds                  likeds(errCode_t) inz
      *
      *  Job log handle
     D handle          ds                  likeds(handle_t)
     D                                     based(pHandle)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_qJob and %addr(i_qJob) <> *NULL);
            qJob = i_qJob;
         else;
            qJob.name = '*';
         endif;

         if (%parms() >= p_options and %addr(i_options) <> *NULL);
            options = i_options;
         else;
            options = JOBLOG_OPTION_MSG + JOBLOG_OPTION_REPLACE_VARS;
         endif;

         if (%parms() >= p_direction and %addr(i_direction) <> *NULL);
            direction = i_direction;
         else;
            direction = JOBLOG_PREVIOUS;
         endif;

         if (%parms() >= p_strMsgKey and %addr(i_strMsgKey) <> *NULL);
            strMsgKey = i_strMsgKey;
         else;
            strMsgKey = getDftMsgKey(direction);
         endif;

         hJobLog = HANDLE_new('*JOBLOG': %size(handle_t));
         pHandle = HANDLE_getPointer(hJobLog);

         clear handle;
         handle.isOpen = cFalse;
         handle.isEOF = cTrue;
         handle.qJob = qJob;
         handle.direction = direction;
         handle.strMsgKey = strMsgKey;
         handle.rcdNbr = 0;
         clear handle.listInf;

         handle.isOpen = openJobLog(
                            handle.qJob: options: handle.direction
                            : handle.strMsgKey: handle.listInf
                            : handle.options: errCode);

         if (handle.isOpen);
            handle.isEOF = cFalse;
         endif;

         return hJobLog;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Closes a given job log.
      *=========================================================================
      *  Parameters:
      *   io_hJobLog    - Required. Handle that was returned by JobLog_open().
      *
      *  Returns:
      *   void
      *=========================================================================
     P JobLog_close...
     P                 B                   export
     D                 PI
     D  io_hJobLog                                like(JobLog_handle_t)
      *
      *  Local fields
     D errCode         ds                  likeds(errCode_t) inz
      *
      *  Job log handle
     D handle          ds                  likeds(handle_t)
     D                                     based(pHandle)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pHandle = HANDLE_getPointer(io_hJobLog);

         if (handle.isOpen);
            QGYCLST(handle.listInf.hRequest: errCode);
            handle.isOpen = cFalse;
         endif;

         HANDLE_delete(io_hJobLog);
         io_hJobLog = HANDLE_NULL;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the next job log entry.
      *=========================================================================
      *  Parameters:
      *   i_hJobLog     - Required. Handle that was returned by JobLog_open().
      *   o_jobLogEntry - Required.
      *
      *  Returns:
      *   hasData       - Returns cTrue if a job log entry is available,
      *                   else cFalse.
      *=========================================================================
     P JobLog_getEntry...
     P                 B                   export
     D                 PI              n
     D  i_hJobLog                          const  like(JobLog_handle_t)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Local fields
     D errCode         ds                  likeds(errCode_t) inz
      *
      *  Job log handle
     D handle          ds                  likeds(handle_t)
     D                                     based(pHandle)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pHandle = HANDLE_getPointer(i_hJobLog);

         if (not handle.isOpen);
            return cFalse;
         endif;

         if (handle.isEOF);
            return cFalse;
         endif;

         o_jobLogEntry = getJobLogEntry(handle.listInf.hRequest
                                        : handle.rcdNbr + 1
                                        : handle.options
                                        : handle.listInf
                                        : errCode);
         if (errCode.bytAvl <> 0);
            return cFalse;
         endif;

         handle.rcdNbr = handle.rcdNbr + 1;

         if (handle.rcdNbr >= handle.listInf.totalRcds);
            handle.isEOF = cTrue;
         endif;

         return cTrue;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the newest job log entry.
      *=========================================================================
      *  Parameters:
      *   i_qJob        - Optional. Full qualified name of the job whose
      *                   newest job log entry is returned.
      *   o_jobLogEntry - Required. Newest job log entry of the specified job.
      *
      *  Returns:
      *   isAvailable   - Returns cTrue on success, else cFalse.
      *=========================================================================
     P JobLog_getNewest...
     P                 B                   export
     D                 PI              n
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*omit)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Return value
     D isAvailable     s               n   inz(cFalse)
      *
      *  Parameter positions
     D p_qJob          c                   1
      *
      *  Optional parameters
     D qJob            ds                  likeds(i_qJob) inz
      *
      *  Local fields
     D listInf         ds                  likeds(qgy_opnListInf_t) inz
     D options         ds                  likeds(listOptions_t) inz
     D errCode         ds                  likeds(errCode_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_qJob and %addr(i_qJob) <> *NULL);
            qJob = i_qJob;
         else;
            qJob.name = '*';
         endif;

         isAvailable = cFalse;
         if (openJobLog(qJob
                        : JOBLOG_OPTION_MSG + JOBLOG_OPTION_REPLACE_VARS
                        : JOBLOG_PREVIOUS: getDftMsgKey(JOBLOG_PREVIOUS)
                        : listInf: options: errCode));
            o_jobLogEntry = getJobLogEntry(
                               listInf.hRequest: 1: options: listInf: errCode);
            if (listInf.RcdsRet > 0);
               isAvailable = cTrue;
            endif;
            QGYCLST(listInf.hRequest: errCode); // Close list
         endif;

         return isAvailable;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the oldest job log entry.
      *=========================================================================
      *  Parameters:
      *   i_qJob        - Optional. Full qualified name of the job whose
      *                   oldest job log entry is returned.
      *   o_jobLogEntry - Required. Oldest job log entry of the specified job.
      *
      *  Returns:
      *   isAvailable   - Returns cTrue on success, else cFalse.
      *=========================================================================
     P JobLog_getOldest...
     P                 B                   export
     D                 PI              n
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*omit)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Return value
     D isAvailable     s               n   inz(cFalse)
      *
      *  Parameter positions
     D p_qJob          c                   1
      *
      *  Optional parameters
     D qJob            ds                  likeds(i_qJob) inz
      *
      *  Local fields
     D listInf         ds                  likeds(qgy_opnListInf_t) inz
     D options         ds                  likeds(listOptions_t) inz
     D errCode         ds                  likeds(errCode_t) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         if (%parms() >= p_qJob and %addr(i_qJob) <> *NULL);
            qJob = i_qJob;
         else;
            qJob.name = '*';
         endif;

         isAvailable = cFalse;
         if (openJobLog(qJob
                        : JOBLOG_OPTION_MSG + JOBLOG_OPTION_REPLACE_VARS
                        : JOBLOG_NEXT: getDftMsgKey(JOBLOG_NEXT)
                        : listInf: options: errCode));
            o_jobLogEntry = getJobLogEntry(
                               listInf.hRequest: 1: options: listInf: errCode);
            if (listInf.RcdsRet > 0);
               isAvailable = cTrue;
            endif;
            QGYCLST(listInf.hRequest: errCode); // Close list
         endif;

         return isAvailable;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the message type of a given job log entry.
      *=========================================================================
      *  Parameters:
      *   job log entry - Job log entry returned by:
      *                      JobLog_getEntry()
      *                      JobLog_getNewest()
      *                      JobLog_getOldest()
      *
      *  Returns:
      *   msgType       - Message type
      *=========================================================================
     P JobLog_getMessageType...
     P                 B                   export
     D                 PI            10a
     D  i_jobLogEntry                      const  likeds(JobLog_jobLogEntry_t)
      *
     D msgType         s             10a   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         select;
         when (i_jobLogEntry.msgType = '01');
            msgType = '*COMP';
         when (i_jobLogEntry.msgType = '02');
            msgType = '*DIAG';
         when (i_jobLogEntry.msgType = '04');
            msgType = '*INFO';
         when (i_jobLogEntry.msgType = '05');
            msgType = '*INQ';
         when (i_jobLogEntry.msgType = '06');
            msgType = '*COPY';
         when (i_jobLogEntry.msgType = '08');
            msgType = '*RQS';
         when (i_jobLogEntry.msgType = '10');
            msgType = '*RQS';
         when (i_jobLogEntry.msgType = '14');
            msgType = '*NOTIFY';
         when (i_jobLogEntry.msgType = '15');
            msgType = '*ESCAPE';
         when (i_jobLogEntry.msgType = '16');
            msgType = '*NOTIFY';
         when (i_jobLogEntry.msgType = '17');
            msgType = '*ESCAPE';
         when (i_jobLogEntry.msgType = '21');
            msgType = '*REPLY';
         when (i_jobLogEntry.msgType = '22');
            msgType = '*REPLY';
         when (i_jobLogEntry.msgType = '23');
            msgType = '*REPLY';
         when (i_jobLogEntry.msgType = '24');
            msgType = '*REPLY';
         when (i_jobLogEntry.msgType = '25');
            msgType = '*REPLY';
         when (i_jobLogEntry.msgType = '26');
            msgType = '*REPLY';
         other;
            msgType = '*N';
         endsl;

         return msgType;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns cTrue if a given job log handle is NULL, else cFalse.
      *=========================================================================
      *  Parameters:
      *   i_hJobLog     - Required. Job log handle.
      *
      *  Returns:
      *   isNull        - Returns cTrue for a NULL handle, else cFalse.
      *=========================================================================
     P JobLog_isNull...
     P                 B                   export
     D                 PI              n
     D  i_hJobLog                                 like(JobLog_handle_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return Handle_isNull(i_hJobLog);

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns a NULL job log handle.
      *=========================================================================
      *  Parameters:
      *   void
      *
      *  Returns:
      *   handle        - A job log handle that is treated as NULL.
      *=========================================================================
     P JobLog_null...
     P                 B                   export
     D                 PI                         like(JobLog_handle_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         return Handle_null();

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Opens the job log.
      *=========================================================================
     P openJobLog...
     P                 B
     D                 PI              n
     D  i_qJob                             const likeds(qJob_t)
     D  i_options                          const like(JobLog_options_t)
     D  i_direction                        const like(JobLog_direction_t)
     D  i_msgKey                           const like(JobLog_msgKey_t)
     D  o_listInf                                likeds(qgy_opnListInf_t)
     D  o_options                                likeds(listOptions_t)
     D  o_errCode                                likeds(errCode_t)
      *
      *  Return value
     D isOpen          s               n   inz(cFalse)
      *
      *  Local fields
     D buffSize        s             10i 0 inz
     D buffer          s          65535a   based(pBuffer)
     D offs            s             10i 0 inz
      *
     D slcInf          ds                  likeds(QGYOLJBL_msgSlcInf)
     D sizeSlcInf      s             10i 0 inz
      *
     D numFldsRtn      s             10i 0 inz
     D fldsToRtn       ds
     D  fldRtn                       10i 0 dim(32)
     D sizeFldsRtn     s             10i 0 inz
      *
     D callMsgQ        s              4a   inz
     D sizeCallMsgQ    s             10i 0 inz
      *
     D oljl0100_buffer...
     D                 s           8192
     D  oljl0100       ds                  likeds(oljl0100_t)
     D                                     based(pOljl0100)
     D pOljl0100       s               *   inz(%addr(oljl0100_buffer))
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         numFldsRtn = 0;
         clear o_options;

         // Return message text (first-level message text)
         if (f_isBitOn(JOBLOG_OPTION_MSG: i_options));
            o_options.isMsg = cTrue;
            numFldsRtn += 1;
            if (f_isBitOn(JOBLOG_OPTION_REPLACE_VARS: i_options));
               fldRtn(numFldsRtn) = QGYOLJBL_MSG_WITH_RPLC_DATA;
            else;
               fldRtn(numFldsRtn) = QGYOLJBL_MSG;
            endif;
            o_options.msgSelectId = fldRtn(numFldsRtn);
         endif;

         // Return message help (second-level message text)
         if (f_isBitOn(JOBLOG_OPTION_MSG_HELP: i_options));
            o_options.isMsgHelp = cTrue;
            numFldsRtn += 1;
            select;
            when (f_isBitOn(JOBLOG_OPTION_REPLACE_VARS: i_options) and
                  f_isBitOn(JOBLOG_OPTION_RETURN_CTRL_CHARS: i_options));
               fldRtn(numFldsRtn)=QGYOLJBL_MSG_HLP_WITH_RPLC_DATA_AND_FMT_CHARS;
            when (f_isBitOn(JOBLOG_OPTION_REPLACE_VARS: i_options));
               fldRtn(numFldsRtn)=QGYOLJBL_MSG_HLP_WITH_RPLC_DATA;
            when (f_isBitOn(JOBLOG_OPTION_RETURN_CTRL_CHARS: i_options));
               fldRtn(numFldsRtn)=QGYOLJBL_MSG_HLP_WITH_FMT_CHARS;
            other;
               fldRtn(numFldsRtn)=QGYOLJBL_MSG_HLP;
            endsl;
            o_options.hlpSelectId = fldRtn(numFldsRtn);
         endif;

         // Return replacement data
         numFldsRtn += 1;
         fldRtn(numFldsRtn) = QGYOLJBL_RPLC_DATA;

         // Return message file library used
         numFldsRtn += 1;
         fldRtn(numFldsRtn) = QGYOLJBL_MSGF_LIB;

         // Return sender information
         if (f_isBitOn(JOBLOG_OPTION_SENDER: i_options));
            o_options.isSender = cTrue;
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_QSND_JOB;   // Sending job
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_TYPE;   // Sending type
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_PGM;    // Sending program
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_MODULE; // Sending module
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_PROC;   // Sending procedure
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_STMTS_ARRAY; // Send. stmts array
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_SND_USRPRF; // Sending suer profile
         else;
            o_options.isSender = cFalse;
         endif;

         // Return receiver information
         if (f_isBitOn(JOBLOG_OPTION_RECEIVER: i_options));
            o_options.isReceiver = cTrue;
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_RCV_TYPE;   // Receiving type
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_RCV_PGM;    // Receiving program
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_RCV_MODULE; // Receiving module
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_RCV_PROC;   // Receiving procedure
            numFldsRtn += 1;
            fldRtn(numFldsRtn) = QGYOLJBL_RCV_STMTS_ARRAY; // Recv. stmts array
         else;
            o_options.isReceiver = cFalse;
         endif;

         callMsgQ = '*';

         sizeSlcInf = %size(slcInf);
         sizeFldsRtn = numFldsRtn * 4;
         sizeCallMsgQ = %len(%trimR(callMsgQ));

         // Prepare selection information
         clear slcInf;
         slcInf.listDirection = i_direction;
         slcInf.qJob = i_qJob;
         slcInf.intJobID = '';
         slcInf.strMsgKey = i_msgKey;
         slcInf.maxMsgLen = JOBLOG_MAX_MSG_TEXT_LEN;
         slcInf.maxMsgHlpLen = 0;
         slcInf.ofsFldsIdnRtn = %size(slcInf);
         slcInf.numFldsRtn = numFldsRtn;
         slcInf.ofsCallMsgQNm = %size(slcInf) + sizeFldsRtn;
         slcInf.lenMsgQNm = 1;

         // Calculate buffer size of selection information
         buffSize = sizeSlcInf + sizeFldsRtn + sizeCallMsgQ;

         pBuffer = %alloc(%size(buffSize));
         offs = 0;
         memcpy(pBuffer + offs: %addr(slcInf): %size(slcInf));
         offs = offs + %size(slcInf);
         memcpy(pBuffer + offs: %addr(fldsToRtn): sizeFldsRtn);
         offs = offs + sizeFldsRtn;
         memcpy(pBuffer + offs: %addr(callMsgQ): sizeCallMsgQ);
         offs = offs + sizeCallMsgQ;

         clear o_errCode;
         o_errCode.bytAvl = %size(o_errCode);

         QGYOLJBL(oljl0100_buffer: %size(oljl0100_buffer): o_listInf: 0
                  : %subst(buffer: 1: buffSize)
                  : buffSize
                  : o_errCode);

         if (o_errCode.bytAvl = 0);
            isOpen = cTrue;
         else;
            isOpen = cFalse;
         endif;

         if (pBuffer <> *NULL);
            dealloc(N) pBuffer;
         endif;

         return isOpen;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the next/previous job log entry.
      *=========================================================================
     P getJobLogEntry...
     P                 B
     D                 PI                        likeds(JobLog_jobLogEntry_t)
     D  i_hRequest                         const like(qgy_opnListInf_t.hRequest)
     D  i_rcdNbr                     10i 0 const
     D  i_options                          const likeds(listOptions_t)
     D  o_listInf                                likeds(qgy_opnListInf_t)
     D  o_errCode                                likeds(errCode_t)
      *
      *  Return value
     D jobLogEntry     ds                  likeds(JobLog_jobLogEntry_t) inz
      *
      *  Local fields
     D oljl0100_buffer...
     D                 s          24576
     D  oljl0100       ds                  likeds(oljl0100_t)
     D                                     based(pOljl0100)
     D pOljl0100       s               *   inz(%addr(oljl0100_buffer))
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         QGYGTLE(oljl0100_buffer: %size(oljl0100_buffer)
                 : i_hRequest: o_listInf: 1: i_rcdNbr: o_errCode);

         clear jobLogEntry;

         if (o_errCode.bytAvl > 0);
            return jobLogEntry;
         endif;

         jobLogEntry.msgSeverity = oljl0100.msgSeverity;
         jobLogEntry.msgID = oljl0100.msgID;
         jobLogEntry.msgType = oljl0100.msgType;
         jobLogEntry.msgKey = oljl0100.msgKey;
         jobLogEntry.msgFile = oljl0100.msgFile;
         jobLogEntry.msgFLibSpcfd = oljl0100.msgFLibSpcfd;
         jobLogEntry.msgFLibUsed = getCharData(oljl0100_buffer
                                               : %size(oljl0100_buffer)
                                               : QGYOLJBL_MSGF_LIB);
         jobLogEntry.timeSent = getTimeSent(oljl0100);
         jobLogEntry.threadId = oljl0100.threadId;

         jobLogEntry.rplcData = getCharData(oljl0100_buffer
                                            : %size(oljl0100_buffer)
                                            : QGYOLJBL_RPLC_DATA);

         if (i_options.isMsg);
            jobLogEntry.msgText = getCharData(oljl0100_buffer
                                              : %size(oljl0100_buffer)
                                              : i_options.msgSelectId);
         endif;

         if (i_options.isMsgHelp);
            jobLogEntry.msgHelp = getCharData(oljl0100_buffer
                                              : %size(oljl0100_buffer)
                                              : i_options.hlpSelectId);
         endif;

         if (i_options.isSender);
            jobLogEntry.sender.job =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_QSND_JOB);
            jobLogEntry.sender.type =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_SND_TYPE);
            jobLogEntry.sender.pgm =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_SND_PGM);
            jobLogEntry.sender.mod =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_SND_MODULE);
            jobLogEntry.sender.proc =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_SND_PROC);
            jobLogEntry.sender.stmts =
                  getMixedData(oljl0100_buffer: %size(oljl0100_buffer)
                               : QGYOLJBL_SND_STMTS_ARRAY);
            jobLogEntry.sender.usrPrf =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_SND_USRPRF);
         endif;

         if (i_options.isReceiver);
            jobLogEntry.receiver.type =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_RCV_TYPE);
            jobLogEntry.receiver.pgm =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_RCV_PGM);
            jobLogEntry.receiver.mod =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_RCV_MODULE);
            jobLogEntry.receiver.proc =
                  getCharData(oljl0100_buffer: %size(oljl0100_buffer)
                              : QGYOLJBL_RCV_PROC);
            jobLogEntry.receiver.stmts =
                  getMixedData(oljl0100_buffer: %size(oljl0100_buffer)
                               : QGYOLJBL_RCV_STMTS_ARRAY);
         endif;

         return jobLogEntry;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Retrieves the character data of the specified field identifier.
      *=========================================================================
     P getCharData...
     P                 B
     D                 PI          8192a          varying
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Return value
     D fieldData       s           8192a   varying inz
      *
     D lenData         s             10i 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_fieldId =  101 or i_fieldId =  201 or
                  i_fieldId =  301 or i_fieldId =  302 or
                  i_fieldId =  401 or i_fieldId =  402 or
                  i_fieldId =  403 or i_fieldId =  404 or
                  i_fieldId =  501 or i_fieldId =  601 or
                  i_fieldId =  602 or i_fieldId =  603 or
                  i_fieldId =  604 or i_fieldId =  605 or
                  i_fieldId =  607 or i_fieldId =  702 or
                  i_fieldId =  703 or i_fieldId =  704 or
                  i_fieldId =  705 or i_fieldId =  801 or
                  i_fieldId =  901 or i_fieldId = 1001 or
                  i_fieldId = 1101
         : 'Illegal procedure call for field with id: ' + %char(i_fieldId));

         fieldData = getData(i_buffer: i_buffLen: i_fieldId);

         return fieldData;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Retrieves the mixed data of the specified field identifier.
      *=========================================================================
     P getMixedData...
     P                 B
     D                 PI                         likeds(mixedData_t)
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Return value
     D fieldData       ds                  likeds(mixedData_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_fieldId = 606 or i_fieldId = 706
         : 'Illegal procedure call for field with id: ' + %char(i_fieldId));

         fieldData = getData(i_buffer: i_buffLen: i_fieldId);

         return fieldData;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Retrieves the binary data of the specified field identifier.
      *=========================================================================
     P getBinData...
     P                 B
     D                 PI            10i 0
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Return value
     D fieldData       s             10i 0 inz
      *
      *  Local fields
     D charBuffer      ds                  qualified
     D  toBinValue                   10i 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         p_assert(i_fieldId = 1201 or i_fieldId = 1301 or
                  i_fieldId = 1302 or i_fieldId = 1303 or
                  i_fieldId = 1304
         : 'Illegal procedure call for field with id: ' + %char(i_fieldId));

         charBuffer = getData(i_buffer: i_buffLen: i_fieldId);
         fieldData = charBuffer.toBinValue;

         return fieldData;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the data buffer of the specified field.
      *=========================================================================
     P getData...
     P                 B
     D                 PI          8192a   varying
     D  i_buffer                  65535a          options(*varsize)
     D  i_buffLen                    10i 0 const
     D  i_fieldId                    10i 0 const
      *
      *  Return value
     D fieldData       s           8192a   varying inz
      *
      *  Local fields
     D oljl0100        ds                  likeds(oljl0100_t)
     D                                     based(pOljl0100)
     D fieldInf        ds                  likeds(oljl0100_fieldInf_t)
     D                                     based(pFieldInf)
     D data            s           8192a   based(pData)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         pOljl0100 = %addr(i_buffer);
         pFieldInf = pOljl0100 + oljl0100.ofsFldsRtn;

         dow (fieldInf.fieldId <> i_fieldId and fieldInf.ofsNxtFldInf <> 0);
            pFieldInf = pOljl0100 + fieldInf.ofsNxtFldInf;
            if (pFieldInf > pOljl0100 + i_buffLen);
               return '*ERR';
            endif;
         enddo;

         if (fieldInf.fieldId = i_fieldId);
            pData = pFieldInf + %size(fieldInf);
            if (fieldInf.lenData <= %len(data));
               fieldData = %subst(data: 1: fieldInf.lenData);
            else;
               fieldData = %subst(data: 1: %len(data));
            endif;
         else;
            fieldData = '';
         endif;

         return fieldData;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns the default message key for a given direction.
      *=========================================================================
     P getDftMsgKey...
     P                 B
     D                 PI                         like(JobLog_msgKey_t)
     D  i_direction                        const  like(JobLog_direction_t)
      *
      *  Return value
     D msgKey          s                   like(JobLog_msgKey_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

            if (i_direction = JOBLOG_PREVIOUS);
               msgKey = MSGKEY_PREVIOUS;
            else;
               msgKey = MSGKEY_NEXT;
            endif;

         return msgKey;

      /END-FREE
      *
     P                 E
      *
      *=========================================================================
      *  Returns timestamp the message was send to the job log.
      *=========================================================================
     P getTimeSent...
     P                 B
     D                 PI              Z
     D  i_oljl0100                         const  likeds(oljl0100_t)
      *
      *  Return value
     D timeSent        s               Z
      *
     D date            s               D
     D time            s               T
     D mSecs           s             10I 0
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /FREE

         monitor;
            date = %date(i_oljl0100.dateSnd: *CYMD0);
            time = %time(i_oljl0100.timeSnd: *HMS0);
            mSecs = %int(i_oljl0100.mSecs);
            timeSent = date + time + %mseconds(mSecs);
         on-error;
            clear timeSent;
         endmon;

         return timeSent;

      /END-FREE
      *
     P                 E
      *
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing OPNLSTAPIS  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "OPNLSTAPIS"
mbrtype =  "RPGLE     "
mbrtext =  "Process Open List APIs                            "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(OPNLSTAPIS)
      /DEFINE OPNLSTAPIS
      *
      *  Open list information format
     D qgy_opnListInf_t...
     D                 DS                  qualified               based(pDummy)
     D  totalRcds                    10I 0
     D  rcdsRet                      10I 0
     D  hRequest                      4A
     D  rcdLen                       10I 0
     D  infComplInd                   1A
     D  dateTimeCrt                  13A
     D  listStatInd                   1A
     D  reserved_01                   1A
     D  lenInfRet                    10I 0
     D  firstRcdInRcv                10I 0
     D  reserved_02                  40A
      *
      *  Get List Entries (QGYGTLE) API
     D QGYGTLE...
     D                 PR                  extpgm('QGYGTLE')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_rcvVarLen                  10I 0 const
     D  i_hRequest                    4A   const
     D  o_opnListInf                 80A
     D  i_numRcdRtn                  10I 0 const
     D  i_startRcd                   10I 0 const
     D  io_errCode                65535A          options(*varsize)
      *
      *  Close List (QGYCLST) API
     D QGYCLST...
     D                 PR                  extpgm('QGYCLST')
     D  i_hRequest                    4A   const
     D  io_errCode                65535A          options(*varsize)
      *
      *  List sort information: QGYOLOBJ / QGYOLSPL
     D qgy_sortInf_t...
     D                 DS                  qualified               based(pDummy)
     D  numE                         10I 0
     D  sortInfE                           likeds(qgy_sortInfE_t   )
     D                                     dim(16)
      *
     D qgy_sortInfE_t...
     D                 DS                  qualified               based(pDummy)
     D  startPos                     10I 0
     D  length                       10I 0
     D  dataType                      5I 0
     D  order                         1A
     D  reserved_1                    1A
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing PJOBLOG  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "PJOBLOG   "
mbrtype =  "RPGLE     "
mbrtext =  "Job Log API - Public Interface                    "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(PJOBLOG)
      /DEFINE PJOBLOG
      *
      *  Parameter values of JobLog_open(), i_direction:
     D JOBLOG_NEXT...
     D                 c                   '*NEXT'
     D JOBLOG_PREVIOUS...
     D                 c                   '*PRV'
      *
      *  Parameter values of JobLog_open(), i_options:
     D JOBLOG_OPTION_REPLACE_VARS...
     D                 c                   1
     D JOBLOG_OPTION_RETURN_CTRL_CHARS...
     D                 c                   2
     D JOBLOG_OPTION_MSG...
     D                 c                   4
     D JOBLOG_OPTION_MSG_HELP...
     D                 c                   8
     D JOBLOG_OPTION_SENDER...
     D                 c                   16
     D JOBLOG_OPTION_RECEIVER...
     D                 c                   32
      *
      *  Opens a job log.
     D JobLog_open...
     D                 PR                         like(JobLog_handle_t)
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_open+
     D                                     ')
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*nopass: *omit)
     D  i_options                          const  like(JobLog_options_t)
     D                                            options(*nopass: *omit)
     D  i_direction                        const  like(JobLog_direction_t)
     D                                            options(*nopass: *omit)
     D  i_strMsgKey                        const  like(JobLog_msgKey_t)
     D                                            options(*nopass: *omit)
      *
      *  Closes a given job log.
     D JobLog_close...
     D                 PR
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_close+
     D                                     ')
     D  io_hJobLog                                like(JobLog_handle_t)
      *
      *  Returns the next job log entry.
     D JobLog_getEntry...
     D                 PR              n
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_getEntry+
     D                                     ')
     D  i_hJobLog                          const  like(JobLog_handle_t)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Returns the newest job log entry.
     D JobLog_getNewest...
     D                 PR              n
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_getNewest+
     D                                     ')
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*omit)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Returns the oldest job log entry.
     D JobLog_getOldest...
     D                 PR              n
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_getOldest+
     D                                     ')
     D  i_qJob                             const  likeds(qJob_t)
     D                                            options(*omit)
     D  o_jobLogEntry                             likeds(JobLog_jobLogEntry_t)
      *
      *  Returns the message type of a given job log entry.
     D JobLog_getMessageType...
     D                 PR            10a
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_getMessageType+
     D                                     ')
     D  i_jobLogEntry                      const  likeds(JobLog_jobLogEntry_t)
      *
      *  Returns cTrue if a given handle is NULL, else cFalse.
     D JobLog_isNull...
     D                 PR              N
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_isNull+
     D                                     ')
     D  i_hJobLog                                 like(JobLog_handle_t)
      *
      *  Returns a NULL job log handle.
     D JobLog_null...
     D                 PR                         like(JobLog_handle_t)
     D                                     extproc('JOBLOG1_+
     D                                     JobLog_null+
     D                                     ')
      *
     D JobLog_handle_t...
     D                 s                   like(HANDLE_handle_t)
     D JobLog_direction_t...
     D                 s             10a
     D JobLog_msgKey_t...
     D                 s              4a
     D JobLog_options_t...
     D                 s             10i 0
      *
     D JobLog_jobLogEntry_t...
     D                 ds                  qualified based(pDummy)
     D  isMsg                          n
     D  isMsgHelp                      n
     D  isSender                       n
     D  isReceiver                     n
     D  msgSeverity                  10I 0
     D  msgID                         7A
     D  msgType                       2A
     D  msgKey                        4A
     D  msgFile                      10A
     D  msgFLibSpcfd                 10A
     D  msgFLibUsed                  10A
     D  timeSent                       Z
     D  threadId                      8A
     D  msgText                     132a   varying
     D  msgHelp                    3000a   varying
     D  sender                             likeds(JobLog_addresse_t)
     D  receiver                           likeds(JobLog_addresse_t)
     D  rplcData                   5120a   varying
      *
     D JobLog_addresse_t...
     D                 DS                  qualified based(pDummy)
     D  job                                likeds(qJob_t)
     D  type                          1a
     D  pgm                                likeds(qObj_t)
     D  mod                          10a
     D  proc                        256a
     D  stmts                              likeds(JobLog_stmts_t)
     D  usrPrf                       10a
      *
     D JobLog_stmts_t...
     D                 DS                  qualified based(pDummy)
     D  numE                         10i 0
     D  lineNbr                      10a   dim(10)
      *
     D JOBLOG_MAX_MSG_TEXT_LEN...
     D                 c                   132
     D JOBLOG_MAX_MSG_HELP_LEN...
     D                 c                   3000
      *
      /COPY QBASICS1,PBASICS1                     Tools/400 Runtime Library
      /COPY QJOBLOG,FDQJOB                        Qualified job name
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*STATUS   "><![CDATA[
Installing QGYOLJBL  type RPGLE - in progress.
]]>  </sendmsg>
<!-- START OF MEMBER  -->
<mbr
mbrname =  "QGYOLJBL  "
mbrtype =  "RPGLE     "
mbrtext =  "Open List of Job Log Messages (QGYOLJBL) API      "
srcfile =  "QJOBLOG   "
srclib  =  "selected  "
srclen  =  "00112"
srccssid=  "00273">
<copysrc><![CDATA[
      /IF NOT DEFINED(QGYOLJBL)
      /DEFINE QGYOLJBL
      *
      *  Open List of Job Log Messages (QGYOLJBL) API
     D QGYOLJBL...
     D                 PR                  extpgm('QGYOLJBL')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  o_listInf                    80A
     D  i_numRcdsRtn                 10I 0 const
     D  i_msgSlcInf               65535A   const  options(*varsize)
     D  i_lenMsgSlcInf...
     D                               10I 0 const
     D  io_errCode                65535A          options(*nopass: *varsize)
      *
      *  OLJL0100 Format
     D oljl0100_t...
     D                 DS                  qualified based(pDummy)
     D  ofsNxtEntry                  10I 0
     D  ofsFldsRtn                   10I 0
     D  numFldsRtn                   10I 0
     D  msgSeverity                  10I 0
     D  msgID                         7A
     D  msgType                       2A
     D  msgKey                        4A
     D  msgFile                      10A
     D  msgFLibSpcfd                 10A
     D  dateSnd                       7A
     D  timeSnd                       6A
     D  mSecs                         6A
     D  threadId                      8A
      *  Reserved                                         CHAR(*)
      *  Offset to the next field information returned    BINARY(4)
      *  Length of field information returned             BINARY(4)
      *  Identifier field                                 BINARY(4)
      *  Type of data                                     CHAR(1)
      *  Status of data                                   CHAR(1)
      *  Reserved                                         CHAR(14)
      *  Length of data                                   BINARY(4)
      *  Data                                             CHAR(*)
      *  Reserved                                         CHAR(14)
      *
     D oljl0100_fieldInf_t...
     D                 DS                  qualified based(pDummy)
     D  ofsNxtFldInf                 10I 0
     D  lenFldInf                    10I 0
     D  fieldId                      10I 0
     D  dataType                      1A
     D  dataSts                       1A
     D  reserved                     14A
     D  lenData                      10I 0
      *  Data                                             CHAR(*)
      *  reserved                                         CHAR(*)
      *
      *  Message Selection Information Format
     D QGYOLJBL_msgSlcInf...
     D                 DS                  qualified based(pDummy)
     D  listDirection                10A
     D  qJob                               likeds(qJob_t)
     D  intJobID                     16A
     D  strMsgKey                     4A
     D  maxMsgLen                    10I 0
     D  maxMsgHlpLen                 10I 0
     D  ofsFldsIdnRtn                10I 0
     D  numFldsRtn                   10I 0
     D  ofsCallMsgQNm                10I 0
     D  lenMsgQNm                    10I 0
      *  Identifiers of fields to return         ARRAY(*) of BINARY(4)
      *  Call message queue name                 CHAR(*)
      *
      *  Valid Field Identifiers
     D QGYOLJBL_ALERT_OPTION...
     D                 C                         0101
     D QGYOLJBL_RPLC_DATA...
     D                 C                         0201
     D QGYOLJBL_MSG...
     D                 C                         0301
     D QGYOLJBL_MSG_WITH_RPLC_DATA...
     D                 C                         0302
     D QGYOLJBL_MSG_HLP...
     D                 C                         0401
     D QGYOLJBL_MSG_HLP_WITH_RPLC_DATA...
     D                 C                         0402
     D QGYOLJBL_MSG_HLP_WITH_FMT_CHARS...
     D                 C                         0403
     D QGYOLJBL_MSG_HLP_WITH_RPLC_DATA_AND_FMT_CHARS...
     D                 C                         0404
     D QGYOLJBL_DDT_RPLY...
     D                 C                         0501
     D QGYOLJBL_QSND_JOB...
     D                 C                         0601
     D QGYOLJBL_SND_TYPE...
     D                 C                         0602
     D QGYOLJBL_SND_PGM...
     D                 C                         0603
     D QGYOLJBL_SND_MODULE...
     D                 C                         0604
     D QGYOLJBL_SND_PROC...
     D                 C                         0605
     D QGYOLJBL_SND_STMTS_ARRAY...
     D                 C                         0606
     D QGYOLJBL_SND_USRPRF...
     D                 C                         0607
     D QGYOLJBL_RCV_TYPE...
     D                 C                         0702
     D QGYOLJBL_RCV_PGM...
     D                 C                         0703
     D QGYOLJBL_RCV_MODULE...
     D                 C                         0704
     D QGYOLJBL_RCV_PROC...
     D                 C                         0705
     D QGYOLJBL_RCV_STMTS_ARRAY...
     D                 C                         0706
     D QGYOLJBL_MSGF_LIB...
     D                 C                         0801
     D QGYOLJBL_PRB_ID...
     D                 C                         0901
     D QGYOLJBL_RPLY_STATUS...
     D                 C                         1001
     D QGYOLJBL_REQ_STATUS...
     D                 C                         1101
     D QGYOLJBL_REQ_LEVEL...
     D                 C                         1201
     D QGYOLJBL_CCSID_TEXT...
     D                 C                         1301
     D QGYOLJBL_CCSID_CONV_STATUS_TEXT...
     D                 C                         1302
     D QGYOLJBL_CCSID_DATA...
     D                 C                         1303
     D QGYOLJBL_CCSID_CONV_STATUS_DATA...
     D                 C                         1304
      *
      *   Qualified job name
      /IF NOT DEFINED(qJob_t    )
      /DEFINE qJob_t
     D qJob_t          DS                  qualified           based(pDummy)
     D  name                         10A
     D  user                         10A
     D  nbr                           6A
      /ENDIF
      *
      /ENDIF
]]>  </copysrc>
</mbr>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="A_INSTALL"><![CDATA[
CRTBNDCL PGM(&tolib/A_INSTALL) SRCFILE(&tolib/QJOBLOG) SRCMBR(*PGM) DFTACTGRP(*NO) ACTGRP(*NEW) DBGV
IEW(*LIST)
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
CALL PGM(&tolib/A_INSTALL) PARM('&TGTRLS' '&SRCFILE' '&tolib' '&CRTTSTPGM')
]]>  </qcmdexc>
<qcmdexc condition="*NONE" release="*CURRENT" dltsplf="*NONE"><![CDATA[
DLTPGM PGM(&tolib/A_INSTALL)
]]>  </qcmdexc>
<sendmsg  sendmsgid="CPF9897" sendmsgtype = "*COMP     "><![CDATA[
Application JOBLOG successfully installed.
]]>  </sendmsg>
</upload>
