      *---------------------------------------------------------------------------------------
      * CRTBNDRPG PGM(QTEMP/XMLINST) SRCFILE(ISPHERE/QBUILD) SRCMBR(*PGM)
      *---------------------------------------------------------------------------------------
      * Parse / Install from xml text into source members and objects.
      * Copyright (C) 2001    Craig Rutledge    <craig_rutledge@mohawkind.com>
      * Martin Rowe    <Martin@dbg400.net>          scripting cmd prompts
      * David George   <webmaster@400times.co.uk>   intellectual input
      * Thomas Raddatz <thomas.raddatz@tools400.de> execute SQL statements
      * Thomas Raddatz <thomas.raddatz@tools400.de> conditions
      * Thomas Raddatz <thomas.raddatz@tools400.de> release
      * Thomas Raddatz <thomas.raddatz@tools400.de> retrieve object description
      *
      * Use xml tags in text to trigger:
      * 1. Parse text into source members (create srcfile & member if required).
      * 2. Compile source into objects.
      * 3. Send installation progress user messages.
      * 4. Execute qcmdexc as required.
      * 5. Execute SQL statements as required.
      *
      * This program is free software, you can redistribute it and/or modify it
      * under the terms of the GNU General Public License as published by
      * the Free Software Foundation.  See GNU General Public License for details
      *---------------------------------------------------------------------------------------
     H DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('QC2LE')
      *---------------------------------------------------------------------------------------
     Fxmlinput  if   f  112        disk    usropn                               uploaded text
     Fqxxxsrc   o    f  112        disk    usropn                               parsed out
      *--------------------------------------------------------------------
      * create parm prototypes
      *--------------------------------------------------------------------
      *  Tokenize String
     D strtok          PR              *          extproc('strtok')
     D  i_string                       *   value  options(*string)
     D  i_token                        *   value  options(*string)
      * retrieve member description
     D qusrmbrd        PR                  ExtPgm('QUSRMBRD')                   MEMBER DESCRIPTION
     D  o_rcvVar                  32767a          options(*varsize)             RECEIVER
     D  i_lenRcvVar                  10i 0 const                                LENGTH OF RECVR
     D  i_format                      8    const                                UPLOAD TYPE
     D  i_qFile                      20    const                                FILE   LIB
     D  i_mbr                        10    const                                MEMBER NAME
     D  i_ovverride                   1    const                                PROCESS OVERIDE
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * retrieve object description
     D QUSROBJD...
     D                 PR                         extpgm('QUSROBJD')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  i_qObj                       20A   const
     D  i_type                       10A   const
     D  io_errCode                65535A          options(*nopass: *varsize)    | OptGrp 1
      * send program message
     D qmhsndpm        PR                  ExtPgm('QMHSNDPM')                   SEND MESSAGES
     D  i_msgID                       7a   const                                ID
     D  i_qMsgF                      20a   const                                FILE
     D  i_msgText                 32767a   const  options(*varsize)             TEXT
     D  i_lenMsgText                 10i 0 const                                LENGTH
     D  i_msgType                    10a   const                                TYPE
     D  i_callStackE                 10a   const                                STACK ENTRY
     D  i_callStackC                 10i 0 const                                STACK COUNTER
     D  i_msgKey                      4a   const                                KEY
     D  io_errCode                32767a          options(*varsize)             ERROR CODE
      * execute cl command
     D  qcmdexc        PR                  ExtPgm('QCMDEXC')
     D  i_cmd                        50a   Const
     D  i_lenCmd                     15p 5 Const
      *  Allocate Environment Handle
     D SQLAllocEnv...
     D                 PR                         extproc('SQLAllocEnv')
     D                                     like(SQLRETURN_t )
     D  o_phenv                        *   value
      *  Allocate Connection Handle
     D SQLAllocConnect...
     D                 PR                         extproc('SQLAllocConnect')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
     D  o_phdbc                        *   value
      *  Connect to a Data Source
     D SQLConnect...
     D                 PR                         extproc('SQLConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_szDSN                        *   value  options(*string)
     D  i_cbDSN                            value  like(SQLSMALLINT_t)
     D  i_szUID                        *   value  options(*string)
     D  i_cbUID                            value  like(SQLSMALLINT_t)
     D  i_szAuthStr                    *   value  options(*string)
     D  i_cbAuthStr                        value  like(SQLSMALLINT_t)
      *  Set Connection Option
     D SQLSetConnectOption...
     D                 PR                         extproc('SQLSetConnectOption')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  i_fOption                          value  like(SQLSMALLINT_t)
     D  i_vParam                           value  like(SQLPOINTER_t )
      *  Allocate a Statement Handle
     D SQLAllocStmt...
     D                 PR                         extproc('SQLAllocStmt')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
     D  o_phstmt                       *   value
      *  Execute a Statement Directly
     D SQLExecDirect...
     D                 PR                         extproc('SQLExecDirect')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_szSqlStr                     *   value  options(*string)
     D  i_cbSqlStr                         value  like(SQLINTEGER_t)
      *  Free (or Reset) a Statement Handle
     D SQLFreeStmt...
     D                 PR                         extproc('SQLFreeStmt')
     D                                     like(SQLRETURN_t )
     D  i_hstmt                            value  like(SQLHSTMT_t  )
     D  i_fOption                          value  like(SQLSMALLINT_t)
      *  Disconnect from a Data Source
     D SQLDisconnect...
     D                 PR                         extproc('SQLDisconnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Connection Handle
     D SQLFreeConnect...
     D                 PR                         extproc('SQLFreeConnect')
     D                                     like(SQLRETURN_t )
     D  i_hdbc                             value  like(SQLHDBC_t   )
      *  Free Environment Handle
     D SQLFreeEnv...
     D                 PR                         extproc('SQLFreeEnv')
     D                                     like(SQLRETURN_t )
     D  i_henv                             value  like(SQLHENV_t   )
      *--------------------------------------------------------------------
     D long_t          S             10I 0                    based(pDummy)
     D short_t         S              5I 0                    based(pDummy)
      *
     D SQLINTEGER_t    S                   like(long_t      ) based(pDummy)
     D SQLSMALLINT_t   S                   like(short_t     ) based(pDummy)
      *
     D PTR_t           S               *                      based(pDummy)
     D SQLPOINTER_t    S                   like(PTR_t       ) based(pDummy)
     D HENV_t          S                   like(long_t      ) based(pDummy)
     D HDBC_t          S                   like(long_t      ) based(pDummy)
     D HSTMT_t         S                   like(long_t      ) based(pDummy)
     D RETCODE_t       S                   like(SQLINTEGER_t) based(pDummy)
      *
     D SQLHENV_t       S                   like(HENV_t      ) based(pDummy)
     D SQLHDBC_t       S                   like(HDBC_t      ) based(pDummy)
     D SQLHSTMT_t      S                   like(HSTMT_t     ) based(pDummy)
     D SQLRETURN_t     S                   like(RETCODE_t   ) based(pDummy)
      *
     D retCode         S                   like(SQLRETURN_t) inz
     D hdbc            S                   like(SQLHDBC_t  ) inz
     D hstmt           S                   like(SQLHSTMT_t ) inz
     D henv            S                   like(SQLHENV_t  ) inz
     D sqlInit         S              1A                     inz(*off)
     D cOptVal         S             10I 0                   inz
      *
     D SQL_NTS         C                   const( -3)
     D SQL_COMMIT_NONE...
     D                 C                   const(  1)
     D SQL_ATTR_COMMIT...
     D                 C                   const(  0)
     D SQL_DROP        C                   const(  1)
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     D readElement     PR                        like(bldexc)
     D  i_element                     9A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to double quotes in a string
      *--------------------------------------------------------------------
     D dblQuotes       PR          2048A         varying
     D  i_string                   2048A   value varying
      *--------------------------------------------------------------------
      * Define function prototype to get attribute data from a string
      *--------------------------------------------------------------------
     D getAttrData...
     D                 PR          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *--------------------------------------------------------------------
      * Define function prototype to check for a condition
      *--------------------------------------------------------------------
     D isCondition...
     D                 PR              n
     D  i_condList                 2000A   value
      *---------------------------------------------------------------------------------------
     D loadConditions...
     D                 PR                  dim(32) like(condition)
     D  i_conditions                128A   value
      *--------------------------------------------------------------------
     D isRelease...
     D                 PR              n
     D  i_release                    10A   value
      *--------------------------------------------------------------------
     D setTargetRelease...
     D                 PR          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *--------------------------------------------------------------------
     D setVariable...
     D                 PR
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
      *---------------------------------------------------------------------------------------------
     D getVarName...
     D                 PR            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
      *---------------------------------------------------------------------------------------------
     D getVarValue...
     D                 PR            64a          varying
     D  i_name                       11a   value  varying
      *---------------------------------------------------------------------------------------------
     D uCase...
     D                 PR          2000A          varying
     D  i_string                   2000A   value  varying
      *--------------------------------------------------------------------
     D vrcvar          s            145
     D qm_msgid        s              7
     D qm_msgtxt       s            500
     D qm_msgq         s             10
     D qm_msgtyp       s             10
     D mbrname         s             10
     D mbrtype         s             10
     D mbrtext         s             50
     D srcfile         s             10
     D srclen          s              5
     D srclenN         s              5  0   inz(0)
     D srccssid        s              5
     D bldexc          s           2000
     D write_flag      s              1n   inz(*off)
     D srcSeqno        s              6s 2 inz(0)
     D aa              s              5u 0 inz(0)
     D ll              s              5u 0 inz(0)
     D qs              c                   ''''
     D qd              c                   '"'
     D errFLag         s              1    inz(*off)
     D cnd_msg         s             42
     D cnd_values      s            110
     D cnd_rtnVal      s             10
     D cnd_array       s                   dim(32) inz like(condition)
     D cnd_ptr         s             10i 0 inz
     D condition       s             10a
     D condList        s           2000a
     D release         s             10a
     D dltsplf         s             10a
     D objd_obj        s             10a
     D objd_lib        s             10a
     D objd_objtype    s             10a
     D objd_rtnlib     s             10a
     D objd0100        ds
     D  od_bytRet              1      4i 0
     D  od_bytAvl              5      8i 0
     D  od_name                9     18a
     D  od_lib                19     28a
     D  od_type               29     38a
     D  od_rtnLib             39     48a
     D fld_array       ds
     D  fld_x                        10i 0 inz
     D  fld_name                     11a   inz dim(64) varying
     D  fld_value                    64a   inz dim(64) varying
     D var_name        s             11a   inz varying
     D var_value       s             64a   inz varying
      * Error return code parm for APIs.
     D errCode         DS
     D  errCode_bytPrv...
     D                               10i 0 inz(%size(errCode))
     D  errCode_bytAvl...
     D                               10i 0 inz(0)
     D  errCode_excID...
     D                                7a   inz
     D  errCode_reserved...
     D                                1a   inz
     D  errCode_escData...
     D                              256a   inz
      * Optional parameters
     D OvrSrcFile      s                   like(i_OvrSrcFile) inz
     D isPreDefCond    s               N   inz(*off)
     D TgtRls          s                   like(i_TgtRls    ) inz
      *
      * Program status data structure.
     D sds            sds
     D  sds_pgmName                  10A
     D  sds_status                    5S 0
     D  sds_prvStat                   5S 0
     D  sds_lastSeq                   8A
     D  sds_lastSubR                  8A
     D  sds_numParm                   3S 0
     D  sds_msgID                     7A
     D  sds_MiInstr                   4A
     D  sds_wrkArea                  30A
     D  sds_lib                      10A
     D  sds_msgText                  80A
      *--------------------------------------------------------------------
     Ixmlinput  ns
     I                                 13   21  xmltag1
     I                                 18   27  xmltag2
     I                                 13  112  xmlcode
      *--------------------------------------------------------------------
     C     *entry        plist
     C                   parm                    ParseSrcMbr      10            source member
     C                   parm                    ParseSrcFile     10            source file
     C                   parm                    ParseSrcLib      10            source lib
      *  optional parameters:
     C                   parm                    i_OvrSrcFile     10            override to src
     C                   parm                    i_Conditions    128            pre-def conditions
     C                   parm                    i_TgtRls         10            target release
      *
      *  get optional parameter: Overrride to Source File
     C                   if        %parms() >= 4
     C                   eval      OvrSrcFile = i_OvrSrcFile
     C                   else
     C                   eval      OvrSrcFile = ''
     C                   endif
      *
      *  get optional parameter: Conditions
     C                   if        %parms() >= 5
     C                   if        i_Conditions <> ''
     C                   eval      cnd_array = loadConditions(i_Conditions)
     C                   eval      isPreDefCond = *on
     C                   else
     C                   eval      isPreDefCond = *off
     C                   endif
     C                   endif
      *
      *  get optional parameter: Target Release
     C                   if        %parms() >= 6
     C                   eval      TgtRls = i_TgtRls
     C                   else
     C                   eval      TgtRls = ''
     C                   endif
      *
     C                   exsr      srValidate                                   make sure exist
      *
      * Set user selected library *first for remainder of program
     C                   eval      bldexc = 'RMVLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
     C                   eval      bldexc = 'ADDLIBLE LIB('+
     C                             %trimr(ParseSrcLib) + ') POSITION(*FIRST)'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      *
      *       CPF2103 - Library &1 already exists in library list.
     C                   if        %error and sds_msgID <> 'CPF2103'
     C                   eval      qm_msgtxt = '0000 ' + sds_msgText
     C                   exsr      srKill
     C                   endif
      *
      * Set variable &TOLIB
     C                   callp     setVariable('tolib': ParseSrcLib)
      *
      * Override Input file to uploaded text file
     C                   eval      bldexc = 'OVRDBF FILE(XMLINPUT) TOFILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(ParseSrcFile) + ') MBR(' +
     C                             %trimr(ParseSrcMbr) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   open      xmlinput
     C                   read      xmlinput
     C                   dow       not %eof
      * write records to outfile if flag is on
     C                   select
     C                   when      write_flag = *on
     C                   if        xmltag2<>'</copysrc>'
     C                   eval      srcSeqno=srcSeqno+1
     C                   except    write_one
     C                   else
     C                   eval      write_flag=*off
     C                   close     qxxxsrc
     C                   endif
      *
      * Extract values based on xml tags.
     C                   when      xmltag1 = 'mbrname ='
     C                   eval      mbrname = %subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtype ='
     C                   eval      mbrtype =%subst(xmlcode:13:10)
     C                   when      xmltag1 = 'mbrtext ='
     C                   eval      mbrtext =dblQuotes(%subst(xmlcode:13:50))
     C                   when      xmltag1 = 'srcfile ='
     C                   if        OvrSrcFile <> ''
     C                   eval      srcfile =OvrSrcFile
     C                   else
     C                   eval      srcfile =%subst(xmlcode:13:10)
     C                   endif
     C                   when      xmltag1 = 'srclen  ='
     C                   eval      srclen  =%subst(xmlcode:13:5)
     C                   when      xmltag1 = 'srccssid='
     C                   eval      srccssid=%subst(xmlcode:13:5)
      *--------------------------------------------------------------------
      * Start of data to copy.  Create source files/mbrs as required.
      *--------------------------------------------------------------------
     C                   when      xmltag1='<copysrc>'
     C                   move      srclen        srclenN
      * crtsrcpf
     C                   eval      bldexc = 'CRTSRCPF FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') RCDLEN(' +
     C                             srclen + ') CCSID(' +
     C                             srccssid + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
      * addpfm
     C                   eval      bldexc = 'ADDPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') SRCTYPE(' +
     C                             %trimr(mbrtype) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp(e)  qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error
      * chgpfm
     C                   eval      bldexc = 'CHGPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ') TEXT(' +
     C                             qs+%trimr(mbrtext)+qs + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
      * clr mbr
     C                   eval      bldexc = 'CLRPFM   FILE(' +
     C                             %trimr(ParseSrcLib)+'/'+
     C                             %trimr(srcfile) + ') MBR(' +
     C                             %trimr(mbrname) + ')'
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      * ovr to outfile mbr
     C                   eval      bldexc = 'OVRDBF QXXXSRC ' +
     C                             %trimr(ParseSrcLib) + '/' +
     C                             %trimr(srcfile) + ' ' +
     C                             mbrname
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   clear                   srcSeqno
     C                   open      qxxxsrc
     C                   eval      write_flag = *on
      *--------------------------------------------------------------------
      * Compile statement.  Read next record and execute it.
      * The subroutine TolibToken will replace &tolib with the
      * library the user has selected at run time.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<compile '
     C                   eval      condList= getAttrData('condition':xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('compile')
     C                   if        isCondition(condList)
     C                   exsr      TolibToken
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   callp     qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
      *--------------------------------------------------------------------
      * qcmdexc statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qcmdexc '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      release  = getAttrData('release'
     C                                                    :xmlcode:'*CURRENT')
     C                   eval      dltsplf  = getAttrData('dltsplf'
     C                                                    :xmlcode:'*NONE')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('qcmdexc')
     C                   if        isCondition(condList) and isRelease(release)
     C                   exsr      TolibToken
     C                   exsr      RplVars
     C                   exsr      SetTgtRls
     C                   if        %subst(bldexc: 1: 3) = 'DLT'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   else
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   if        %error()
     C                   eval      qm_msgtxt = '0000 Failed to execute: '+bldexc
     C                   exsr      srKill
     C                   endif
     C                   if        dltsplf <> '' and dltsplf <> '*NONE'
     C                   eval      bldexc = 'DLTSPLF FILE(' + dltsplf +
     C                                      ') JOB(*) SPLNBR(*LAST)'
     C                   callp (e) qcmdexc(bldexc:%len(%trimr(bldexc)))
     C                   endif
     C                   endif
     C                   endif
      *--------------------------------------------------------------------
      * SQL statement. Build statement from each record between start
      * and stop tags.  When stop tag is found, execute SQL statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<execsql '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   read      xmlinput
     C                   eval      bldexc = readElement('execsql')
     C                   if        isCondition(condList)
     C                   exsr      TolibToken
     C                   exsr      RplVars
     C                   exsr      srSQLExecute
     C                   endif
      *--------------------------------------------------------------------
      * Send messages to user as program executes
      * Extract message ID, Message Type, from <sendmsg>
      * read a record and get the single line of message text.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<sendmsg '
     C                   eval      qm_msgid = %subst(xmlcode:22:7)
     C                   eval      qm_msgtyp = %subst(xmlcode:46:10)
     C                   read      xmlinput
     C                   eval      qm_msgq   = '*EXT   '
     C                   eval      qm_msgtxt = xmlcode
     C                   exsr      srSndMessage
      *--------------------------------------------------------------------
      * rtvobjd statement. retrieve object description of the specified
      * object. Store attributes in specified fields.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<rtvobjd '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('rtvobjd')
     C                   eval      objd_obj    =getAttrData('obj'    :bldexc:'')
     C                   eval      objd_lib    =getAttrData('lib'    :bldexc:'')
     C                   eval      objd_objtype=getAttrData('objtype':bldexc:'')
     C                   eval      objd_rtnlib =getAttrData('rtnlib' :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srRtvObjD
     C                   endif
      *--------------------------------------------------------------------
      * chgvar statement.
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<chgvar  '
     C                   eval      condList = getAttrData('condition'
     C                                                    :xmlcode:'')
     C                   eval      bldexc = readElement('chgvar')
     C                   eval      var_name  = getAttrData('var'    :bldexc:'')
     C                   eval      var_value = getAttrData('value'  :bldexc:'')
     C                   if        isCondition(condList)
     C                   exsr      srChgVar
     C                   endif
      *--------------------------------------------------------------------
      * Query condition
      *--------------------------------------------------------------------
     C                   when      xmltag1 = '<qrycond '
     C                   eval      bldexc = readElement('qrycond')
     C                   eval      cnd_msg    = getAttrData('msg'   : bldexc:'')
     C                   eval      cnd_values = getAttrData('values': bldexc:'')
     C                   exsr      srQueryCond
     C                   endsl
      *
     C                   read      xmlinput
     C                   enddo
      *
     C                   exsr      srSQLEnd
     C                   eval      *inlr=*on
     C                   return
      *--------------------------------------------------------------------
      * Replace &tolib (no matter how many times it is in the string)
      * with whatever library the user has selected at run time.
      *--------------------------------------------------------------------
     C     TolibToken    begsr
     C                   eval      aa=%scan('&tolib':bldexc)
     C                   dow       aa>0
     C                   eval      bldexc=%replace(%trimr(ParseSrcLib):bldexc:
     C                             aa:6)
     C                   eval      aa=%scan('&tolib':bldexc)
     C                   enddo
      *  user has selected to override source, reset SRCFILE parm in bldexcs.
     C                   if        OvrSrcFile <> ''                             xmlpreview override
     C                   eval      aa=%scan('SRCFILE(':bldexc)
     C                   if        aa>0
     C                   eval      aa=%scan('/':bldexc:aa)
     C                   if        aa>0
     C                   eval      ll=%scan(')':bldexc:aa)
     C                   eval      bldexc=%replace(
     C                               %trimr(OvrSrcFile):bldexc:aa+1:ll-(aa+1))
     C                   endif
     C                   endif
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * Replace variable names with their associated values.
      *--------------------------------------------------------------------
     C     RplVars       begsr
     C                   eval      aa=%scan('&':bldexc)
     C                   dow       aa>0
     C                   eval      var_name=getVarName(bldexc:aa)
     C                   eval      var_value=getVarValue(var_name)
     C                   eval      bldexc=%replace(var_value:bldexc:aa
     C                                             :%len(var_name))
     C                   eval      aa=%scan('&':bldexc)
     C                   enddo
     C                   endsr
      *--------------------------------------------------------------------
      * Sets the target release according to the optional parameter
      * i_TgtRls.
      *--------------------------------------------------------------------
     C     SetTgtRls     begsr
     C                   if        TgtRls = ''
     C                   leavesr
     C                   endif
     C                   eval      bldexc =
     C                                setTargetRelease('TGTRLS': bldexc: TgtRls)
     C                   endsr
      *--------------------------------------------------------------------
      * Check of file, lib, member exist.
      *--------------------------------------------------------------------
     C     srValidate    begsr
     C                   callp     QUSRMBRD(
     C                             vrcvar:
     C                             145:
     C                             'MBRD0100':
     C                             ParseSrcFile + ParseSrcLib:
     C                             ParseSrcMbr:
     C                             '0':
     C                             errCode)
      *   --------------------------------------------------------------------------------
      *   If error occurred on call, send appropriate message back to user.
      *   ---------------------------------------------------------------------------------
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   select
      * lib not found
     C                   when      errCode_excID = 'CPF9810'
     C                   eval      qm_msgtxt = '0000 Library ' +
     C                             %trimr(ParseSrcLib) + ' was not found.'
      * src file not found
     C                   when      errCode_excID = 'CPF9812'
     C                   eval      qm_msgtxt = '0000 Source file ' +
     C                             %trimr(ParseSrcFile)+' was not found in ' +
     C                             %trimr(ParseSrcLib) + '.'
      * member not found
     C                   when      errCode_excID = 'CPF9815'
     C                   eval      qm_msgtxt = '0000 Member ' +
     C                             %trimr(ParseSrcMbr)+' was not found in ' +
     C                             %trimr(ParseSrcLib)+'/'+ %trimr(ParseSrcFile)
      * unexpected
     C                   other
     C                   eval      qm_msgtxt = '0000 Unexpected message ' +
     C                             errCode_excID + ' received. '
     C                   endsl
      * send message
     C                   exsr      srKill
     C                   eval      *inlr=*on
     C                   return
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * kill application
      *--------------------------------------------------------------------
     C     srKill        begsr
     C                   eval      qm_msgid  = 'CPD0006'
     C                   eval      qm_msgtyp = '*DIAG'
     C                   eval      qm_msgq   = '*CTLBDY'
     C                   exsr      srSndMessage
     C                   eval      qm_msgtxt = *blanks
     C                   eval      qm_msgid  = 'CPF0002'
     C                   eval      qm_msgtyp = '*ESCAPE'
     C                   exsr      srSndMessage
     C                   endsr
      *--------------------------------------------------------------------
      * call send program message api
      *--------------------------------------------------------------------
     C     srSndMessage  begsr
     C                   callp     QMHSNDPM(
     C                             qm_msgid:
     C                             'QCPFMSG   *LIBL     ':
     C                             qm_msgtxt:
     C                             %size(qm_msgtxt):
     C                             qm_msgtyp:
     C                             qm_msgq:
     C                             1:
     C                             '    ':
     C                             errCode)
     C                   endsr
      *--------------------------------------------------------------------
      * retrieve object description and store attributes
      *--------------------------------------------------------------------
     C     srRtvObjD     begsr
     C                   callp     QUSROBJD(objd0100
     C                                      : %size(objd0100)
     C                                      : 'OBJD0100'
     C                                      : objd_obj + objd_lib
     C                                      : objd_objtype
     C                                      : errCode)
     C                   if        errCode_bytAvl <> 0                          error occurred
     C                   eval      qm_msgtxt = '0000 Failed to retrieve +
     C                             object description of object ' +
     C                             %trim(objd_lib) + '/' + %trim(objd_obj) +
     C                             ' type ' + %trim(objd_objtype) + '.'
      * send message
     C                   exsr      srKill
     C                   else
     C                   callp     setVariable(objd_rtnlib: od_rtnlib)
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * change variable
      *--------------------------------------------------------------------
     C     srChgVar      begsr
     C                   callp     setVariable(var_name: var_value)
     C                   endsr
      *--------------------------------------------------------------------
      * execute SQL statement.
      *--------------------------------------------------------------------
     C     srSQLExecute  begsr
     C                   exsr      srSQLInit
     C                   Eval      retCode = SQLExecDirect(hstmt    :
     C                                                     bldexc   :
     C                                                     SQL_NTS  )
     C                   endsr
      *--------------------------------------------------------------------
      * query condition.
      *--------------------------------------------------------------------
     C     srQueryCond   begsr
     C                   if        isPreDefCond = *off
     C                   eval      cnd_values = uCase(cnd_values)
     C                   dou       (%scan(cnd_rtnVal: cnd_values) > 0) and
     C                             (cnd_rtnval <> ''                 )
     C                   eval      cnd_rtnval = ' '
     C     cnd_msg       dsply                   cnd_rtnval
     C                   eval      cnd_rtnVal = uCase(cnd_rtnVal)
     C                   enddo
     C                   eval      cnd_ptr = cnd_ptr + 1
     C                   eval      cnd_array(cnd_ptr) = cnd_rtnVal
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * initialize SQL.
      *--------------------------------------------------------------------
     C     srSQLInit     begsr
      *
     C                   if        sqlInit = *off
     C                   Eval      retCode = SQLAllocEnv(%addr(henv))
     C                   Eval      retCode = SQLAllocConnect(henv: %addr(hdbc))
     C                   Eval      retCode = SQLConnect(hdbc      :
     C                                                  '*LOCAL'  :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   :
     C                                                  *null     :
     C                                                  SQL_NTS   )
     C                   Eval      cOptVal = SQL_COMMIT_NONE
     C                   Eval      retCode = SQLSetConnectOption(hdbc          :
     C                                                          SQL_ATTR_COMMIT:
     C                                                          %addr(cOptVal) )
     C                   Eval      retCode = SQLAllocStmt(hdbc       :
     C                                                  %addr(hstmt) )
     C                   eval      sqlInit = *on
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * end SQL.
      *--------------------------------------------------------------------
     C     srSQLEnd      begsr
     C                   if        sqlInit = *on
     C                   Eval      retCode = SQLFreeStmt(hstmt    :
     C                                                   SQL_DROP )
     C                   Eval      retCode = SQLDisconnect(hdbc)
     C                   Eval      retCode = SQLFreeConnect(hdbc)
     C                   Eval      retCode = SQLFreeEnv(henv)
     C                   eval      sqlInit = *off
     C                   endif
     C                   endsr
      *--------------------------------------------------------------------
      * error handler
      *--------------------------------------------------------------------
     C     *pssr         begsr
     C                   if        errFLag = *off
     C                   eval      errFlag = *on
     C                   exsr      srSQLEnd
     C                   endif
     C                   endsr     '*CANCL'
     Oqxxxsrc   e            write_one
     O                       srcSeqno             6
     O                                           12 '000000'
     O                       xmlcode            112
      *--------------------------------------------------------------------
      * Read element
      *--------------------------------------------------------------------
     P readElement...
     P                 B
      *
     D readElement     PI                        like(bldexc)
     D  i_element                     9A   value varying
      *
     D i               S             10I 0 inz
     D value           S                   like(bldexc ) inz
     D endTag          S                   like(xmlTag2) inz
      *
     C                   eval      i = 1
     C                   eval      endTag = '</' + i_element + '>'
     C                   dow       xmltag2 <> endTag
     C                   eval      %subst(value: i: %len(xmlcode)) = xmlcode
     C                   eval      i = i + %len(xmlcode)
     C                   read      xmlinput
     C                   enddo
      *
     C                   Return    value
      *
     P readElement...
     P                 E
      *--------------------------------------------------------------------
      * Double quotes
      *--------------------------------------------------------------------
     P dblQuotes...
     P                 B
      *
     D dblQuotes       PI          2048A         varying
     D  i_string                   2048A   value varying
      *
     D x               S             10I 0         inz
     D string          S           2048A   varying inz
      *
     C                   For       x = 1 to %len(i_string)
     C                   Eval      string = string + %subst(i_string: x:1)
     C                   If        %subst(i_string: x : 1) = qs
     C                   Eval      string = string + qs
     C                   Endif
     C                   Endfor
      *
     C                   Return    string
      *
     P dblQuotes...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Get Attribute Data from String
      *---------------------------------------------------------------------------------------------
     P getAttrData...
     P                 B
      *
     D getAttrData...
     D                 PI          2000A          varying                       like(string_t)
     D  i_attr                       10a   value
     D  i_string                   2000A   value  varying                       like(string_t)
     D  i_default                  2000A   value  varying                       like(string_t)
      *
      *  return value
     D attrData        S           2000A   varying inz                          like(string_t)
      *
      *  local fields
     D attr            S             20a   varying inz
     D lenAttr         S             10i 0 inz
     D aa              S             10i 0 inz
     D cc              S             10i 0 inz
      *
     D Qd              C                   const('"')
      *-------------------------------------------------------------------*
      *
      *  find the keyword
     C                   eval      attr = %trim(i_attr) + '=' + Qd
      *
     C                   eval      aa   = %scan(attr: i_string)
     C                   if        aa = 0
     C                   return    i_default
     C                   endif
      *
     C                   eval      aa   = aa + %len(attr)
     C                   eval      cc   = %scan(Qd: i_string: aa+1)
      *
      *  return the data between the double-quotes
     C                   if        (cc-aa) > 0
     C                   eval      attrData = %subst(i_string: aa: cc-aa)
     C                   endif
      *
     C                   Return    attrData
      *
     P getAttrData...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Load condition array
      *---------------------------------------------------------------------------------------------
     P loadConditions...
     P                 B
      *
     D loadConditions...
     D                 PI                  dim(32) like(condition)
     D  i_conditions                128A   value
      *
      *  return value
     D cnd_array       s                   dim(32) inz like(condition)
     D pValue          s               *   inz
     D x               s             10i 0 inz
      *-------------------------------------------------------------------*
     C                   eval      i_conditions = uCase(i_conditions)
      *
     C                   eval      pValue = strtok(i_conditions: ';')
     C                   dow       pValue <> *null
     C                   eval      x = x + 1
     C                   eval      cnd_array(x) = %str(pValue)
     C                   eval      pValue = strtok(*null: ';')
     C                   enddo
      *
     C                   Return    cnd_array
     P loadConditions...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check for a condition
      *---------------------------------------------------------------------------------------------
     P isCondition...
     P                 B
      *
     D isCondition...
     D                 PI              n
     D  i_condList                 2000A   value
      *
      *  return value
     D isCondition     S               n   inz
     D pValue          S               *   inz
     D aCondition      S             10a   inz
      *-------------------------------------------------------------------*
     C                   eval      i_condList = uCase(i_condList)
      *
     C                   if        (i_condList = '*NONE')  or
     C                             (i_condList = ''     )
     C                   eval      *in01 = *on
     C                   else
      *
     C                   eval      pValue = strtok(i_condList: ' ')
     C                   dow       pValue <> *null
     C                   eval      aCondition = %str(pValue)
     C     aCondition    lookup    cnd_array                              01
     C                   if        not *in01
     C                   leave
     C                   endif
     C                   eval      pValue = strtok(*null     : ' ')
     C                   enddo
      *
     C                   endif
      *
     C                   if        *in01
     C                   eval      isCondition = *on
     C                   else
     C                   eval      isCondition = *off
     C                   endif
      *
     C                   Return    isCondition
     P isCondition...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Check the release level
      *---------------------------------------------------------------------------------------------
     P isRelease...
     P                 B
      *
     D isRelease...
     D                 PI              n
     D  i_release                    10A   value
      *
      *  return value
     D isRelease       S               n   inz(*off)
      *
      *  QSZRTVPR API
     D QSZRTVPR...
     D                 PR                  extpgm('QSZRTVPR')
     D  o_rcvVar                  65535A          options(*varsize)
     D  i_lenRcvVar                  10I 0 const
     D  i_format                      8A   const
     D  o_prodInf                 65535A   const  options(*varsize)
     D  io_errCode                65535A          options(*varsize)
      *
     D prdi0100        DS                  qualified
     D  productID              1      7A   inz('*OPSYS')
     D  releaseLvl             8     13A   inz('*CUR'  )
     D  productOpt            14     17A   inz('0000'  )
     D  loadID                18     27A   inz('*CODE' )
      *  Shortened!:
     D prdr0100        DS                  qualified
     D  bytRet                 1      4I 0
     D  bytAvl                 5      8I 0
     D  reserved_1             9     12I 0
     D  productID             13     19A
     D  releaseLvl            20     25A
      *  API error code
     D errCode         DS
     D  bytPrv                       10i 0 inz(0)
     D  bytAvl                       10i 0 inz(0)
      *  Release
     D release         DS
     D  r_operator             1      3a
     D  r_space                4      4a
     D  r_level                5     10a
      *-------------------------------------------------------------------*
     C                   If        i_release = '*CURRENT'
     C                   Eval      isRelease = *on
     C                   Else
     C                   Eval      release = i_release
     C                   Callp     QSZRTVPR(prdr0100: %size(prdr0100):
     C                                      'PRDR0100': prdi0100: errCode)
     C                   Select
     C                   When      r_operator = '*LT' and
     C                             prdr0100.releaseLvl < i_release
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*EQ' and
     C                             prdr0100.releaseLvl = i_release
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GT' and
     C                             prdr0100.releaseLvl > i_release
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*LE' and
     C                             prdr0100.releaseLvl <= i_release
     C                   Eval      isRelease = *on
     C                   When      r_operator = '*GE' and
     C                             prdr0100.releaseLvl >= i_release
     C                   Eval      isRelease = *on
     C                   Other
     C                   Eval      isRelease = *off
     C                   Endsl
     C                   Endif
      *
     C                   Return    isRelease
     P isRelease...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Replaces the value of a given keyword.
      *---------------------------------------------------------------------------------------------
     P setTargetRelease...
     P                 B
      *
     D setTargetRelease...
     D                 PI          2000A          varying
     D  i_keyword                    10A   value  varying
     D  i_string                   2000A   value  varying
     D  i_value                      10A   value  varying
      *
      *  return value
     D string          S           2000A   varying inz
      *
      *  helper fields
     D x               S             10I 0 inz
     D l               S             10I 0 inz
     D tmpKeyword      S                   like(i_keyword) inz
     D tmpString       S                   like(i_string ) inz
     D tmpCmd          S             10A   inz
      *-------------------------------------------------------------------*
      /FREE
         tmpKeyword = uCase(%trimR(i_keyword));
         tmpString  = uCase(%trimR(i_string ));
         x = %scan(' ': tmpString);
         if x = 0;
            return i_string;
         endif;
         tmpCmd = %subst(tmpString: 1: x);
         if tmpCmd <> 'CRTRPGMOD' and
            tmpCmd <> 'CRTRPGPGM' and
            tmpCmd <> 'CRTCLMOD'  and
            tmpCmd <> 'CRTCLPGM'  and
            tmpCmd <> 'CRTCBLMOD' and
            tmpCmd <> 'CRTCBLPGM' and
            tmpCmd <> 'CRTCMOD'   and
            tmpCmd <> 'CRTCPPMOD' and
            tmpCmd <> 'CRTBNDC'   and
            tmpCmd <> 'CRTBNDCBL' and
            tmpCmd <> 'CRTBNDCL'  and
            tmpCmd <> 'CRTBNDCPP' and
            tmpCmd <> 'CRTBNDDIR' and
            tmpCmd <> 'CRTBNDRPG' and
            tmpCmd <> 'CRTPGM'    and
            tmpCmd <> 'CRTSRVPGM' ;
            return i_string;
         endif;
         x = %scan(tmpKeyword + '(': tmpString);
         if x = 0;
            return %trimR(i_string) +
                   ' ' + tmpKeyword + '(' + %trimR(i_value) + ')';
         endif;
         l = %scan(')': tmpString: x + %len(i_keyword) + 1);
         if l = 0;
            return i_string;
         endif;
         l = l - x + 1;
         string = %replace(tmpKeyword + '(' + %trimR(i_value) + ')'
                           : i_string: x: l);
         Return string;
      /END-FREE
      *
     P setTargetRelease...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  Store field value.
      *---------------------------------------------------------------------------------------------
     P setVariable...
     P                 B
      *
     D setVariable...
     D                 PI
     D  i_fldName                    10A   value  varying
     D  i_value                      64A   value  varying
     D i               s             10I 0 inz
      *-------------------------------------------------------------------*
      /FREE
         if (i_fldName = '');
            return;
         endif;
         for i = 1 to fld_x;
            if (uCase('&' + %trim(i_fldName)) = uCase(fld_name(fld_x)));
               fld_value(fld_x) = i_value;
               leave;
            endif;
         endfor;
         if (fld_x >= %elem(fld_name));
            return;
         endif;
         fld_x = fld_x + 1;
         fld_name(fld_x)  = uCase('&' + %trim(i_fldName));
         fld_value(fld_x) = i_value;
      /END-FREE
      *
     P setVariable...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable name from statement.
      *---------------------------------------------------------------------------------------------
     P getVarName...
     P                 B
      *
     D getVarName...
     D                 PI            11a          varying
     D  i_bldexc                           value  like(bldexc)
     D  i_pos                        10i 0 value
     D name            s             11a   varying inz
     D CHARS           c                   '&ABCDEFGHIJKLMNOPQRSTUVWXYZ+
     D                                      1234567890_'
      *-------------------------------------------------------------------*
      /FREE
         dow (i_pos<=%len(i_bldexc) and
              %check(CHARS:%subst(i_bldexc:i_pos:1))=0);
            name = name+%subst(i_bldexc:i_pos:1);
            i_pos=i_pos+1;
         enddo;
         return name;
      /END-FREE
      *
     P getVarName...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  get variable value.
      *---------------------------------------------------------------------------------------------
     P getVarValue...
     P                 B
      *
     D getVarValue...
     D                 PI            64a          varying
     D  i_name                       11a   value  varying
     D i               s             10i 0 inz
     D value           s             64a   varying inz
      *-------------------------------------------------------------------*
      /FREE
         for i=1 to fld_x;
            if (ucase(fld_name(i))=uCase(i_name));
               value=%trimR(fld_value(i));
               leave;
            endif;
         endfor;
         return value;
      /END-FREE
      *
     P getVarValue...
     P                 E
      *---------------------------------------------------------------------------------------------
      *  convert to upper case
      *---------------------------------------------------------------------------------------------
     P uCase...
     P                 B
      *
     D uCase...
     D                 PI          2000A          varying
     D  i_string                   2000A   value  varying
     D uCase           s           2000A   inz varying
     D LC              C                   const('abcdefghijklmnopqrstuvwxyz')
     D UC              C                   CONST('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      *-------------------------------------------------------------------*
      /FREE
         uCase = %xlate(LC:UC:i_string);
         return uCase;
      /END-FREE
      *
     P uCase...
     P                 E
 